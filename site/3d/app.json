[{"name": "app.py", "content": "#\n# Heatmapper\n# 3D\n#\n# This file contains the Shiny application for 3D Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshiny run\n#\n# Exporting via ShinyLive is not currently supported, as pyvista\n# is not yet available in the Pyodide environment. Required libraries\n# include: openmpi, verdict, glew, alongside python libraries in requirements.txt\n# WebGL is required for this application.\n#\n\nfrom shiny import App, reactive, render, ui\nfrom pandas import DataFrame\nfrom os.path import basename\n\n# Shared functions\nfrom shared import Cache, MainTab, NavBar, FileSelection, Filter, ColumnType, TableOptions, InitializeConfig, ColorMaps, Update, Pyodide, Error\n\nif not Pyodide:\n\tfrom pyvista import Plotter, plotting, read_texture, read as VistaRead\n\nfrom py3Dmol import view\nfrom Bio.PDB import PDBParser, Structure, PDBIO\nfrom io import StringIO\nfrom matplotlib.cm import get_cmap\n\ntry:\n\tfrom user import config\nexcept ImportError:\n\tfrom config import config\n\n\ndef server(input, output, session):\n\n\t# Information regarding example files.\n\tInfo = {\n\t\t\"example1.csv\": {\n\t\t\t\"Object\": \"bunny.obj\",\n\t\t\t\"Description\": \"A bunny, mapped with random data.\"\n\t\t},\n\t\t\"texture.jpg\": {\n\t\t\t\"Object\": \"FinalBaseMesh.obj\",\n\t\t\t\"Description\": \"A human model with a sample heatmap texture applied. Sourced from https://free3d.com/3d-model/male-base-mesh-6682.html\"\n\t\t},\n\t\t\"4K8X.pdb\": {\n\t\t\t\"Description\": \"An example protein PDB from dash-bio at https://dash.plotly.com/dash-bio/molecule3dviewer\"\n\t\t}\n\t}\n\n\n\tdef HandleData(path):\n\t\t\"\"\"\n\t\t@brief A custom Data Handler for the Cache.\n\t\t@param n: The Path object to the file.\n\t\t@returns A data object from the cache.\n\t\t@info This Data Handler supports object files, and images as textures.\n\t\t\"\"\"\n\n\t\tsuffix = path.suffix\n\t\tif suffix == \".obj\": return None if Pyodide else VistaRead(path.resolve())\n\t\tif suffix == \".png\" or suffix == \".jpg\": return None if Pyodide else read_texture(path.resolve())\n\t\tif suffix == \".pdb\": return PDBParser().get_structure(\"protein\", str(path))\n\t\telse: return DataCache.DefaultHandler(path)\n\tDataCache = Cache(\"3d\", DataHandler=HandleData)\n\n\tData = reactive.value(None)\n\tValid = reactive.value(False)\n\tObject = reactive.value(None)\n\n\tInitializeConfig(config, input)\n\n\n\t@reactive.effect\n\t@reactive.event(input.SourceFile, input.File, input.Example, input.Reset, input.ID)\n\tasync def UpdateData(): \n\t\tif input.SourceFile() == \"ID\": \n\t\t\tData.set(input.ID())\n\t\telse: \n\t\t\tData.set((await DataCache.Load(input, default=None)))\n\t\tValid.set(False)\n\n\t@reactive.effect\n\t@reactive.event(input.SourceFile, input.Object, input.Example)\n\tasync def UpdateObject():\n\t\texample = input.Example()\n\t\tif not example.endswith(\".pdb\"):\n\t\t\tObject.set(await DataCache.Load(input,\n\t\t\t\tsource_file=input.Object(),\n\t\t\t\texample_file=Info[input.Example()][\"Object\"],\n\t\t\t\tdefault=None\n\t\t\t))\n\n\n\tdef GetData(): return Table.data_view() if Valid() else Data()\n\n\n\t@output\n\t@render.data_frame\n\tdef Table():\n\t\tdf = Data()\n\t\ttry:\n\t\t\tgrid = render.DataGrid(Data(), editable=True)\n\t\t\tValid.set(True)\n\t\t\treturn grid\n\t\texcept TypeError:\n\t\t\tError(\"The provided input format cannot be rendered\")\n\n\n\t@Table.set_patch_fn\n\tdef UpdateTable(*, patch: render.CellPatch) -> render.CellValue:\n\t\tif input.Type() == \"Integer\": value = int(patch[\"value\"])\n\t\telif input.Type() == \"Float\": value = float(patch[\"value\"])\n\t\telse: value = patch[\"value\"]\n\t\treturn value\n\n\n\tdef PDBViewer(source, p):\n\n\t\t# Store computations\n\t\tif input.SourceFile() == \"ID\":\n\t\t\tviewer = view(query=f\"pdb:{source}\", width=input.Size(), height=input.Size())\n\t\telse:\n\t\t\tinputs = [input.File() if input.SourceFile() == \"Upload\" else input.Example()]\n\t\t\tif not DataCache.In(inputs):\n\t\t\t\tpio = PDBIO()\n\t\t\t\tpio.set_structure(source)\n\n\t\t\t\tpdb_data = StringIO()\n\t\t\t\tpio.save(pdb_data)\n\t\t\t\tDataCache.Store(pdb_data.getvalue(), inputs)\n\t\t\tdata = DataCache.Get(inputs)\n\t\t\tviewer = view(data=data, width=input.Size(), height=input.Size())\n\n\t\tif config.ColorScheme() == \"b-factor\":\n\t\t\tviewer.startjs += \"\"\"\\n\n\t\t\t\tlet customColorize = function(atom){\n\t\t\t\t\tif (atom.b < 10) return \"blue\"\n\t\t\t\t\telse if (atom.b < 15) return \"lightblue\"\n\t\t\t\t\telse if (atom.b < 20) return \"white\"\n\t\t\t\t\telse if (atom.b < 40) return \"orange\"\n\t\t\t\t\telse return \"red\"\n\t\t\t\t}\\n\"\"\"\n\t\t\tcolor_property = \"colorfunc\"\n\t\t\tcolor_name = \"customColorize\"\n\n\t\telif config.ColorScheme() == \"spectrum\":\n\t\t\tcolor_property = \"color\"\n\t\t\tcolor_name = config.ColorScheme()\n\t\telse: \n\t\t\tcolor_property = \"colorscheme\"\n\t\t\tcolor_name = config.ColorScheme()\n\n\t\tviewer.setStyle({config.PStyle().lower(): {\n\t\t\tcolor_property: color_name,\n\t\t\t\"arrows\": \"Arrows\" in config.PFeatures(), \n\t\t\t\"style\": config.PCStyle().lower(),\n\t\t\t\"thickness\": config.Thickness(),\n\t\t\t\"tubes\": \"Tubes\" in config.PFeatures(),\n\t\t\t\"width\": config.Width(),\n\t\t\t\"opacity\": config.Opacity(),\n\t\t\t\"dashedBonds\": \"Dashed Bonds\" in config.PFeatures(),\n\t\t\t\"showNonBonded\": \"Show Non-Bonded\" in config.PFeatures(),\n\t\t\t\"singleBonds\": \"Single Bonds\" in config.PFeatures(),\n\t\t\t\"radius\": config.Radius(),\n\t\t\t\"scale\": config.Scale(),\n\t\t}})\n\n\t\tif color_property == \"colorfunc\": \n\t\t\tviewer.startjs = viewer.startjs.replace(f'\"{color_name}\"', f'{color_name}')\n\n\t\treturn ui.HTML(viewer.write_html())\n\n\n\tdef ModelViewer(source, p):\n\t\tif Pyodide:\n\t\t\tError(\"The Object Viewer is not supported in WebAssembly Mode!\")\n\t\t\treturn\n\n\t\tmodel = Object()\n\t\tif model is None: return\n\n\t\tp.inc(message=\"Plotting...\")\n\t\tpl = Plotter()\n\n\t\tstyle = config.Style().lower()\n\t\topacity = config.Opacity()\n\t\tfeatures = config.Features()\n\t\tcmap = config.ColorMap().lower()\n\t\tcolors = config.Colors()\n\n\t\t# If there's no source, just render the model\n\t\tif source is None:\n\t\t\tpl.add_mesh(\n\t\t\t\tmodel,\n\t\t\t\tstyle=style,\n\t\t\t\topacity=opacity,\n\t\t\t\tshow_edges=\"Edges\" in features,\n\t\t\t\tlighting=\"Lighting\" in features,\n\t\t\t\tinterpolate_before_map=\"Interpolation\" in features,\n\t\t\t\tsmooth_shading=\"Smooth Shading\" in features,\n\t\t\t)\n\n\t\t# If are data source is a table, render it as a heatmap.\n\t\telif type(source) is DataFrame:\n\t\t\tvalues = source[Filter(source.columns, ColumnType.Name, only_one=True)]\n\t\t\tpl.add_mesh(\n\t\t\t\tmodel,\n\t\t\t\tscalars=values,\n\t\t\t\tstyle=style,\n\t\t\t\tcmap=cmap,\n\t\t\t\topacity=opacity,\n\t\t\t\tn_colors=colors,\n\t\t\t\tshow_edges=\"Edges\" in features,\n\t\t\t\tlighting=\"Lighting\" in features,\n\t\t\t\tinterpolate_before_map=\"Interpolation\" in features,\n\t\t\t\tsmooth_shading=\"Smooth Shading\" in features,\n\t\t\t)\n\n\t\t# If we have a texture, map it.\n\t\telif type(source) is plotting.texture.Texture:\n\t\t\tmesh = model.texture_map_to_plane()\n\t\t\tpl.add_mesh(mesh, texture=source)\n\n\t\t# Exporting as None returns the HTML as a file handle, which we read.\n\t\tp.inc(message=\"Exporting...\")\n\t\treturn ui.HTML(pl.export_html(filename=None).read())\n\n\n\tdef GenerateHeatmap():\n\t\twith ui.Progress() as p:\n\n\t\t\t# Get the model and data. \n\t\t\tp.inc(message=\"Loading input...\")\n\n\t\t\tsource = GetData()\n\n\t\t\tif type(source) == Structure.Structure or input.SourceFile() == \"ID\":\n\t\t\t\treturn PDBViewer(source, p)\n\t\t\telif source is None: return\n\t\t\telse: return ModelViewer(source, p)\n\n\n\t@output\n\t@render.ui\n\tdef HeatmapReactive(): return GenerateHeatmap()\n\n\n\t@output\n\t@render.text\n\t@reactive.event(input.SourceFile, input.Example)\n\tdef ExampleInfo(): return Info[input.Example()][\"Description\"]\n\n\n\t@render.download(filename=\"table.csv\")\n\tdef DownloadTable():\n\t\tdf = GetData()\n\t\tif df is not None:\n\t\t\tyield df.to_string()\n\n\n\t@output\n\t@render.ui\n\tdef ConditionalElements():\n\t\telements = []\n\t\tdata = GetData()\n\n\t\tif data is None: return\n\t\telements.append(config.Opacity.UI(ui.input_slider, id=\"Opacity\", label=\"Heatmap Opacity\", min=0.0, max=1.0, step=0.1))\n\n\t\tif type(data) == Structure.Structure or input.SourceFile() == \"ID\":\n\t\t\telements += [\n\t\t\t\tconfig.PStyle.UI(ui.input_select, id=\"PStyle\", label=\"Style\", choices=[\"Cartoon\", \"Stick\", \"Sphere\", \"Line\", \"Cross\"]),\n\t\t\t\tconfig.ColorScheme.UI(ui.input_select, id=\"ColorScheme\", label=\"Color Scheme\", choices=[\"spectrum\", \"b-factor\", \"ssPyMol\", \"ssJmol\", \"Jmol\", \"amino\", \"shapely\", \"nucleic\", \"chain\", \"rasmol\", \"default\", \"greenCarbon\", \"cyanCarbon\", \"magentaCarbon\", \"purpleCarbon\", \"whiteCarbon\", \"orangeCarbon\", \"yellowCarbon\", \"blueCarbon\", \"chainHetatm\"]),\n\t\t\t\tconfig.PCStyle.UI(ui.input_select, id=\"PCStyle\", label=\"Cartoon Style\", choices=[\"Trace\", \"Oval\", \"Rectangle\", \"Parabola\", \"Edged\"]),\n\t\t\t\tconfig.Thickness.UI(ui.input_numeric, id=\"Thickness\", label=\"Strand Thickness\", min=0, max=10, step=0.1),\n\t\t\t\tconfig.Width.UI(ui.input_numeric, id=\"Width\", label=\"Strand Width\", min=0, max=10, step=1),\n\t\t\t\tconfig.Radius.UI(ui.input_numeric, id=\"Radius\", label=\"Radius\", min=0, max=5, step=0.05),\n\t\t\t\tconfig.Scale.UI(ui.input_numeric, id=\"Scale\", label=\"Scale\", min=0, max=10, step=1),\n\t\t\t\tconfig.Size.UI(ui.input_numeric, id=\"Size\", label=\"Viewer Size\", min=1, step=1),\n\t\t\t\tconfig.PFeatures.UI(ui.input_checkbox_group, id=\"PFeatures\", label=\"PDB Features\", choices=[\"Dashed Bonds\", \"Show Non-Bonded\", \"Single Bonds\", \"Tubes\"]),\n\t\t\t]\t\n\n\t\telse:\n\t\t\telements.append(ui.panel_conditional(\"input.SourceFile === 'Upload'\", ui.input_file(\"Object\", \"Choose an Object File\", accept=[\".obj\"], multiple=False)))\n\t\t\tif type(data) == DataFrame:\n\t\t\t\telements += [\n\t\t\t\t\tconfig.Colors.UI(ui.input_slider, id=\"Colors\", label=\"Number of Colors\", value=256, min=1, max=256, step=1),\n\t\t\t\t\tconfig.ColorMap.UI(ui.input_select, id=\"ColorMap\", label=\"Color Map\", choices=ColorMaps),\n\t\t\t\t\tconfig.Style.UI(ui.input_select, id=\"Style\", label=\"Style\", choices=[\"Surface\", \"Wireframe\", \"Points\"]),\n\t\t\t\t\tconfig.Features.UI(ui.input_checkbox_group, id=\"Features\", label=\"Heatmap Features\", choices=[\"Edges\", \"Lighting\", \"Interpolation\", \"Smooth Shading\"]),\n\t\t\t]\n\n\t\treturn elements\n\n\n\napp_ui = ui.page_fluid(\n\n\tNavBar(),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\t\t\tFileSelection(\n\t\t\t\texamples={\"4K8X.pdb\": \"Example 1\", \"example1.csv\": \"Example 2\", \"texture.jpg\": \"Example 3\"}, \n\t\t\t\ttypes=[\".csv\", \".txt\", \".dat\", \".tsv\", \".tab\", \".xlsx\", \".xls\", \".odf\", \".png\", \".jpg\", \".pdb\"], \n\t\t\t\tproject=\"3D\",\n\t\t\t\textras=[\"ID\"]),\n\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.SourceFile === 'ID'\",\n\t\t\t\tui.input_text(id=\"ID\", label=\"PDB ID\", value=\"1upp\"),\n\t\t\t),\n\n\t\t\tTableOptions(config),\n\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'HeatmapTab'\",\n\n\t\t\t\tui.output_ui(id=\"ConditionalElements\")\n\t\t\t)\n\t\t),\n\n\t\t# Add the main interface tabs.\n\t\tMainTab(m_type=ui.output_ui),\n\t\theight=\"90vh\",\n\t)\n)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "config.py", "content": "#\n# Heatmapper \n# 3D Configuration\n#\n# This file contains configuration for 3D. \n\n\nfrom shared import Config, ConfigHandler\n\nconfig = ConfigHandler({\n\n\t# \"Distance\", \"Correlation\"\n\t\"Opacity\": Config(value=1.0),\n\n\t# Any numerical value between 1 and 256.\n\t\"Colors\": Config(value=256),\n\n\t# \"Viridis\", \"Plasma\", \"Inferno\", \"Magma\", \"Cividis\"\n\t\"ColorMap\": Config(selected=\"Viridis\"),\n\n\t# \"Integer\" \"Float\" \"String\"\n\t\"Type\": Config(selected=\"Integer\"),\n\n\t# \"Surface\", \"Wireframe\", \"Points\"\n\t\"Style\": Config(selected=\"Surface\"),\n\n\t# Combination of \"Edges\", \"Lighting\", \"Interpolation\", \"Smooth Shading\"\n\t\"Features\": Config(selected=[\"Lighting\", \"Interpolation\", \"Smooth Shading\"]),\n\n\t# \"Cartoon\", \"Stick\", \"Sphere\", \"Line\"\n\t\"PStyle\": Config(selected=\"Cartoon\"),\n\n\t# See 3D's ConditionalElements function for details\n\t\"ColorScheme\": Config(selected=\"spectrum\"),\n\n\t# Can vary depending on PStyle. See ConditionalElements for details.\n\t\"PFeatures\": Config(selected=[]),\n\n\t# \"Trace\", \"Oval\", \"Rectangle\", \"Parabola\", \"Edged\"\n\t\"PCStyle\": Config(selected=\"Rectangle\"),\n\n\t# Any value from 0-10\n\t\"Thickness\": Config(value=0.4),\n\n\t# Any value from 0-10\n\t\"Width\": Config(value=3),\n\n\t# Any value from 0-10\n\t\"Radius\": Config(value=0.25),\n\n\t# Any value from 0-10\n\t\"Scale\": Config(value=1),\n\n\t# Any numerical value\n\t\"Size\": Config(value=600),\n})", "type": "text"}, {"name": "requirements.txt", "content": "# shinylive will try and pull these, but they aren't supported in WASM yet\n# pyvista\n# trame\n# vtk\n# trame-vtk\n# meshio\n# pywebview\n# trame-vuetify\n# nest_asyncio\nbiopython\npy3Dmol\n", "type": "text"}, {"name": "shared.py", "content": "#\n# Heatmapper\n# Shared\n#\n# This file contains shared functionality between Heatmapper applications. It is not a standalone application.\n# Due to the way ShinyLive exports applications, this file is symlinked into each project to reduce redundancy.\n#\n\nfrom shiny import ui, reactive\nfrom shiny.types import FileInfo\nfrom pandas import DataFrame, read_csv, read_excel, read_table\nfrom io import BytesIO\nfrom tempfile import NamedTemporaryFile\nfrom sys import modules\nfrom pathlib import Path\nfrom enum import Enum\nfrom os.path import exists\nfrom copy import deepcopy\n\n# Used for fetching web resources in a variety of fashions.\nURL = \"https://wishartlab.github.io/heatmapper2\"\nRaw = \"https://raw.githubusercontent.com/WishartLab/heatmapper2/main\"\n\n# Define the Server and Port of the Shiny instances (Port is incremented)\n# Change these if Heatmapper is running on a server.\nServer = \"http://35.208.86.138\"\nPort = 8000\n\n# Detect the running environment\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tPyodide = True\nelse:\n\tPyodide = False\n\n# Shared Values\nColors = [\"Blue\", \"Orange\", \"Green\", \"Red\", \"Purple\", \"Brown\", \"Pink\", \"Gray\", \"Olive\", \"Cyan\", \"White\", \"Yellow\"]\nDistanceMethods = [\"Braycurtis\", \"Canberra\", \"Chebyshev\", \"Cityblock\", \"Correlation\", \"Cosine\", \"Dice\", \"Euclidean\", \"Hamming\", \"Jaccard\", \"Jensenshannon\", \"Kulczynski1\", \"Matching\", \"Minkowski\", \"Rogerstanimoto\", \"Russellrao\", \"Seuclidean\", \"Sokalmichener\", \"Sokalsneath\", \"Sqeuclidean\", \"Yule\"]\nInterpolationMethods = [\"None\", \"Antialiased\", \"Nearest\", \"Bilinear\", \"Bicubic\", \"Spline16\", \"Spline36\", \"Hanning\", \"Hamming\", \"Hermite\", \"Kaiser\", \"Quadric\", \"Catrom\", \"Gaussian\", \"Bessel\", \"Mitchell\", \"Sinc\", \"Lanczos\", \"Blackman\"]\nClusteringMethods = [\"Single\", \"Complete\", \"Average\", \"Weighted\", \"Centroid\", \"Median\", \"Ward\"]\nColorMaps = [\"Viridis\", \"Plasma\", \"Inferno\", \"Magma\"]\n\nclass ColumnType(Enum): Time = 0; Name = 1; Value = 2; Longitude = 3; Latitude = 4; X = 5; Y = 6; Z = 7; Cluster = 8; Free = 9; Spatial = 10; NameGeoJSON = 11;\nColumns = {\n\tColumnType.Time: {\"time\", \"date\", \"year\"},\n\tColumnType.Name: {\"name\", \"orf\", \"uniqid\", \"face\", \"triangle\", \"iso_code\", \"continent\", \"country\", \"location\"},\n\tColumnType.Value: {\"value\", \"weight\", \"intensity\", \"in_tissue\"},\n\tColumnType.Longitude: {\"longitude\", \"long\"},\n\tColumnType.Latitude: {\"latitude\", \"lat\"},\n\tColumnType.X: {\"x\"},\n\tColumnType.Y: {\"y\"},\n\tColumnType.Z: {\"z\"},\n\tColumnType.Cluster: {\"cell type\", \"celltype_mapped_refined\", \"cluster\", \"cell_class\", \"cell_subclass\", \"cell_cluster\"},\n\tColumnType.Free: {None},\n\tColumnType.Spatial: {\"spatial\"},\n\tColumnType.NameGeoJSON: {\"name\", \"admin\", \"iso_a3\", \"iso_a2\", \"iso\"}\n}\n\n\ndef Filter(columns, ctype: ColumnType, good: list = [], bad: list = [], only_one=False, reject_unknown=False):\n\t\"\"\"\n\t@brief Filters available column names based on what input we want\n\t@param columns: The columns of the DataFrame (Usually just df.columns)\n\t@param ctype: The type of column we're looking for (Look at the ColumnType Enum)\n\t@param good: A list of column names on top of those defined by the type to be included\n\t@param bad: A list of column names on top of those defined by the type to be excluded from the result.\n\t@param only_one: Only return a single result, so the variable can be used immediately.\n\t@param reject_unknown: Only include columns explicitly defined\n\t@return: A list of column names to use.\n\t\"\"\"\n\n\t# Fold cases\n\tfolded = [column.lower() for column in columns]\n\n\t# Add and remove what user asked for, filtering None\n\toptions = set(folded)\n\tif bad: options -= set([b.lower() for b in bad if b])\n\tif good: options &= set([g.lower() for g in good if g])\n\n\t# Take an intersection of our columns and the type we want. If there is a match, return those\n\t# Otherwise, remove all columns we know it shouldn't be, and return that instead.\n\tintersection = options & Columns[ctype]\n\tif intersection or reject_unknown: options = intersection\n\telse:\n\t\tfor key, value in Columns.items():\n\t\t\tif key != ctype: options -= value\n\n\t# Get the valid indices, and sort them in ascending order\n\tindices = [folded.index(value) for value in options]\n\tindices.sort()\n\n\t# Get the original column names, without case-folding, and return as a list.\n\treassembled = [columns[index] for index in indices]\n\tif not reassembled: return None\n\treturn reassembled[0] if only_one else reassembled\n\n\ndef UpdateColumn(columns, ctype, default, id, **kwargs):\n\t\"\"\"\n\t@brief Update a input_select element based on columns\n\t@pararm columns: The list of columns to source\n\t@param ctype: The ColumnType to search for\n\t@param default: The default value to use\n\t@param id: The ID of the UI element\n\t@param kwargs: Keyword arguments to be passed to filter. \n\t@returns The new value of the element..\n\t\"\"\"\n\n\tfiltered = Filter(columns, ctype, **kwargs)\n\tif filtered is None: return\n\tselected = default if default in columns else filtered[0]\n\tui.update_select(id=id, choices=filtered, selected=selected)\n\treturn selected\n\n\nclass Cache:\n\t\"\"\"\n\t@brief A class that encompasses fetching/storing web resources.\n\t\"\"\"\n\n\t@staticmethod\n\tdef HandleDataFrame(path, function):\n\t\t\"\"\"\n\t\t@brief Handle DataFrame's\n\t\t@param i: The binary of the file\n\t\t@param function: The pandas function to use to read the file.\n\t\t@returns A DataFrame\n\t\t\"\"\"\n\n\t\t# Read the table once.\n\t\tdf = function(path.resolve()).fillna(0)\n\n\t\t# If the first column value is a float, we assume it's data, and not column names.\n\t\t# Re-read the DataFrame with generic column names instead\n\t\ttry:\n\t\t\tfloat(df.columns[0])\n\t\t\tdf = function(path.resolve(), header=None, names=[f\"Column {i}\" for i in range(df.shape[1])])\n\t\texcept ValueError: pass\n\t\treturn df\n\n\n\t@staticmethod\n\tdef DefaultHandler(path):\n\t\t\"\"\"\n\t\t@brief The default handler. It can handle csv, xlsx, and defaults all other files to read_table\n\t\t@param n: The path to the file\n\t\t@returns: An object, if the provided file is supported, None otherwise.\n\t\t\"\"\"\n\n\t\tsuffix = path.suffix\n\t\tif suffix == \".csv\": return Cache.HandleDataFrame(path, read_csv)\n\t\telif suffix == \".xlsx\" or suffix == \".xls\" or suffix == \".odf\": return Cache.HandleDataFrame(path, read_excel)\n\t\telse: return Cache.HandleDataFrame(path, read_table)\n\n\n\tasync def _remote(self, url):\n\t\t\tr = await pyfetch(url);\n\t\t\tif not r.ok: return None\n\t\t\treturn await r.bytes()\n\n\n\tasync def _local(self, url):\n\t\tif not exists(url): return None\n\t\treturn Path(url)\n\n\n\tdef __init__(self, project, DataHandler = DefaultHandler):\n\t\t\"\"\"\n\t\t@brief Initialize an instance of the Cache object.\n\t\t@param project: The name of the project. This is used to fetch web resources.\n\t\t@param DataHandler:\tThe function that should be called to process files. It should\n\t\t\t\t\t\t\t\t\t\t\t\ttake a name, and a binary stream, and return a DataFrame.\n\t\t\"\"\"\n\n\t\t# The primary is the unprocessed, fetched web resources\n\t\tself._primary = {}\n\n\t\t# The objects are anything that applications want to store\n\t\tself._objects = {}\n\n\t\t# The data handler for processing the binary files.\n\t\tself._handler = DataHandler\n\n\t\t# If we're in a Pyodide environment, we fetch resources from the web.\n\t\tif Pyodide:\n\t\t\tself._download = lambda url: self._remote(url)\n\t\t\tself._source = f\"{Raw}/{project}/example_input/\"\n\n\t\t# Otherwise, we fetch locally.\n\t\telse:\n\t\t\tself._download = lambda url: self._local(url)\n\t\t\tself._source = \"../example_input/\"\n\n\n\tasync def Load(self, \n\t\tinput, \n\t\tsource_file=None, \n\t\texample_file=None, \n\t\tsource=None, \n\t\tinput_switch=None, \n\t\tupload=\"Upload\",\n\t\texample=\"Example\",\n\t\tdefault=DataFrame()\n\t\t):\n\n\t\t\"\"\"\n\t\t@brief Caches whatever the user has currently uploaded/selection, returning the identifier within the secondary cache.\n\t\t@param input: The Shiny input variable. Importantly, these must be defined:\n\t\t\tinput.File: The uploaded file\n\t\t\tinput.Example: The selected example file\n\t\t\tinput.SourceFile: Whether the user wants \"Upload\" or \"Example\"\n\t\t@param source_file: The input ID that should be used to fetch the file (Defaults to input.File() if None)\n\t\t@param example_file: The input ID that should be used to fetch th example (Defaults to input.Example() if None)\n\t\t@param input_switch:\tThe input ID to check for Upload/Example/Other. The value is compared against \"Upload\" for user\n\t\t\t\t\t\t\t\t\t\t\t\t\tuploaded items, and defaults to fetching example_file otherwise. (Defaults to input.SourceFile())\n\t\t@param upload: The value of the input_switch such that we should fetch a source file from source_file\n\t\t@param example: The value of the input_switch such that we should fetch an example from example_file\n\t\t@param default:\tThe object that should be returned if files cannot be fetched. Ensures that Load will always return an\n\t\t\t\t\t\t\t\t\t\tobject, avoiding the needing to check output. Defaults to a DataFrame. The object should be able to\n\t\t\t\t\t\t\t\t\t\tinitialize without arguments.\n\t\t\"\"\"\n\n\t\tif source_file is None: source_file = input.File()\n\t\tif example_file is None: example_file = input.Example()\n\t\tif source is None: source = self._source\n\t\tif input_switch is None: input_switch = input.SourceFile()\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input_switch == upload:\n\t\t\tfile: list[FileInfo] | None = source_file\n\t\t\tif file is None: return default\n\n\t\t\t# The datapath can be immediately used to load examples, but we explicitly need to use\n\t\t\t# Local as a user uploaded file will always be fetched on disk.\n\t\t\tn = str(file[0][\"datapath\"])\n\t\t\tif n not in self._primary: self._primary[n] = self._handler(Path(n))\n\n\t\t# Example files, conversely, can be on disk or on a server depending on whether we're in a WASM environment.\n\t\telif input_switch == example:\n\n\t\t\t# If we explicitly provide a URL, use it, but only in Pyodide (We still assume the file exists on disk when running \n\t\t\t# in server-mode).\n\t\t\tif example_file.startswith(\"https://\"):\n\t\t\t\tn = example_file if Pyodide else str(source + example_file.split(\"/\")[-1])\n\t\t\telse:\n\t\t\t\tn = str(source + example_file)\n\t\t\traw = await self._download(n)\n\n\t\t\t# WASM needs a temporary file, but they are deleted out of their scope.\n\t\t\tif Pyodide:\n\t\t\t\ttemp = NamedTemporaryFile(suffix=Path(n).suffix); \n\t\t\t\ttemp.write(BytesIO(raw).read()); temp.seek(0)\n\t\t\t\tif n not in self._primary: self._primary[n] = self._handler(Path(temp.name))\n\n\t\t\telif n not in self._primary: self._primary[n] = self._handler(raw)\n\n\t\t# If the application has a unique method of input (IE 3D's ID, don't handle it.)\n\t\telse: return None\n\n\t\t# If the object cannot be copied, then we can just return it directly\n\t\ttry:\n\t\t\treturn deepcopy(self._primary[n])\n\t\texcept AttributeError:\n\t\t\treturn self._primary[n]\n\n\n\tdef Store(self, object, inputs):\n\t\t\"\"\"\n\t\t@brief Store arbitrary data in the Cache.\n\t\t@param object: The object to store\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\th = \"\".join(str(i) for i in inputs)\n\t\tself._objects[h] = object\n\n\n\tdef Get(self, inputs):\n\t\t\"\"\"\n\t\t@brief Retrieve arbitrary data in the Cache.\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\th = \"\".join(str(i) for i in inputs)\n\t\tif h in self._objects:\n\t\t\t\treturn self._objects[h]\n\t\telse: return None\n\n\tdef In(self, inputs):\n\t\th = \"\".join(str(i) for i in inputs)\n\t\treturn h in self._objects\n\n\ndef NavBar():\n\t\"\"\"\n\t@brief Returns a Navigation Bar for each project, with the current project selected.\n\t@returns A list, containing a ui.panel_title, and a ui.navset_bar.\n\t\"\"\"\n\n\tSources = {\n\t\t\"expression\": f\"{URL}/site/expression/index.html\" if Pyodide else f\"{Server}:{Port}\",\n\t\t\"pairwise\": f\"{URL}/site/pairwise/index.html\" if Pyodide else f\"{Server}:{Port + 1}\",\n\t\t\"image\": f\"{URL}/site/image/index.html\" if Pyodide else f\"{Server}:{Port + 2}\",\n\t\t\"geomap\": f\"{URL}/site/geomap/index.html\" if Pyodide else f\"{Server}:{Port + 3}\",\n\t\t\"geocoordinate\": f\"{URL}/site/geocoordinate/index.html\" if Pyodide else f\"{Server}:{Port + 4}\",\n\t\t\"3d\": f\"{Server}:{Port + 5}\",\n\t\t\"spatial\": f\"{Server}:{Port + 6}\",\n\t}\n\n\treturn (\n\t\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\t\tui.navset_bar(\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"expression\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Expression</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"pairwise\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Pairwise</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"image\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Image</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geomap\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geomap</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geocoordinate\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geocoordinate</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"3d\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">3D</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"spatial\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Spatial</a>')),\n\t\t\tui.nav_control(ui.HTML('<a href=https://github.com/WishartLab/heatmapper2/wiki target=\"_blank\" rel=\"noopener noreferrer\">About</a>')),\n\t\t\tui.nav_spacer(),\n\t\t\tui.nav_control(ui.input_dark_mode(id=\"mode\")),\n\t\t\ttitle=ui.HTML(\n\t\t\t\tf'<a href=\"{URL}\" target=\"_blank\" rel=\"noopener noreferrer\"> \\\n\t\t\t\t\t<img src=\"{Raw}/site/logo.png\" alt=\"Heatmapper\"> \\\n\t\t\t\t</a>'),\n\t\t),\n\t)\n\n\ndef FileSelection(examples, types, upload_label=\"Choose a File\", multiple=False, default=\"Upload\", project=\"Overview\", extras=[]):\n\t\"\"\"\n\t@brief Returns the file selection dialog for the user to upload/select an example\n\t@param examples: Either a list of example file names, or a dictionary mapping\n\t@param types: The valid file extensions for user uploaded files.\n\t@param upload_label: The label for the upload input. Useful to define specifically what kind of files are needed\n\t@param multiple: Whether to accept multiple files. \n\t@param default: Whether to start on the example, or upload dialog\n\t@param project: The name of a project, to specify a specified header within the Interface documentation\n\t@param extras: Extra options for giving the application information no render. You are responsible for handling it.\n\t@returns A list, containing the necessary ui components for uploading/selecting\n\t@info The returns elements are named:\n\t\tinput.SourceFile: The ui.input_radio_buttons for whether the user wants to choose an \"Example\" or \"Upload\"\n\t\tinput.File: The ui.input_file for user uploaded files.\n\t\tinput.Example: The ui.input_select for an example file selection\n\t@info multiple=True is not handled properly by the Cache. You will need to create a function that properly handles\n\t\teach file (See spatial for an implementation)\n\t@info If you're examples are large files, or require significant computation, you may want to switch it to Upload instead.\n\t\"\"\"\n\n\t# If the user needs help with the formatting.\n\treturn [\n\tui.layout_columns(\n\t\tui.HTML(\"<a href=https://github.com/WishartLab/heatmapper2/wiki/Format target='_blank' rel='noopener noreferrer'>Format</a>\"),\n\t\tui.HTML(f\"<a href='https://github.com/WishartLab/heatmapper2/wiki/Interface#{project}' target='_blank' rel='noopener noreferrer'>Help</a>\"),\n\t\tcol_widths=[6,6]\n\t),\n\n\t# Specify whether to use example files, or upload one.\n\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"] + extras, selected=default, inline=True),\n\n\t# Only display an input dialog if the user is one Upload\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Upload'\",\n\t\tui.input_file(\"File\", upload_label, accept=types, multiple=multiple),\n\t),\n\n\t# Otherwise, add the example selection and an info button.\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Example'\",\n\t\tui.layout_columns(\n\t\t\tui.input_select(id=\"Example\", label=None, choices=examples, multiple=False),\n\t\t\tui.popover(ui.input_action_link(id=\"ExampleInfoButton\", label=\"Info\"), ui.output_text(\"ExampleInfo\")),\n\t\t\tcol_widths=[7,3],\n\t\t)\n\t),\n\t]\n\n\ndef TableOptions(config):\n\t\"\"\"\n\t@brief Return the options for Table Manipulation.\n\t@returns A conditional panel that provides a DataType, and a ResetButton.\n\t\"\"\"\n\treturn  ui.panel_conditional(\n\t\t\"input.MainTab === 'TableTab'\",\n\t\tconfig.Type.UI(ui.input_radio_buttons, id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"], inline=True),\n\t\tui.input_action_button(id=\"Reset\", label=\"Reset Values\"),\n\t\tui.download_button(id=\"DownloadTable\", label=\"Download Table\"),\n\t),\n\n\ndef MainTab(*args, m_type=ui.output_plot):\n\treturn ui.navset_tab(\n\t\tui.nav_panel(\"Heatmap\",\n\t\t\tui.panel_conditional(\"input.UpdateToggle\", m_type(id=\"Heatmap\")),\n\t\t\tui.panel_conditional(\"!input.UpdateToggle\", m_type(id=\"HeatmapReactive\")), \n\t\t\tvalue=\"HeatmapTab\"\n\t\t),\n\t\tui.nav_panel(\"Table\", ui.output_data_frame(id=\"Table\"), value=\"TableTab\"),\n\t\t*args,\n\t\tid=\"MainTab\"\n\t)\n\n\nclass Config:\n\t\"\"\"\n\t@brief A configuration entry.\n\t\"\"\"\n\n\tdef __init__(self, visible=True, **kwargs):\n\t\t\"\"\"\n\t\t@brief Create a configuration entry.\n\t\t@param default: The default value for an input.\n\t\t@param visible: Whether the input should be shown in the sidebar\n\t\t@param **kwargs: Arguments to be passed to the input.\n\t\t\"\"\"\n\t\tself.visible = visible\n\t\tself.kwargs = kwargs\n\t\tif \"selected\" in kwargs:\n\t\t\tself.default = kwargs[\"selected\"]\n\t\telif \"value\" in kwargs:\n\t\t\tself.default = kwargs[\"value\"]\n\t\telse:\n\t\t\tself.default = None\n\t\tself.resolve = None\n\n\n\tdef __call__(self): \n\t\ttry:\n\t\t\tresolved = self.resolve()\n\t\t\treturn self.default if resolved is None else resolved\n\t\texcept Exception:\n\t\t\treturn self.default\n\n\n\tdef Resolve(self, input): \n\t\tself.resolve = input\n\n\n\tdef UI(self, ui, *args, **kwargs):\n\t\t\"\"\"\n\t\t@brief Displays the configured UI.\n\t\t@param ui The Shiny interface element to use.\n\t\t@parram **kwargs: Additional arguments to be passed to the input.\n\t\t@note\tkeyword arguments passed to the Config object during initialization will overrule\n\t\t\t\t\targuments passed to this function. Duplicates are allowed.\n\t\t\"\"\"\n\n\t\t# Remove duplicates.\n\t\tduplicates = []\n\t\tfor key in kwargs.keys():\n\t\t\tif key in self.kwargs: duplicates.append(key)\n\t\tfor key in duplicates: del kwargs[key]\n\n\t\t# Return the correct UI.\n\t\tif self.visible: return ui(*args, **kwargs, **self.kwargs)\n\n\nclass ConfigHandler(dict):\n\t\"\"\"\n\t@brief: A dictionary that can be accessed with dots, and can automatically resolve.\n\t\"\"\"\n\n\t__getattr__ = dict.get\n\t__setattr__ = dict.__setitem__\n\t__delattr__ = dict.__delitem__\n\n\n\tdef Resolve(self, input): \n\t\t\"\"\"\n\t\t@brief Resolves all stored objects.\n\t\t@param input The input to use for resolving.\n\t\t\"\"\"\n\t\tfor conf, var in self.items():\n\t\t\tvar.Resolve(input[conf])\n\n\ndef InitializeConfig(config, input): \n\t\"\"\"\n\t@brief Initializes the configuration variable.\n\t@param config: The configuration variable\n\t@param input: The Shiny input\n\n\tThis function will update each configuration's resolve member, so that\n\tif \n\t\"\"\"\n\tfor conf, var in config.items(): var.Resolve(input[conf])\n\n\ndef GenerateConditionalElements(pairs):\n\telements = []\n\tfor conditional, element in pairs:\n\t\tif conditional: elements.append(element)\n\treturn elements\n\n\ndef Error(message):\n\treturn ui.notification_show(ui=message, type=\"error\", duration=3)\n\n\ndef Update(): return ui.input_action_button(\n\t\tid=\"Update\", \n\t\tlabel=ui.layout_columns(\n\t\t\tui.panel_conditional(\"input.UpdateToggle\", \"Auto\"),\n\t\t\t\"Update\",\n\t\t\tui.input_switch(id=\"UpdateToggle\", label=None, value=True),\n\t\t\tcol_widths=[1,9,1],\n\t\t\tgap=\"1px\",\n\t\t\theight=\"1px\", \t# Make it as small as possible\n\t\t)\n\t)", "type": "text"}]