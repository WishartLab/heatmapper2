[{"name": "app.py", "content": "#\n# Heatmapper\n# Pairwise\n#\n# This file contains the ShinyLive application for Pairwise Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshinylive export . [site]\n# Where [site] is the destination of the site folder.\n#\n# If you would rather deploy the application as a PyShiny application,\n# run the following command within this directory:\n#\t\tshiny run\n#\n#\n\n\nfrom shiny import App, reactive, render, ui, types\nfrom matplotlib.pyplot import subplots, colorbar\nfrom scipy.spatial.distance import pdist, squareform\nfrom matplotlib.colors import LinearSegmentedColormap\nfrom Bio.PDB import PDBParser\nfrom Bio import SeqIO\nfrom pandas import DataFrame\nfrom tempfile import NamedTemporaryFile\nfrom io import BytesIO\n\nfrom shared import Cache, NavBar, MainTab, Filter, ColumnType, FileSelection, TableOptions, Colors, DistanceMethods, InterpolationMethods, InitializeConfig, Error\n\ntry:\n\tfrom user import config\nexcept ImportError:\n\tfrom config import config\n\n\ndef server(input, output, session):\n\n\t# Information about the Examples\n\tInfo = {\n\t\t\"example1.txt\": \"This example dataset represents pairwise distances between C-alpha atoms in ubiquitin (1ubq).\",\n\t\t\"example2.txt\": \"This example dataset was generated randomly.\",\n\t\t\"example3.txt\": \"This example dataset was generated randomly.\",\n\t\t\"example4.fasta\": \"An example FASTA file.\",\n\t\t\"ala_phe_ala.pdb\": \"An example PDB file.\",\n\t}\n\n\tdef HandleData(path):\n\t\tsuffix = path.suffix\n\t\tif suffix == \".pdb\": return PDBMatrix(path.resolve())\n\t\telif suffix == \".fasta\": return FASTAMatrix(path.resolve())\n\t\telse: return ChartMatrix(DataCache.DefaultHandler(path))\n\n\n\tDataCache = Cache(\"pairwise\", HandleData)\n\tData = reactive.value(None)\n\tValid = reactive.value(False)\n\n\tInitializeConfig(config, input)\n\n\n\t# We add Matrix and Method as they are calculated in the Matrix handlers.\n\t@reactive.effect\n\t@reactive.event(input.SourceFile, input.File, input.Example, input.Reset)\n\tasync def UpdateData():\n\t\twith ui.Progress() as p:\n\t\t\tp.inc(message=\"Loading Data...\")\n\t\t\tData.set((await DataCache.Load(input)))\n\t\t\tValid.set(False)\n\n\n\tdef GetData(): return Table.data_view() if Valid() else Data()\n\n\n\tdef FASTAMatrix(file):\n\t\t\"\"\"\n\t\t@brief Computes the pairwise matrix from a FASTA file.\n\t\t@param file: The path to the FASTA File\n\t\t@returns a pairwise matrix.\n\t\t\"\"\"\n\n\t\t# Get information from the file\n\t\trecords = list(SeqIO.parse(open(file), \"fasta\"))\n\t\tsequences = [str(record.seq) for record in records]\n\t\tcolumn_names = [record.id for record in records]\n\n\t\t# Get our K-Mer value\n\t\tk = config.K()\n\n\t\t# Generate the value\n\t\tdictionary = {}\n\t\tfor x, seq in enumerate(sequences):\n\t\t\tkmers = [seq[i:i+k] for i in range(len(seq) - k + 1)]\n\t\t\tincrement = 1 / len(kmers)\n\t\t\tfor kmer in kmers:\n\t\t\t\t\tif kmer not in dictionary:\n\t\t\t\t\t\t\tdictionary[kmer] = [0.0] * len(sequences)\n\t\t\t\t\tdictionary[kmer][x] += increment\n\t\treturn DataFrame.from_dict(dictionary, orient='index', columns=column_names)\n\n\n\tdef PDBMatrix(file):\n\t\t\"\"\"\n\t\t@brief Generates a pairwise matrix from a PDB file\n\t\t@param file: The path to a PDB file (Or BytesIO file if applicable)\n\t\t@returns The pairwise matrix.\n\t\t\"\"\"\n\n\t\tparser = PDBParser()\n\t\tstructure = parser.get_structure(\"protein\", file)\n\n\t\t# Extract atomic coordinates\n\t\tcoordinates = []\n\t\tfor model in structure:\n\t\t\tfor chain in model:\n\t\t\t\t\tif chain.id == config.Chain():\n\t\t\t\t\t\t\tfor residue in chain:\n\t\t\t\t\t\t\t\t\tfor atom in residue:\n\t\t\t\t\t\t\t\t\t\t\tcoordinates.append(atom.coord)\n\t\treturn DataFrame(coordinates)\n\n\n\tdef ChartMatrix(df):\n\t\t\"\"\"\n\t\t@brief Generates a pairwise matrix from charts\n\t\t@param df:\tThe DataFrame containing the data. This can either be a chart\n\t\t\t\t\t\t\t\tcontaining {x,y,z} columns outlining each point on a row, with\n\t\t\t\t\t\t\t\tan optional name column (Any fourth column), a chart to which\n\t\t\t\t\t\t\t\tan explicit \"Name\" column is provided, to which the first row\n\t\t\t\t\t\t\t\tand column are assumed variable names for an existing matrix,\n\t\t\t\t\t\t\t\tor the default, where it is assumed that the chart is an\n\t\t\t\t\t\t\t\tunlabeled collection either of points, or an existing matrix.\n\t\t@returns A DataFrame containing the provided data as a pairwise matrix\n\t\t\"\"\"\n\n\t\t# If \"Name\" is found, its assumed to be the label for the points.\n\t\tname_col = Filter(df.columns, ColumnType.Name, only_one=True, reject_unknown=True)\n\t\tif name_col: point_names = df[name_col]\n\n\t\t# If explicit coordinates are provided, use them, with the final column used as labels.\n\t\tx_col = Filter(df.columns, ColumnType.X, only_one=True, reject_unknown=True)\n\t\ty_col = Filter(df.columns, ColumnType.Y, only_one=True, reject_unknown=True)\n\t\tz_col = Filter(df.columns, ColumnType.Z, only_one=True, reject_unknown=True)\n\n\t\tif x_col and y_col and z_col:\n\t\t\tcoordinates = df[[x_col, y_col, z_col]].values\n\t\t\tpoint_names = df[list(set(df.columns) - set([x_col, y_col, z_col]))[0]].values\n\n\t\telse:\n\n\t\t\t# If the first value is an integer, this is a distance matrix.\n\t\t\ttry:\n\t\t\t\tfloat(df.iloc[0,0])\n\t\t\t\tcoordinates = df.values\n\t\t\t\tpoint_names = df.columns\n\n\t\t\t# Otherwise, we assume the first row/column define the axis names.\n\t\t\texcept ValueError:\n\t\t\t\tcoordinates = df.iloc[:, 1:].values\n\t\t\t\tpoint_names = df.columns[1:]\n\t\treturn DataFrame(coordinates, columns=point_names, index=point_names).T\n\n\n\t@output\n\t@render.data_frame\n\tdef Table():\n\t\tdf = Data()\n\t\tif df is None or len(df.columns) == 0: return\n\n\t\tif df.columns[0] == 0:\n\t\t\tui.modal_show(ui.modal(\"The provided input format cannot be rendered\",\n\t\t\ttitle=\"Table cannot be rendered\", easy_close=True, footer=None))\n\t\telse: \n\t\t\tValid.set(True)\n\t\t\treturn render.DataGrid(Data(), editable=True)\n\n\n\t@Table.set_patch_fn\n\tdef UpdateTable(*, patch: render.CellPatch) -> render.CellValue:\n\t\tif config.Type() == \"Integer\": value = int(patch[\"value\"])\n\t\telif config.Type() == \"Float\": value = float(patch[\"value\"])\n\t\telse: value = patch[\"value\"]\n\t\treturn value\n\n\n\t@output\n\t@render.image(delete_file=True)\n\tdef Heatmap():\n\n\t\tinputs = [\n\t\t\tinput.File() if input.SourceFile() == \"Upload\" else input.Example(),\n\t\t\tconfig.DistanceMethod() if config.MatrixType() == \"Distance\" else config.CorrelationMethod(),\n\t\t\tconfig.CustomColors() if config.Custom() else config.ColorMap().split(),\n\t\t\tconfig.Interpolation(),\n\t\t\tconfig.Bins(),\n\t\t\tconfig.TextSize(),\n\t\t\tconfig.Features()\n\t\t]\n\n\t\tif not DataCache.In(inputs):\n\t\t\twith ui.Progress() as p:\n\t\t\t\tp.inc(message=\"Reading input...\")\n\t\t\t\tdata = GetData()\n\t\t\t\tif data is None or len(data.index) == 0: return\n\t\t\t\t\n\t\t\t\tp.inc(message=\"Calculating...\")\n\t\t\t\ttry:\n\t\t\t\t\t# Calculate matrix\n\t\t\t\t\tif config.MatrixType() == \"Distance\":\n\t\t\t\t\t\tmetric = config.DistanceMethod().lower()\n\t\t\t\t\t\tdistances = pdist(data, metric=metric)\n\t\t\t\t\t\tdf = DataFrame(squareform(distances), columns=data.index, index=data.index)\n\t\t\t\t\telse:\n\t\t\t\t\t\tmethod = config.CorrelationMethod().lower()\n\t\t\t\t\t\tdf = data.T.corr(method=method)\n\t\t\t\texcept Exception:\n\t\t\t\t\tError(\"Could not compute matrix. Ensure your input data is correct!\")\n\t\t\t\t\treturn\n\n\t\t\t\tp.inc(message=\"Plotting...\")\n\t\t\t\tfig, ax = subplots()\n\n\t\t\t\tcolors = config.CustomColors() if config.Custom() else config.ColorMap().split()\n\t\t\t\tinterpolation = config.Interpolation().lower()\n\t\t\t\tim = ax.imshow(\n\t\t\t\t\tdf, \n\t\t\t\t\tcmap=LinearSegmentedColormap.from_list(\"ColorMap\", colors, N=config.Bins()), \n\t\t\t\t\tinterpolation=interpolation,\n\t\t\t\t\taspect=\"equal\",\n\t\t\t\t)\n\n\t\t\t\ttext_size = config.TextSize()\n\n\t\t\t\t# Visibility of features\n\t\t\t\tif \"legend\" in config.Features(): \n\t\t\t\t\tcbar = colorbar(im, ax=ax, label=\"Distance\")\n\t\t\t\t\tcbar.ax.tick_params(labelsize=text_size)\n\n\t\t\t\tif \"y\" in config.Features():\n\t\t\t\t\tax.tick_params(axis=\"y\", labelsize=text_size)\n\t\t\t\t\tax.set_yticks(range(len(df.columns)))\n\t\t\t\t\tax.set_yticklabels(df.columns)\n\t\t\t\telse:\n\t\t\t\t\tax.set_yticklabels([])\n\n\t\t\t\tif \"x\" in config.Features():\n\t\t\t\t\tax.tick_params(axis=\"x\", labelsize=text_size)\n\t\t\t\t\tax.set_xticks(range(len(df.columns)))\n\t\t\t\t\tax.set_xticklabels(df.columns, rotation=90)\n\t\t\t\telse:\n\t\t\t\t\tax.set_xticklabels([])\n\n\t\t\t\t# Annotate each cell with its value\n\t\t\t\tif \"label\" in config.Features():\n\t\t\t\t\tfor i in range(df.shape[0]):\n\t\t\t\t\t\t\tfor j in range(df.shape[1]):\n\t\t\t\t\t\t\t\t\tax.text(j, i, '{:.2f}'.format(df.iloc[i, j]), ha='center', va='center', color='white')\n\n\t\t\t\tb = BytesIO()\n\t\t\t\tfig.savefig(b, format=\"png\", dpi=config.DPI())\n\t\t\t\tb.seek(0)\n\t\t\t\tDataCache.Store(b.read(), inputs)\n\n\t\tb = DataCache.Get(inputs)\n\t\twith NamedTemporaryFile(delete=False, suffix=\".png\") as temp:\n\t\t\ttemp.write(b)\n\t\t\ttemp.close()\n\t\t\timg: types.ImgData = {\"src\": temp.name, \"height\": f\"{config.Size()}vh\"}\n\t\t\treturn img\n\n\n\t@output\n\t@render.text\n\t@reactive.event(input.SourceFile, input.Example)\n\tdef ExampleInfo(): return Info[input.Example()]\n\n\n\t@render.download(filename=\"table.csv\")\n\tdef DownloadTable(): yield GetData().to_string()\n\n\n\t@render.download(filename=\"heatmap.png\")\n\tdef DownloadHeatmap():\n\t\tyield DataCache.Get([\n\t\t\tinput.File() if input.SourceFile() == \"Upload\" else input.Example(),\n\t\t\tconfig.DistanceMethod() if config.MatrixType() == \"Distance\" else config.CorrelationMethod(),\n\t\t\tconfig.CustomColors() if config.Custom() else config.ColorMap().split(),\n\t\t\tconfig.Interpolation(),\n\t\t\tconfig.Bins(),\n\t\t\tconfig.TextSize(),\n\t\t\tconfig.Features()\n\t\t])\n\n\n\t@render.ui\n\tdef ConditionalElements():\n\t\t\"\"\"\n\t\t@brief Handle Conditional Panels.\n\n\t\tBecause we need access to config, we cannot use ui.panel_conditional, as that uses\n\t\tJavaScript.\n\t\t\"\"\"\n\t\telements = []\n\n\t\tif config.Custom():\n\t\t\telements.append(\n\t\t\t\tconfig.CustomColors.UI(ui.input_select,\n\t\t\t\t\tid=\"CustomColors\",\n\t\t\t\t\tlabel=\"Colors\",\n\t\t\t\t\tchoices=Colors,\n\t\t\t\t\tmultiple=True,\n\t\t\t\t\tselectize=True,\n\t\t\t\t)\n\t\t\t)\n\t\telse:\n\t\t\telements.append(\n\t\t\t\tconfig.ColorMap.UI(ui.input_select, \n\t\t\t\t\tid=\"ColorMap\", label=\"Colors\", \n\t\t\t\t\tchoices={\n\t\t\t\t\t\t\"Blue White Yellow\": \"Blue/Yellow\",\n\t\t\t\t\t\t\"Red Black Green\": \"Red/Green\",\n\t\t\t\t\t\t\"Pink White Green\": \"Pink/Green\",\n\t\t\t\t\t\t\"Blue Green Yellow\": \"Blue/Green/Yellow\",\n\t\t\t\t\t\t\"Black Gray White\": \"Grayscale\",\n\t\t\t\t\t\t\"Red Orange Yellow Green Blue Indigo Violet\": \"Rainbow\",\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\t\t\n\n\t\t# https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html\n\t\tif config.MatrixType() == \"Distance\":\n\t\t\telements.append(\n\t\t\t\tconfig.DistanceMethod.UI(ui.input_select,\n\t\t\t\t\tid=\"DistanceMethod\", \n\t\t\t\t\tlabel=\"Distance Method\", \n\t\t\t\t\tchoices=DistanceMethods,\n\t\t\t\t)\n\t\t\t)\n\n\t\t# https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.corr.html\n\t\telif config.MatrixType() == \"Correlation\":\n\t\t\telements.append(\n\t\t\t\tconfig.CorrelationMethod.UI(ui.input_select,\n\t\t\t\t\tid=\"CorrelationMethod\", \n\t\t\t\t\tlabel=\"Correlation Method\", \n\t\t\t\t\tchoices=[\"Pearson\", \"Kendall\", \"Spearman\"], \n\t\t\t\t)\n\t\t\t)\n\t\treturn elements\n\n\napp_ui = ui.page_fluid(\n\n\tNavBar(),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\n\t\t\tFileSelection(\n\t\t\t\texamples={\n\t\t\t\t\"example1.txt\": \"Example 1\", \n\t\t\t\t\"example2.txt\": \"Example 2\", \n\t\t\t\t\"example3.txt\": \"Example 3\",\n\t\t\t\t\"example4.fasta\": \"Example 4\",\n\t\t\t\t\"ala_phe_ala.pdb\": \"Example 5\",\n\t\t\t\t},\n\t\t\t\ttypes=[\".csv\", \".txt\", \".dat\", \".tsv\", \".tab\", \".xlsx\", \".xls\", \".odf\", \".pdb\", \".dat\", \".fasta\"],\n\t\t\t\tproject=\"Pairwise\"\n\t\t\t),\n\n\t\t\tTableOptions(config),\n\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab != 'TableTab'\",\n\n\t\t\t\tconfig.MatrixType.UI(ui.input_radio_buttons, id=\"MatrixType\",  label=\"Matrix Type\",  choices=[\"Distance\", \"Correlation\"], inline=True),\n\n\t\t\t\t# Customize the text size of the axes.\n\t\t\t\tconfig.TextSize.UI(ui.input_numeric, id=\"TextSize\", label=\"Text Size\", min=1, max=20, step=1),\n\n\t\t\t\tconfig.Custom.UI(ui.input_checkbox, id=\"Custom\", label=\"Custom ColorMap\"),\n\t\t\t\tconfig.Bins.UI(ui.input_slider, id=\"Bins\", label=\"Number of Colors\", min=3, max=100, step=1),\n\n\t\t\t\tui.output_ui(\"ConditionalElements\"),\n\n\t\t\t\t# https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html\n\t\t\t\tconfig.Interpolation.UI(ui.input_select, id=\"Interpolation\", label=\"Interpolation\", choices=InterpolationMethods),\n\n\t\t\t\t# Customize what aspects of the heatmap are visible\n\t\t\t\tconfig.Features.UI(ui.input_checkbox_group,\n\t\t\t\t\tid=\"Features\", label=\"Heatmap Features\",\n\t\t\t\t\tchoices={\"x\": \"X Labels\", \"y\": \"Y Labels\", \"label\": \"Data Labels\", \"legend\": \"Legend\"},\n\t\t\t\t),\n\n\t\t\t\t# Specify the PDB Chain\n\t\t\t\tconfig.Chain.UI(ui.input_text, id=\"Chain\", label=\"PDB Chain\"),\n\n\t\t\t\t# Customize the K-mer to compute for FASTA sequences\n\t\t\t\tconfig.K.UI(ui.input_numeric, id=\"K\", label=\"K-Mer Length\", min=3, max=5, step=1),\n\n\t\t\t\tconfig.Size.UI(ui.input_numeric, id=\"Size\", label=\"Size\", value=800, min=1),\n\t\t\t\tconfig.DPI.UI(ui.input_numeric, id=\"DPI\", label=\"DPI\", value=100, min=1),\n\t\t\t\tui.download_button(id=\"DownloadHeatmap\", label=\"Download\"),\n\t\t\t),\n\t\t),\n\n\t\t# Add the main interface tabs.\n\t\tMainTab(m_type=ui.output_image),\n\t)\n)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "config.py", "content": "#\n# Heatmapper \n# Pairwise Configuration\n#\n# This file contains configuration for Pairwise. \n\n\nfrom shared import Config, ConfigHandler\n\nconfig = ConfigHandler({\n\n\n\t# \"Distance\", \"Correlation\"\n\t\"MatrixType\": Config(selected=\"Distance\"),\n\n\t# Number between 1-50\n\t\"TextSize\": Config(value=8),\n\n\t# Check shared.py for DistanceMethods.\n\t\"DistanceMethod\": Config(selected=\"Euclidean\"),\n\n\t# \"Pearson\", \"Kendall\", \"Spearman\"\n\t\"CorrelationMethod\": Config(selected=\"Pearson\"),\n\n\t# Check shared.py for InterpolationMethods\n\t\"Interpolation\": Config(selected=\"Nearest\"),\n\n\t# Any combination of \"x\", \"y\", \"label\", \"legend\" in a list\n\t\"Features\": Config(selected=[\"legend\"]),\n\n\t# Any alphanumeric string that corresponds to a PDB chain.\n\t\"Chain\": Config(value=\"A\"),\n\n\t# Any K-Mer length from 3-5\n\t\"K\": Config(value=3),\n\n\t# True or False to Use custom color maps or pre-defined ones.\n\t\"Custom\": Config(value=False),\n\n\t# A list of colors. See shared.py for Colors\n\t\"CustomColors\": Config(selected=[\"Blue\", \"White\", \"Yellow\"]),\n\t\n\t# See shared.py ColorMap for options. \n\t\"ColorMap\": Config(selected=\"Blue White Yellow\"),\n\n\t# Any number between 3-100 to define amount of bins for color mapping\n\t\"Bins\": Config(value=50),\n\n\t# Any value greater than 1.\n\t\"Size\": Config(value=600),\n\n\t# Any value greater than 1.\n\t\"DPI\": Config(value=100),\n\n\t# \"Integer\" \"Float\" \"String\"\n\t\"Type\": Config(selected=\"Integer\"),\n})", "type": "text"}, {"name": "requirements.txt", "content": "biopython", "type": "text"}, {"name": "shared.py", "content": "#\n# Heatmapper\n# Shared\n#\n# This file contains shared functionality between Heatmapper applications. It is not a standalone application.\n# Due to the way ShinyLive exports applications, this file is symlinked into each project to reduce redundancy.\n#\n\nfrom shiny import ui, reactive\nfrom shiny.types import FileInfo\nfrom pandas import DataFrame, read_csv, read_excel, read_table\nfrom io import BytesIO\nfrom tempfile import NamedTemporaryFile\nfrom sys import modules\nfrom pathlib import Path\nfrom enum import Enum\nfrom os.path import exists\nfrom copy import deepcopy\n\n# Used for fetching web resources in a variety of fashions.\nURL = \"https://wishartlab.github.io/heatmapper2\"\nRaw = \"https://raw.githubusercontent.com/WishartLab/heatmapper2/main\"\n\n# Define the Server and Port of the Shiny instances (Port is incremented)\n# Change these if Heatmapper is running on a server.\nServer = \"http://35.208.86.138\"\nPort = 8000\n\n# Detect the running environment\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tPyodide = True\nelse:\n\tPyodide = False\n\n# Shared Values\nColors = [\"Blue\", \"Orange\", \"Green\", \"Red\", \"Purple\", \"Brown\", \"Pink\", \"Gray\", \"Olive\", \"Cyan\", \"White\", \"Yellow\"]\nDistanceMethods = [\"Braycurtis\", \"Canberra\", \"Chebyshev\", \"Cityblock\", \"Correlation\", \"Cosine\", \"Dice\", \"Euclidean\", \"Hamming\", \"Jaccard\", \"Jensenshannon\", \"Kulczynski1\", \"Matching\", \"Minkowski\", \"Rogerstanimoto\", \"Russellrao\", \"Seuclidean\", \"Sokalmichener\", \"Sokalsneath\", \"Sqeuclidean\", \"Yule\"]\nInterpolationMethods = [\"None\", \"Antialiased\", \"Nearest\", \"Bilinear\", \"Bicubic\", \"Spline16\", \"Spline36\", \"Hanning\", \"Hamming\", \"Hermite\", \"Kaiser\", \"Quadric\", \"Catrom\", \"Gaussian\", \"Bessel\", \"Mitchell\", \"Sinc\", \"Lanczos\", \"Blackman\"]\nClusteringMethods = [\"Single\", \"Complete\", \"Average\", \"Weighted\", \"Centroid\", \"Median\", \"Ward\"]\nColorMaps = [\"Viridis\", \"Plasma\", \"Inferno\", \"Magma\"]\n\nclass ColumnType(Enum): Time = 0; Name = 1; Value = 2; Longitude = 3; Latitude = 4; X = 5; Y = 6; Z = 7; Cluster = 8; Free = 9; Spatial = 10; NameGeoJSON = 11;\nColumns = {\n\tColumnType.Time: {\"time\", \"date\", \"year\"},\n\tColumnType.Name: {\"name\", \"orf\", \"uniqid\", \"face\", \"triangle\", \"iso_code\", \"continent\", \"country\", \"location\"},\n\tColumnType.Value: {\"value\", \"weight\", \"intensity\", \"in_tissue\"},\n\tColumnType.Longitude: {\"longitude\", \"long\"},\n\tColumnType.Latitude: {\"latitude\", \"lat\"},\n\tColumnType.X: {\"x\"},\n\tColumnType.Y: {\"y\"},\n\tColumnType.Z: {\"z\"},\n\tColumnType.Cluster: {\"cell type\", \"celltype_mapped_refined\", \"cluster\", \"cell_class\", \"cell_subclass\", \"cell_cluster\"},\n\tColumnType.Free: {None},\n\tColumnType.Spatial: {\"spatial\"},\n\tColumnType.NameGeoJSON: {\"name\", \"admin\", \"iso_a3\", \"iso_a2\", \"iso\"}\n}\n\n\ndef Filter(columns, ctype: ColumnType, good: list = [], bad: list = [], only_one=False, reject_unknown=False):\n\t\"\"\"\n\t@brief Filters available column names based on what input we want\n\t@param columns: The columns of the DataFrame (Usually just df.columns)\n\t@param ctype: The type of column we're looking for (Look at the ColumnType Enum)\n\t@param good: A list of column names on top of those defined by the type to be included\n\t@param bad: A list of column names on top of those defined by the type to be excluded from the result.\n\t@param only_one: Only return a single result, so the variable can be used immediately.\n\t@param reject_unknown: Only include columns explicitly defined\n\t@return: A list of column names to use.\n\t\"\"\"\n\n\t# Fold cases\n\tfolded = [column.lower() for column in columns]\n\n\t# Add and remove what user asked for, filtering None\n\toptions = set(folded)\n\tif bad: options -= set([b.lower() for b in bad if b])\n\tif good: options &= set([g.lower() for g in good if g])\n\n\t# Take an intersection of our columns and the type we want. If there is a match, return those\n\t# Otherwise, remove all columns we know it shouldn't be, and return that instead.\n\tintersection = options & Columns[ctype]\n\tif intersection or reject_unknown: options = intersection\n\telse:\n\t\tfor key, value in Columns.items():\n\t\t\tif key != ctype: options -= value\n\n\t# Get the valid indices, and sort them in ascending order\n\tindices = [folded.index(value) for value in options]\n\tindices.sort()\n\n\t# Get the original column names, without case-folding, and return as a list.\n\treassembled = [columns[index] for index in indices]\n\tif not reassembled: return None\n\treturn reassembled[0] if only_one else reassembled\n\n\ndef UpdateColumn(columns, ctype, default, id, **kwargs):\n\t\"\"\"\n\t@brief Update a input_select element based on columns\n\t@pararm columns: The list of columns to source\n\t@param ctype: The ColumnType to search for\n\t@param default: The default value to use\n\t@param id: The ID of the UI element\n\t@param kwargs: Keyword arguments to be passed to filter. \n\t@returns The new value of the element..\n\t\"\"\"\n\n\tfiltered = Filter(columns, ctype, **kwargs)\n\tif filtered is None: return\n\tselected = default if default in columns else filtered[0]\n\tui.update_select(id=id, choices=filtered, selected=selected)\n\treturn selected\n\n\nclass Cache:\n\t\"\"\"\n\t@brief A class that encompasses fetching/storing web resources.\n\t\"\"\"\n\n\t@staticmethod\n\tdef HandleDataFrame(path, function):\n\t\t\"\"\"\n\t\t@brief Handle DataFrame's\n\t\t@param i: The binary of the file\n\t\t@param function: The pandas function to use to read the file.\n\t\t@returns A DataFrame\n\t\t\"\"\"\n\n\t\t# Read the table once.\n\t\tdf = function(path.resolve()).fillna(0)\n\n\t\t# If the first column value is a float, we assume it's data, and not column names.\n\t\t# Re-read the DataFrame with generic column names instead\n\t\ttry:\n\t\t\tfloat(df.columns[0])\n\t\t\tdf = function(path.resolve(), header=None, names=[f\"Column {i}\" for i in range(df.shape[1])])\n\t\texcept ValueError: pass\n\t\treturn df\n\n\n\t@staticmethod\n\tdef DefaultHandler(path):\n\t\t\"\"\"\n\t\t@brief The default handler. It can handle csv, xlsx, and defaults all other files to read_table\n\t\t@param n: The path to the file\n\t\t@returns: An object, if the provided file is supported, None otherwise.\n\t\t\"\"\"\n\n\t\tsuffix = path.suffix\n\t\tif suffix == \".csv\": return Cache.HandleDataFrame(path, read_csv)\n\t\telif suffix == \".xlsx\" or suffix == \".xls\" or suffix == \".odf\": return Cache.HandleDataFrame(path, read_excel)\n\t\telse: return Cache.HandleDataFrame(path, read_table)\n\n\n\tasync def _remote(self, url):\n\t\t\tr = await pyfetch(url);\n\t\t\tif not r.ok: return None\n\t\t\treturn await r.bytes()\n\n\n\tasync def _local(self, url):\n\t\tif not exists(url): return None\n\t\treturn Path(url)\n\n\n\tdef __init__(self, project, DataHandler = DefaultHandler):\n\t\t\"\"\"\n\t\t@brief Initialize an instance of the Cache object.\n\t\t@param project: The name of the project. This is used to fetch web resources.\n\t\t@param DataHandler:\tThe function that should be called to process files. It should\n\t\t\t\t\t\t\t\t\t\t\t\ttake a name, and a binary stream, and return a DataFrame.\n\t\t\"\"\"\n\n\t\t# The primary is the unprocessed, fetched web resources\n\t\tself._primary = {}\n\n\t\t# The objects are anything that applications want to store\n\t\tself._objects = {}\n\n\t\t# The data handler for processing the binary files.\n\t\tself._handler = DataHandler\n\n\t\t# If we're in a Pyodide environment, we fetch resources from the web.\n\t\tif Pyodide:\n\t\t\tself._download = lambda url: self._remote(url)\n\t\t\tself._source = f\"{Raw}/{project}/example_input/\"\n\n\t\t# Otherwise, we fetch locally.\n\t\telse:\n\t\t\tself._download = lambda url: self._local(url)\n\t\t\tself._source = \"../example_input/\"\n\n\n\tasync def Load(self, input, source_file=None, example_file=None, source=None, input_switch=None, default=DataFrame()):\n\t\t\"\"\"\n\t\t@brief Caches whatever the user has currently uploaded/selection, returning the identifier within the secondary cache.\n\t\t@param input: The Shiny input variable. Importantly, these must be defined:\n\t\t\tinput.File: The uploaded file\n\t\t\tinput.Example: The selected example file\n\t\t\tinput.SourceFile: Whether the user wants \"Upload\" or \"Example\"\n\t\t@param source_file: The input ID that should be used to fetch the file (Defaults to input.File() if None)\n\t\t@param example_file: The input ID that should be used to fetch th example (Defaults to input.Example() if None)\n\t\t@param input_switch:\tThe input ID to check for Upload/Example/Other. The value is compared against \"Upload\" for user\n\t\t\t\t\t\t\t\t\t\t\t\t\tuploaded items, and defaults to fetching example_file otherwise. (Defaults to input.SourceFile())\n\t\t@param default:\tThe object that should be returned if files cannot be fetched. Ensures that Load will always return an\n\t\t\t\t\t\t\t\t\t\tobject, avoiding the needing to check output. Defaults to a DataFrame. The object should be able to\n\t\t\t\t\t\t\t\t\t\tinitialize without arguments.\n\t\t\"\"\"\n\n\t\tif source_file is None: source_file = input.File()\n\t\tif example_file is None: example_file = input.Example()\n\t\tif source is None: source = self._source\n\t\tif input_switch is None: input_switch = input.SourceFile()\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input_switch == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = source_file\n\t\t\tif file is None: return default\n\n\t\t\t# The datapath can be immediately used to load examples, but we explicitly need to use\n\t\t\t# Local as a user uploaded file will always be fetched on disk.\n\t\t\tn = str(file[0][\"datapath\"])\n\t\t\tif n not in self._primary: self._primary[n] = self._handler(Path(n))\n\n\t\t# Example files, conversely, can be on disk or on a server depending on whether we're in a WASM environment.\n\t\telse:\n\n\t\t\t# If we explicitly provide a URL, use it, but only in Pyodide (We still assume the file exists on disk when running \n\t\t\t# in server-mode).\n\t\t\tif example_file.startswith(\"https://\"):\n\t\t\t\tn = example_file if Pyodide else str(source + example_file.split(\"/\")[-1])\n\t\t\telse:\n\t\t\t\tn = str(source + example_file)\n\t\t\traw = await self._download(n)\n\n\t\t\t# WASM needs a temporary file, but they are deleted out of their scope.\n\t\t\tif Pyodide:\n\t\t\t\ttemp = NamedTemporaryFile(suffix=Path(n).suffix); \n\t\t\t\ttemp.write(BytesIO(raw).read()); temp.seek(0)\n\t\t\t\tif n not in self._primary: self._primary[n] = self._handler(Path(temp.name))\n\n\t\t\telif n not in self._primary: self._primary[n] = self._handler(raw)\n\n\t\t# If the object cannot be copied, then we can just return it directly\n\t\ttry:\n\t\t\treturn deepcopy(self._primary[n])\n\t\texcept AttributeError:\n\t\t\treturn self._primary[n]\n\n\n\tdef Store(self, object, inputs):\n\t\t\"\"\"\n\t\t@brief Store arbitrary data in the Cache.\n\t\t@param object: The object to store\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\th = \"\".join(str(i) for i in inputs)\n\t\tself._objects[h] = object\n\n\n\tdef Get(self, inputs):\n\t\t\"\"\"\n\t\t@brief Retrieve arbitrary data in the Cache.\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\th = \"\".join(str(i) for i in inputs)\n\t\tif h in self._objects:\n\t\t\t\treturn self._objects[h]\n\t\telse: return None\n\n\tdef In(self, inputs):\n\t\th = \"\".join(str(i) for i in inputs)\n\t\treturn h in self._objects\n\n\ndef NavBar():\n\t\"\"\"\n\t@brief Returns a Navigation Bar for each project, with the current project selected.\n\t@returns A list, containing a ui.panel_title, and a ui.navset_bar.\n\t\"\"\"\n\n\tSources = {\n\t\t\"expression\": f\"{URL}/site/expression/index.html\" if Pyodide else f\"{Server}:{Port}\",\n\t\t\"pairwise\": f\"{URL}/site/pairwise/index.html\" if Pyodide else f\"{Server}:{Port + 1}\",\n\t\t\"image\": f\"{URL}/site/image/index.html\" if Pyodide else f\"{Server}:{Port + 2}\",\n\t\t\"geomap\": f\"{URL}/site/geomap/index.html\" if Pyodide else f\"{Server}:{Port + 3}\",\n\t\t\"geocoordinate\": f\"{URL}/site/geocoordinate/index.html\" if Pyodide else f\"{Server}:{Port + 4}\",\n\t\t\"3d\": f\"{Server}:{Port + 5}\",\n\t\t\"spatial\": f\"{Server}:{Port + 6}\",\n\t}\n\n\treturn (\n\t\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\t\tui.navset_bar(\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"expression\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Expression</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"pairwise\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Pairwise</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"image\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Image</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geomap\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geomap</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geocoordinate\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geocoordinate</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"3d\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">3D</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"spatial\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Spatial</a>')),\n\t\t\tui.nav_control(ui.HTML('<a href=https://github.com/WishartLab/heatmapper2/wiki target=\"_blank\" rel=\"noopener noreferrer\">About</a>')),\n\t\t\tui.nav_spacer(),\n\t\t\tui.nav_control(ui.input_dark_mode(id=\"mode\")),\n\t\t\ttitle=ui.HTML(\n\t\t\t\tf'<a href=\"{URL}\" target=\"_blank\" rel=\"noopener noreferrer\"> \\\n\t\t\t\t\t<img src=\"{Raw}/site/logo.png\" alt=\"Heatmapper\"> \\\n\t\t\t\t</a>'),\n\t\t),\n\t)\n\n\ndef FileSelection(examples, types, upload_label=\"Choose a File\", multiple=False, default=\"Upload\", project=\"Overview\"):\n\t\"\"\"\n\t@brief Returns the file selection dialog for the user to upload/select an example\n\t@param examples: Either a list of example file names, or a dictionary mapping\n\t@param types: The valid file extensions for user uploaded files.\n\t@param upload_label: The label for the upload input. Useful to define specifically what kind of files are needed\n\t@param multiple: Whether to accept multiple files. \n\t@param default: Whether to start on the example, or upload dialog\n\t@param project: The name of a project, to specify a specified header within the Interface documentation\n\t@returns A list, containing the necessary ui components for uploading/selecting\n\t@info The returns elements are named:\n\t\tinput.SourceFile: The ui.input_radio_buttons for whether the user wants to choose an \"Example\" or \"Upload\"\n\t\tinput.File: The ui.input_file for user uploaded files.\n\t\tinput.Example: The ui.input_select for an example file selection\n\t@info multiple=True is not handled properly by the Cache. You will need to create a function that properly handles\n\t\teach file (See spatial for an implementation)\n\t@info If you're examples are large files, or require significant computation, you may want to switch it to Upload instead.\n\t\"\"\"\n\n\t# If the user needs help with the formatting.\n\treturn [\n\tui.layout_columns(\n\t\tui.HTML(\"<a href=https://github.com/WishartLab/heatmapper2/wiki/Format target='_blank' rel='noopener noreferrer'>Format</a>\"),\n\t\tui.HTML(f\"<a href='https://github.com/WishartLab/heatmapper2/wiki/Interface#{project}' target='_blank' rel='noopener noreferrer'>Help</a>\"),\n\t\tcol_widths=[6,6]\n\t),\n\n\t# Specify whether to use example files, or upload one.\n\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"], selected=default, inline=True),\n\n\t# Only display an input dialog if the user is one Upload\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Upload'\",\n\t\tui.input_file(\"File\", upload_label, accept=types, multiple=multiple),\n\t),\n\n\t# Otherwise, add the example selection and an info button.\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Example'\",\n\t\tui.layout_columns(\n\t\t\tui.input_select(id=\"Example\", label=None, choices=examples, multiple=False),\n\t\t\tui.popover(ui.input_action_link(id=\"ExampleInfoButton\", label=\"Info\"), ui.output_text(\"ExampleInfo\")),\n\t\t\tcol_widths=[7,3],\n\t\t)\n\t),\n\t]\n\n\ndef TableOptions(config):\n\t\"\"\"\n\t@brief Return the options for Table Manipulation.\n\t@returns A conditional panel that provides a DataType, and a ResetButton.\n\t\"\"\"\n\treturn  ui.panel_conditional(\n\t\t\"input.MainTab === 'TableTab'\",\n\t\tconfig.Type.UI(ui.input_radio_buttons, id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"], inline=True),\n\t\tui.input_action_button(id=\"Reset\", label=\"Reset Values\"),\n\t\tui.download_button(id=\"DownloadTable\", label=\"Download Table\"),\n\t),\n\n\ndef MainTab(*args, m_type=ui.output_plot):\n\treturn ui.navset_tab(\n\t\tui.nav_panel(\"Heatmap\", m_type(id=\"Heatmap\"), value=\"HeatmapTab\"),\n\t\tui.nav_panel(\"Table\", ui.output_data_frame(id=\"Table\"), value=\"TableTab\"),\n\t\t*args,\n\t\tid=\"MainTab\"\n\t)\n\n\nclass Config:\n\t\"\"\"\n\t@brief A configuration entry.\n\t\"\"\"\n\n\tdef __init__(self, visible=True, **kwargs):\n\t\t\"\"\"\n\t\t@brief Create a configuration entry.\n\t\t@param default: The default value for an input.\n\t\t@param visible: Whether the input should be shown in the sidebar\n\t\t@param **kwargs: Arguments to be passed to the input.\n\t\t\"\"\"\n\t\tself.visible = visible\n\t\tself.kwargs = kwargs\n\t\tif \"selected\" in kwargs:\n\t\t\tself.default = kwargs[\"selected\"]\n\t\telif \"value\" in kwargs:\n\t\t\tself.default = kwargs[\"value\"]\n\t\telse:\n\t\t\tself.default = None\n\t\tself.resolve = None\n\n\n\tdef __call__(self): \n\t\ttry:\n\t\t\tresolved = self.resolve()\n\t\t\treturn self.default if resolved is None else resolved\n\t\texcept Exception:\n\t\t\treturn self.default\n\n\n\tdef Resolve(self, input): \n\t\tself.resolve = input\n\n\n\tdef UI(self, ui, *args, **kwargs):\n\t\t\"\"\"\n\t\t@brief Displays the configured UI.\n\t\t@param ui The Shiny interface element to use.\n\t\t@parram **kwargs: Additional arguments to be passed to the input.\n\t\t@note\tkeyword arguments passed to the Config object during initialization will overrule\n\t\t\t\t\targuments passed to this function. Duplicates are allowed.\n\t\t\"\"\"\n\n\t\t# Remove duplicates.\n\t\tduplicates = []\n\t\tfor key in kwargs.keys():\n\t\t\tif key in self.kwargs: duplicates.append(key)\n\t\tfor key in duplicates: del kwargs[key]\n\n\t\t# Return the correct UI.\n\t\tif self.visible: return ui(*args, **kwargs, **self.kwargs)\n\n\nclass ConfigHandler(dict):\n\t\"\"\"\n\t@brief: A dictionary that can be accessed with dots, and can automatically resolve.\n\t\"\"\"\n\n\t__getattr__ = dict.get\n\t__setattr__ = dict.__setitem__\n\t__delattr__ = dict.__delitem__\n\n\n\tdef Resolve(self, input): \n\t\t\"\"\"\n\t\t@brief Resolves all stored objects.\n\t\t@param input The input to use for resolving.\n\t\t\"\"\"\n\t\tfor conf, var in self.items():\n\t\t\tvar.Resolve(input[conf])\n\n\ndef InitializeConfig(config, input): \n\t\"\"\"\n\t@brief Initializes the configuration variable.\n\t@param config: The configuration variable\n\t@param input: The Shiny input\n\n\tThis function will update each configuration's resolve member, so that\n\tif \n\t\"\"\"\n\tfor conf, var in config.items(): var.Resolve(input[conf])\n\n\ndef GenerateConditionalElements(pairs):\n\telements = []\n\tfor conditional, element in pairs:\n\t\tif conditional: elements.append(element)\n\treturn elements\n\n\ndef Error(message):\n\treturn ui.notification_show(ui=message, type=\"error\", duration=3)", "type": "text"}]