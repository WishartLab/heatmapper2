[{"name": "app.py", "content": "#\n# Heatmapper\n# Spatial\n#\n# This file contains the Shiny application for Spatial Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshiny run\n#\n# Exporting via ShinyLive is not currently supported, as squidpy\n# is not yet available in the Pyodide environment. Required libraries\n# include: openmpi, verdict, glew, alongside python libraries in requirements.txt\n# WebGL is required for this application.\n#\n\nfrom pandas.core.arrays.arrow.array import pa\nfrom shiny import App, reactive, render, ui\nfrom matplotlib.pyplot import get_cmap\nfrom tempfile import TemporaryDirectory, NamedTemporaryFile\nfrom anndata import read_h5ad\nfrom squidpy import gr, pl, read\nfrom scanpy import pp, tl\nfrom pathlib import Path\n\n# Shared functions\nfrom shared import Cache, MainTab, NavBar, FileSelection, Filter, ColumnType, InitializeConfig, ColorMaps, DistanceMethods, Update, Msg, Error, Inlineify, TableOptions, File\n\ntry:\n\tfrom user import config\nexcept ImportError:\n\tfrom config import config\n\n\ndef server(input, output, session):\n\n\t# Information regarding example files.\n\tInfo = {\n\t\t\"visium_hne_adata.h5ad\": \"Pre-processed example files provided by SquidPy\",\n\t\t\"seqfish.h5ad\": \"Pre-processed example files provided by SquidPy\",\n\t\t\"imc.h5ad\": \"Pre-processed example files provided by SquidPy\",\n\t}\n\n\tInitializeConfig(config, input)\n\n\n\tdef HandleData(path, p=None):\n\t\t\"\"\"\n\t\t@brief A custom Data Handler for the Cache.\n\t\t@param path: the Path to the file\n\t\t@returns A data object from the cache.\n\t\t@info This Data Handler supports h5ad files via scanpy.\n\t\t\"\"\"\n\n\t\tsuffix = path.suffix\n\t\tif suffix == \".h5ad\":\n\t\t\tadata = read_h5ad(path.resolve())\n\t\t\tgr.spatial_neighbors(adata)\n\t\t\treturn adata\n\n\t\t# Pass loading .h5, we deal with them in UpdateData()\n\t\telif suffix == \".h5\": return None\n\t\telse: return DataCache.DefaultHandler(path)\n\tDataCache = Cache(\"spatial\", DataHandler=HandleData)\n\tData = reactive.value(None)\n\n\n\tdef ColumnNames(adata, p):\n\t\tp.inc(message=\"Generating Annotation Keys...\")\n\t\tFilter(adata.obs[\"cluster\"].cat.categories.to_list(), ColumnType.Free, id=\"CoCluster\")\n\t\tFilter(adata.obs.columns.to_list(), ColumnType.Count, id=\"Count\")\n\n\t\tchoices = []\n\t\tif input.UploadType() == \"Visium\" or input.SourceFile() == \"Example\":\n\t\t\tchoices = adata.var.gene_ids.index.drop_duplicates().to_list()\n\t\telif input.UploadType() == \"NanoString\":\n\t\t\tchoices = adata.obs[\"fov\"].drop_duplicates().to_list()\n\t\t\tui.update_select(id=\"Count\", choices=adata.obs.columns.to_list())\n\t\tif choices: ui.update_select(id=\"Keys\", choices=choices, selected=choices[0])\n\n\n\tasync def VisiumReader(temp, p):\n\t\tPath(f\"{temp.name}/spatial\").mkdir()\n\t\tcounts = None\n\t\tfor file in input.File():\n\t\t\tn = file[\"datapath\"]\n\t\t\tbase = file[\"name\"]\n\n\t\t\t# These files are located in the spatial subdir\n\t\t\tsuffix = Path(base).suffix\n\n\t\t\t# These files are considered spatial.\n\t\t\tif suffix in [\".png\", \".json\", \".csv\"]: base = f\"spatial/{base}\"\n\t\t\telif suffix == \".h5\": counts = base\n\n\t\t\t# If the user uploaded a .h5ad, we already have that information Cached, so just return it.\n\t\t\telif suffix == \".h5ad\":\n\t\t\t\tadata = await DataCache.Load(input, default=None, p=p)\n\t\t\t\tColumnNames(adata, p)\n\t\t\t\tp.close()\n\t\t\t\treturn adata\n\n\t\t\tpath = f\"{temp.name}/{base}\"\n\t\t\topen(path, \"wb\").write(open(n, \"rb\").read())\n\n\t\t# Make SquidPy generate an object from the folder.\n\t\tp.inc(message=\"Consolidating Data...\")\n\t\treturn read.visium(temp.name, counts_file=counts)\n\n\n\tasync def NanoStringReader(temp, p):\n\t\tcounts = None\n\t\tmeta = None\n\t\tfov = None\n\n\t\tPath(temp.name, \"CellComposite\").mkdir()\n\t\tPath(temp.name, \"CellLabels\").mkdir()\n\n\t\tfor file in input.File():\n\t\t\tn = file[\"datapath\"]\n\t\t\tbase = file[\"name\"]\n\n\t\t\t# These files are located in the spatial subdir\n\t\t\tsuffix = Path(base).suffix\n\n\t\t\t# If the user uploaded a .h5ad, we already have that information Cached, so just return it.\n\t\t\tif suffix == \".h5ad\":\n\t\t\t\tadata = await DataCache.Load(input, default=None, p=p)\n\t\t\t\tColumnNames(adata, p)\n\t\t\t\tp.close()\n\t\t\t\treturn adata\n\t\t\telif suffix == \".csv\":\n\t\t\t\tif base.endswith(\"_exprMat_file.csv\"): count = base\n\t\t\t\tif base.endswith(\"_metadata_file.csv\"): meta = base\n\t\t\t\tif \"fov\" in base: fov = base\n\t\t\telif suffix == \".tif\": base = f\"CellLabels/{base}\"\n\t\t\telif suffix in (\".png\", \".jpg\"): base = f\"CellComposite/{base}\"\n\n\t\t\topen(f\"{temp.name}/{base}\", \"wb\").write(open(n, \"rb\").read())\n\n\t\t# Make SquidPy generate an object from the folder.\n\t\tp.inc(message=\"Consolidating Data...\")\n\t\tadata = read.nanostring(\n\t\t\ttemp.name,\n\t\t\tcounts_file=count,\n\t\t\tmeta_file=meta,\n\t\t\tfov_file=fov\n\t\t)\n\t\treturn adata\n\n\t@reactive.effect\n\t@reactive.event(input.SourceFile, input.File, input.Example, input.CellCount, input.GeneCount, input.UploadType)\n\tasync def UpdateData():\n\t\t\"\"\"\n\t\t@brief Returns AnnData objects with data for Spatial Mapping.\n\t\t@info SquidPy's Visium Reader expect a directory, so Spatial will accept multiple files\n\t\t\tand then parse them into the correct structure.\n\t\t\"\"\"\n\n\t\twith ui.Progress() as p:\n\t\t\tp.inc(message=\"Loading Data...\")\n\t\t\tif input.SourceFile() == \"Upload\":\n\n\t\t\t\t# Get all the files, to generate a name.\n\t\t\t\tif input.File() is None: return\n\t\t\t\tname = [f[\"datapath\"] for f in input.File()]\n\n\t\t\t\t# If the name hasn't been cached, we need to construct the object.\n\t\t\t\tif not DataCache.In(name):\n\t\t\t\t\tp.inc(message=\"Organizing Data...\")\n\t\t\t\t\ttemp = TemporaryDirectory()\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif input.UploadType() == \"Visium\": adata = await VisiumReader(temp, p)\n\t\t\t\t\t\telif input.UploadType() == \"NanoString\": adata = await NanoStringReader(temp, p)\n\t\t\t\t\t\telse: return None\n\t\t\t\t\texcept Exception:\n\t\t\t\t\t\tError(\"Couldn't parse the provided input! Make sure all files needed files are uploaded, and the right Upload Type is selected!\")\n\t\t\t\t\t\treturn None\n\n\t\t\t\t\tif adata is None: return\n\n\t\t\t\t\t# Throw it into the Cache.\n\t\t\t\t\tDataCache.Store(adata, name)\n\n\t\t\t\t\t# Now that it's cached, remove the origin\n\t\t\t\t\tfor file in name:\n\t\t\t\t\t\t\tPath(file).unlink()\n\n\t\t\t\tadata = DataCache.Get(name)\n\n\t\t\t\tif input.File()[0][\"name\"].endswith(\".h5ad\"):\n\t\t\t\t\tprint(\"Returning\")\n\t\t\t\t\tData.set(adata)\n\t\t\t\t\treturn\n\n\t\t\t\tcell, gene = input.CellCount(), input.GeneCount()\n\t\t\t\tif cell is None or gene is None: return\n\n\t\t\t\tfiltered = name + [cell, gene]\n\t\t\t\tif not DataCache.In(filtered):\n\n\t\t\t\t\tbdata = adata.copy()\n\t\t\t\t\tpp.filter_cells(bdata, min_counts=cell)\n\t\t\t\t\tpp.filter_genes(bdata , min_cells=gene)\n\n\t\t\t\t\tif input.UploadType() == \"Visium\":\n\t\t\t\t\t\tadata.var_names_make_unique()\n\t\t\t\t\t\tp.inc(message=\"Normalizing...\")\n\t\t\t\t\t\tpp.normalize_total(bdata, inplace=True)\n\t\t\t\t\t\tpp.log1p(bdata)\n\n\t\t\t\t\t\tp.inc(message=\"Calculating Neighbors...\")\n\t\t\t\t\t\tpp.neighbors(bdata)\n\t\t\t\t\t\ttl.umap(bdata)\n\t\t\t\t\t\tgr.spatial_neighbors(bdata)\n\n\t\t\t\t\t\tp.inc(message=\"Calculating QC Metrics...\")\n\t\t\t\t\t\tpp.calculate_qc_metrics(bdata, inplace=True)\n\n\t\t\t\t\t\tp.inc(message=\"Clustering...\")\n\t\t\t\t\t\ttl.leiden(bdata, key_added=\"cluster\", neighbors_key=\"spatial_neighbors\", resolution=input.Resolution())\n\n\t\t\t\t\t\tp.inc(message=\"Finding Highly Variable Genes...\")\n\t\t\t\t\t\tpp.highly_variable_genes(bdata, inplace=True, n_top_genes=100, flavor=\"seurat_v3\")\n\n\n\t\t\t\t\telif input.UploadType() == \"NanoString\":\n\t\t\t\t\t\tp.inc(message=\"Obtaining Control Probes...\")\n\t\t\t\t\t\tbdata.var[\"NegPrb\"] = bdata.var_names.str.startswith(\"NegPrb\")\n\t\t\t\t\t\tpp.calculate_qc_metrics(bdata, qc_vars=[\"NegPrb\"], inplace=True)\n\n\t\t\t\t\t\tp.inc(message=\"Normalizing...\")\n\t\t\t\t\t\tbdata.layers[\"counts\"] = bdata.X.copy()\n\t\t\t\t\t\tpp.normalize_total(bdata, inplace=True)\n\t\t\t\t\t\tpp.log1p(bdata)\n\n\t\t\t\t\t\tp.inc(message=\"Calculating Neighbors...\")\n\t\t\t\t\t\tpp.pca(bdata)\n\t\t\t\t\t\tpp.neighbors(bdata)\n\t\t\t\t\t\ttl.umap(bdata)\n\t\t\t\t\t\tgr.spatial_neighbors(bdata, coord_type=\"generic\", delaunay=True)\n\n\t\t\t\t\t\tp.inc(message=\"Clustering...\")\n\t\t\t\t\t\ttl.leiden(bdata, key_added=\"cluster\")\n\n\t\t\t\t\tColumnNames(bdata ,p)\n\t\t\t\t\tDataCache.Store(bdata, filtered)\n\t\t\t\tData.set(DataCache.Get(filtered))\n\t\t\t\tp.close()\n\n\t\t\t# With an example, just return it.\n\t\t\telse:\n\t\t\t\tData.set(await DataCache.Load(input, default=None))\n\t\t\t\tColumnNames(Data(), p)\n\t\t\t\tp.close()\n\n\n\t@output\n\t@render.data_frame\n\tdef Table():\n\t\tstate = config.TableType()\n\t\tdf = Data()\n\t\tif df is None: return\n\t\tif state == \"obs\": return render.DataGrid(df.obs, editable=True)\n\t\telif state == \"var\": return render.DataGrid(df.var, editable=True)\n\n\n\t@Table.set_patch_fn\n\tdef UpdateTable(*, patch: render.CellPatch) -> render.CellValue:\n\t\tif config.Type() == \"Integer\": value = int(patch[\"value\"])\n\t\telif config.Type() == \"Float\": value = float(patch[\"value\"])\n\t\telse: value = patch[\"value\"]\n\n\t\trow = patch[\"row_index\"]\n\t\tcol = patch[\"column_index\"]\n\n\t\tdf = Data()\n\t\ttable = df.obs if config.TableType() == \"obs\" else df.var\n\t\ttable.iloc[row, col] = value\n\t\tData.set(df)\n\n\t\tDataCache.Invalidate(File(input))\n\n\t\treturn value\n\n\n\tdef GenerateNanoString(adata, file, p):\n\t\tid = config.Keys()\n\t\tcount = config.Count()\n\t\tif adata is None or id is None or count is None: return\n\n\t\tshape = config.Shape().lower()\n\t\tfeatures = config.Features()\n\t\timg_alpha = config.ImgOpacity()\n\t\tcmap = config.ColorMap().lower()\n\t\talpha = config.Opacity()\n\t\tcolumns = config.Columns()\n\t\tspacing = config.Spacing()\n\t\tdpi = config.DPI()\n\n\t\tp.inc(message=\"Plotting...\")\n\t\tpl.spatial_segment(\n\t\t\tadata,\n\t\t\tcolor=count,\n\t\t\tlibrary_key=\"fov\",\n\t\t\tseg_cell_id=\"cell_ID\",\n\t\t\tlibrary_id=id,\n\t\t\tshape=shape,\n\t\t\timg=\"Image\" in features,\n\t\t\timg_alpha=img_alpha,\n\t\t\tcmap=get_cmap(cmap),\n\t\t\talpha=alpha,\n\t\t\tcolorbar=\"Legend\" in features,\n\t\t\tframeon=\"Frame\" in features,\n\t\t\tncols=columns,\n\t\t\twspace=spacing,\n\t\t\thspace=spacing,\n\t\t\tsave=file.name,\n\t\t\tdpi=dpi\n\t\t)\n\t\timg: types.ImgData = {\"src\": file.name, \"height\": f\"{config.Size()}vh\"}\n\t\treturn img\n\n\tdef GenerateVisium(adata, file, p):\n\t\tcolors = config.Keys()\n\t\tif adata is None or colors is None: return\n\t\ttry:\n\t\t\tgenes = adata[:, adata.var.highly_variable].var_names.values[:100]\n\t\texcept AttributeError:\n\t\t\tgenes=None\n\n\t\tp.inc(message=\"Computing statistic...\")\n\t\tstat = config.Statistic()\n\t\tif stat == \"sepal\" and \"sepal_score\" not in adata.uns:\n\t\t\tgr.sepal(\n\t\t\t\tadata,\n\t\t\t\tgenes=genes,\n\t\t\t\tmax_neighs=6,\n\t\t\t\tshow_progress_bar=False,\n\t\t\t)\n\t\telif (stat == \"moran\" and \"moranI\" not in adata.uns) or (stat == \"geary\" and \"gearyC\" not in adata.uns):\n\t\t\tgr.spatial_autocorr(\n\t\t\t\tadata,\n\t\t\t\tgenes=genes,\n\t\t\t\tmode=stat,\n\t\t\t)\n\n\t\tp.inc(message=\"Plotting...\")\n\t\tshape = config.Shape().lower()\n\t\tfeatures = config.Features()\n\t\timg_alpha = config.ImgOpacity()\n\t\tcmap = config.ColorMap().lower()\n\t\talpha = config.Opacity()\n\t\tcolumns = config.Columns()\n\t\tspacing = config.Spacing()\n\t\tdpi = config.DPI()\n\n\t\tpl.spatial_scatter(\n\t\t\tadata,\n\t\t\tcolor=colors,\n\t\t\tshape=shape,\n\t\t\timg=\"Image\" in features,\n\t\t\timg_alpha=img_alpha,\n\t\t\tcmap=get_cmap(cmap),\n\t\t\talpha=alpha,\n\t\t\tcolorbar=len(colors) > 1 and \"Legend\" in features,\n\t\t\tframeon=\"Frame\" in features,\n\t\t\tncols=columns,\n\t\t\twspace=spacing,\n\t\t\thspace=spacing,\n\t\t\tsave=file.name,\n\t\t\tdpi=dpi\n\t\t)\n\t\timg: types.ImgData = {\"src\": file.name, \"height\": f\"{config.Size()}vh\"}\n\t\treturn img\n\n\n\tdef GenerateHeatmap(file=None):\n\t\t\"\"\"\n\t\t@brief Generates the Annotation Key Spatial Scatter Heatmap, returning an ImgData dictionary\n\t\t@param file: An optional file to use.\n\t\t@returns: An ImgData dictionary\n\n\t\t@info By default, this function will generate a non-deleting TemporaryFile, which means the calling function has the\n\t\tresponsibility of deleting it (Which Shiny handles via render.image). However, for applications like DownloadHeatmap,\n\t\tit has no way to tell Shiny to delete the file, so rather than manually dealing with cleanup, we can just pass it a\n\t\tNamedTemporaryFile within the scope if it's function, and let the Operating System delete it after the call.\n\t\t\"\"\"\n\t\twith ui.Progress() as p:\n\n\t\t\tp.inc(message=\"Loading input...\")\n\t\t\tadata = Data()\n\t\t\tif file is None: file = NamedTemporaryFile(delete=False, suffix=\".png\")\n\t\t\tif input.SourceFile() == \"Example\" or input.UploadType() == \"Visium\":\n\t\t\t\treturn GenerateVisium(adata, file, p)\n\t\t\telif input.UploadType() == \"NanoString\":\n\t\t\t\treturn GenerateNanoString(adata, file, p)\n\n\n\t@output\n\t@render.image(delete_file=True)\n\tdef Heatmap(): return GenerateHeatmap()\n\n\n\t@output\n\t@render.image(delete_file=True)\n\tdef HeatmapReactive(): return GenerateHeatmap()\n\n\n\t@output\n\t@render.plot\n\tdef Centrality():\n\t\twith ui.Progress() as p:\n\n\t\t\tp.inc(message=\"Loading input...\")\n\t\t\tadata = Data()\n\t\t\tscore = config.Score()\n\n\t\t\tif adata is None: return\n\n\t\t\tkey = \"cluster\"\n\t\t\tlocation = f\"{key}_centrality_scores\"\n\n\t\t\tp.inc(message=\"Computing score...\")\n\t\t\tif location not in adata.uns or score not in adata.uns[location]:\n\t\t\t\tgr.centrality_scores(\n\t\t\t\t\tadata,\n\t\t\t\t\tcluster_key=key,\n\t\t\t\t\tshow_progress_bar=False,\n\t\t\t\t\tscore=score,\n\t\t\t\t)\n\n\t\t\tp.inc(message=\"Plotting...\")\n\t\t\tpl.centrality_scores(adata, key, score=score)\n\n\n\t@output\n\t@render.plot\n\tdef Ripley():\n\t\twith ui.Progress() as p:\n\n\t\t\tp.inc(message=\"Loading input...\")\n\t\t\tadata = Data()\n\t\t\tif adata is None: return\n\n\t\t\tfunction = config.Function()\n\t\t\tmetric = config.Distance().lower()\n\n\t\t\t# Because the metric is not uniquely identified within the adata, we cache it\n\t\t\t# and check if the user has changed it. If it has changed, we need to recompute.\n\t\t\t# However, we don't Cache the actual calculation, just the metric, as we would\n\t\t\t# be caching the information twice.\n\t\t\thash_list = [config.Function(), input.SourceFile(), input.Example(), input.File()]\n\t\t\told_metric = DataCache.Get(hash_list)\n\n\t\t\tkey = \"cluster\"\n\n\t\t\tp.inc(message=\"Generating function...\")\n\t\t\tif f\"{key}_ripley_{function}\" not in adata.uns or metric != old_metric:\n\t\t\t\tgr.ripley(\n\t\t\t\t\tadata,\n\t\t\t\t\tcluster_key=key,\n\t\t\t\t\tmode=function,\n\t\t\t\t\tmetric=metric,\n\t\t\t\t)\n\t\t\t\tDataCache.Store(metric, hash_list)\n\n\t\t\tp.inc(message=\"Plotting...\")\n\t\t\tpl.ripley(adata, cluster_key=key, mode=function)\n\n\n\t@output\n\t@render.plot\n\tdef Occurrence():\n\t\twith ui.Progress() as p:\n\n\t\t\tp.inc(message=\"Loading input...\")\n\t\t\tadata = Data()\n\t\t\tif adata is None: return\n\n\t\t\tif input.UploadType() == \"NanoString\":\n\t\t\t\tadata = adata[adata.obs.fov.isin(input.Keys())].copy()\n\n\t\t\tkey = \"cluster\"\n\t\t\tp.inc(message=\"Calculating...\")\n\n\t\t\tinterval = config.Interval()\n\t\t\tsplits = None if input.Splits() == 0 else input.Splits()\n\n\t\t\tif f\"{key}_co_occurrence\" not in adata.uns:\n\t\t\t\tgr.co_occurrence(\n\t\t\t\t\tadata,\n\t\t\t\t\tcluster_key=key,\n\t\t\t\t\tinterval=interval,\n\t\t\t\t\tn_splits=splits,\n\t\t\t\t\tshow_progress_bar=False,\n\t\t\t\t)\n\n\t\t\tp.inc(message=\"Plotting...\")\n\t\t\tif config.OccurrenceGraph() == \"Line\" and config.CoCluster() is not None:\n\t\t\t\tpl.co_occurrence(adata, cluster_key=key, clusters=config.CoCluster())\n\t\t\telse:\n\t\t\t\tpl.spatial_scatter(adata, color=key, size=10, shape=None)\n\n\n\t@reactive.effect\n\t@reactive.event(input.ExampleInfo)\n\tdef ExampleInfo():\n\t\tMsg(ui.HTML(Info[input.Example()]))\n\n\n\t@render.download(filename=\"adata.h5ad\")\n\tdef DownloadTable():\n\t\tadata = Data()\n\t\tif adata is None: return\n\t\ttemp = NamedTemporaryFile();\n\t\tadata.write(temp.name)\n\t\tyield open(temp.name, \"rb\").read()\n\n\n\t@render.download(filename=\"heatmap.png\")\n\tdef DownloadHeatmap():\n\t\t# Generate a TemporaryFile that deletes itself after scope.\n\t\twith NamedTemporaryFile(suffix=\".png\") as file:\n\t\t\tdata = GenerateHeatmap(file)\n\t\t\tif data is None: return\n\t\t\tyield file.read()\n\n\napp_ui = ui.page_fluid(\n\n\tNavBar(),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\t\t\tFileSelection(\n\t\t\t\texamples={\n\t\t\t\t\t\"visium_hne_adata.h5ad\": \"Example 1\",\n\t\t\t\t\t\"seqfish.h5ad\": \"Example 2\",\n\t\t\t\t\t\"imc.h5ad\": \"Example 3\",\n\t\t\t\t},\n\t\t\t\ttypes=[\".h5\", \".png\", \".csv\", \".json\", \".h5ad\", \".jpg\", \".tif\"],\n\t\t\t\tmultiple=True,\n\t\t\t\tdefault=\"Upload\",\n\t\t\t\tproject=\"Spatial\"\n\t\t\t),\n\n\t\t\tui.input_select(id=\"UploadType\", label=None, choices=[\"Visium\", \"NanoString\"]),\n\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'TableTab'\",\n\t\t\t\tconfig.TableType.UI(ui.input_select, id=\"TableType\", label=\"Table\", choices={\"obs\": \"Observations\", \"var\": \"Variable\"}),\n\t\t\t\tTableOptions(config),\n\t\t\t),\n\n\t\t\tui.panel_conditional(\"input.MainTab != 'TableTab'\",\n\t\t\t\tUpdate(),\n\n\t\t\t\tui.HTML(\"<b>Minimum Count Filtering</b>\"),\n\t\t\t\tInlineify(ui.input_numeric, id=\"GeneCount\", label=\"Gene\", min=0, value=400),\n\t\t\t\tInlineify(ui.input_numeric, id=\"CellCount\", label=\"Cell\", min=0, value=100),\n\n\t\t\t\tui.HTML(\"<b>Keys</b>\"),\n\t\t\t\tconfig.Keys.UI(ui.input_select, id=\"Keys\", label=\"Keys\", choices=[], selectize=True, multiple=True),\n\t\t\t\tconfig.Count.UI(ui.input_select, id=\"Count\", label=\"Count\", choices=[]),\n\t\t\t),\n\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'HeatmapTab'\",\n\t\t\t\tui.HTML(\"<b>Heatmap</b>\"),\n\t\t\t\tconfig.Statistic.UI(ui.input_select, id=\"Statistic\", label=\"Statistic\", choices={\"moran\": \"Moran's I\", \"sepal\": \"Sepal\", \"geary\": \"Geary's C\"}),\n\t\t\t\tconfig.ColorMap.UI(ui.input_select, id=\"ColorMap\", label=\"Map\", choices=ColorMaps),\n\t\t\t\tconfig.Shape.UI(ui.input_select, id=\"Shape\", label=\"Shape\", choices=[\"Circle\", \"Square\", \"Hex\"]),\n\t\t\t\tconfig.Columns.UI(ui.input_slider, id=\"Columns\", label=\"Columns\", min=1, max=10, step=1),\n\t\t\t\tconfig.Spacing.UI(ui.input_slider, id=\"Spacing\", label=\"Spacing\", min=0.0, max=1.0, step=0.1),\n\n\t\t\t\tui.HTML(\"<b>Opacity</b>\"),\n\t\t\t\tconfig.ImgOpacity.UI(ui.input_slider, id=\"ImgOpacity\", label=\"Image\", min=0.0, max=1.0, step=0.1),\n\t\t\t\tconfig.Opacity.UI(ui.input_slider, id=\"Opacity\", label=\"Data\", min=0.0, max=1.0, step=0.1),\n\n\t\t\t\tui.HTML(\"<b>Image Settings</b>\"),\n\t\t\t\tconfig.Size.UI(ui.input_numeric, id=\"Size\", label=\"Size\", min=1),\n\t\t\t\tconfig.DPI.UI(ui.input_numeric, id=\"DPI\", label=\"DPI\", min=1),\n\n\t\t\t\tui.HTML(\"<b>Features</b>\"),\n\t\t\t\tconfig.Features.UI(ui.input_checkbox_group, make_inline=False, id=\"Features\", label=None, \tchoices=[\"Image\", \"Legend\", \"Frame\"]),\n\n\t\t\t\tui.download_button(id=\"DownloadHeatmap\", label=\"Download\"),\n\t\t\t),\n\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'Centrality'\",\n\t\t\t\tui.HTML(\"<b>Centrality</b>\"),\n\t\t\t\tconfig.Score.UI(ui.input_select,\n\t\t\t\t\tid=\"Score\",\n\t\t\t\t\tlabel=\"Score\",\n\t\t\t\t\tchoices={\n\t\t\t\t\t\t\"closeness_centrality\": \"Closeness Centrality\",\n\t\t\t\t\t\t\"average_clustering\": \"Average Clustering\",\n\t\t\t\t\t\t\"degree_centrality\": \"Degree Centrality\"\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'Ripley'\",\n\t\t\t\tui.HTML(\"<b>Ripley</b>\"),\n\t\t\t\tconfig.Function.UI(ui.input_select, id=\"Function\", label=\"Function\", choices=[\"L\", \"F\", \"G\"]),\n\t\t\t\tconfig.Distance.UI(ui.input_select, id=\"Distance\", label=\"Distance\", choices=DistanceMethods),\n\t\t\t),\n\n\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'Occurrence'\",\n\t\t\t\tui.HTML(\"<b>Co-Occurrence</b>\"),\n\t\t\t\tconfig.CoCluster.UI(ui.input_select, id=\"CoCluster\", label=\"Group\", choices=[]),\n\t\t\t\tconfig.OccurrenceGraph.UI(ui.input_select, id=\"OccurrenceGraph\", label=\"Graph\", choices=[\"Scatter\", \"Line\"]),\n\t\t\t\tconfig.Interval.UI(ui.input_slider, id=\"Interval\", label=\"Interval\", min=1, max=100, step=1),\n\t\t\t\tconfig.Splits.UI(ui.input_slider, id=\"Splits\", label=\"Splits\", min=0, max=10, step=0),\n\t\t\t),\n\t\t\tpadding=\"10px\",\n\t\t\tgap=\"20px\",\n\t\t\twidth=\"250px\",\n\t\t),\n\n\t\t# Add the main interface tabs.\n\t\tMainTab(\n\t\t\tui.nav_panel(\"Centrality Scores\", ui.output_plot(\"Centrality\", height=\"90vh\"), value=\"Centrality\"),\n\t\t\tui.nav_panel(\"Ripley's Function\", ui.output_plot(\"Ripley\", height=\"90vh\"), value=\"Ripley\"),\n\t\t\tui.nav_panel(\"Co-occurrence\", ui.output_plot(\"Occurrence\", height=\"90vh\"), value=\"Occurrence\")\n\t\t),\n\t\theight=\"90vh\",\n\t)\n)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "config.py", "content": "#\n# Heatmapper\n# Spatial Configuration\n#\n# This file contains configuration for Spatial.\n\n\nfrom shared import Config, ConfigHandler\n\nconfig = ConfigHandler({\n\n\t# \"obs\", \"var\"\n\t\"TableType\": Config(selected=\"obs\"),\n\n\t# \"moran\", \"sepal\", \"geary\"\n\t\"Statistic\": Config(selected=\"moran\"),\n\n\t# See expression's config for description of dynamic inputs\n\t\"Keys\": Config(),\n\t\"Count\": Config(),\n\n\t# See shared.py for ColorMaps\n\t\"ColorMap\": Config(selected=\"Viridis\"),\n\n\t# \"Circle\", \"Square\", \"Hex\"\n\t\"Shape\": Config(selected=\"Hex\"),\n\n\t# A value from 0.0-1.0\n\t\"ImgOpacity\": Config(value=1.0),\n\n\t# A value from 0.0-1.0\n\t\"Opacity\": Config(value=1.0),\n\n\t# Any value from 1-10\n\t\"Columns\": Config(value=2),\n\n\t# Any value from 0.0-1.0\n\t\"Spacing\": Config(value=0.1),\n\n\t# Any value greater than 1.\n\t\"Size\": Config(value=600),\n\n\t# Any value greater than 1.\n\t\"DPI\": Config(value=200),\n\n\t# Any of \"Image\", \"Legend\", \"Frame\"\n\t\"Features\": Config(selected=[\"Image\", \"Legend\"]),\n\n\t# One of \"closeness_centrality\", \"average_clustering\", \"degree_centrality\"\n\t\"Score\": Config(selected=\"closeness_centrality\"),\n\n\t# \"L\", \"F\", \"G\"\n\t\"Function\": Config(selected=\"L\"),\n\n\t# See shared.py DistanceMethods\n\t\"Distance\": Config(selected=\"Euclidean\"),\n\n\t# \"Scatter\", \"Line\"\n\t\"OccurrenceGraph\": Config(selected=\"Scatter\"),\n\n\t# See expression's configuration for dynamic inputs\n\t\"CoCluster\": Config(),\n\n\t# Any value from 1-50\n\t\"Interval\": Config(value=50),\n\n\t# Any value from 0-10\n\t\"Splits\": Config(value=0),\n\n\t# No value, just toggle visibility.\n\t\"DownloadTable\": Config(),\n\n\t# \"Integer\" \"Float\" \"String\"\n\t\"Type\": Config(selected=\"Integer\"),\n})\n", "type": "text"}, {"name": "requirements.txt", "content": "squidpy\nanndata\nscikit-misc", "type": "text"}, {"name": "shared.py", "content": "#\n# Heatmapper\n# Shared\n#\n# This file contains shared functionality between Heatmapper applications. It is not a standalone application.\n# Due to the way ShinyLive exports applications, this file is symlinked into each project to reduce redundancy.\n#\n\nfrom shiny import ui, reactive\nfrom shiny.types import FileInfo\nfrom pandas import DataFrame, read_csv, read_excel, read_table\nfrom io import BytesIO\nfrom tempfile import NamedTemporaryFile\nfrom sys import modules\nfrom pathlib import Path\nfrom enum import Enum\nfrom os.path import exists\nfrom copy import deepcopy\n\n# Used for fetching web resources in a variety of fashions.\nURL = \"https://wishartlab.github.io/heatmapper2\"\nRaw = \"https://raw.githubusercontent.com/WishartLab/heatmapper2/main\"\n\n# Define the Server and Port of the Shiny instances (Port is incremented)\n# Change these if Heatmapper is running on a server.\nServer = \"http://heatmapper2.ca\"\nPort = 8000\n\n# Detect the running environment\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tPyodide = True\n\tasync def fetch(url):\n\t\tresponse = await pyfetch(url)\n\t\tif response.ok: return (await response.bytes())\n\t\telse:\n\t\t\tError(\"Could not download file\")\n\t\t\treturn None\nelse:\n\tfrom urllib.request import urlopen\n\tPyodide = False\n\tasync def fetch(url):\n\t\ttry: return urlopen(url).read()\n\t\texcept Exception:\n\t\t\tError(\"Could not download file!\")\n\t\t\treturn None\n\n# Shared Values\nColors = [\"Blue\", \"Orange\", \"Green\", \"Red\", \"Purple\", \"Brown\", \"Pink\", \"Gray\", \"Olive\", \"Cyan\", \"White\", \"Yellow\"]\nDistanceMethods = [\"Braycurtis\", \"Canberra\", \"Chebyshev\", \"Cityblock\", \"Correlation\", \"Cosine\", \"Dice\", \"Euclidean\", \"Hamming\", \"Jaccard\", \"Jensenshannon\", \"Kulczynski1\", \"Matching\", \"Minkowski\", \"Rogerstanimoto\", \"Russellrao\", \"Seuclidean\", \"Sokalmichener\", \"Sokalsneath\", \"Sqeuclidean\", \"Yule\"]\nInterpolationMethods = [\"None\", \"Antialiased\", \"Nearest\", \"Bilinear\", \"Bicubic\", \"Spline16\", \"Spline36\", \"Hanning\", \"Hamming\", \"Hermite\", \"Kaiser\", \"Quadric\", \"Catrom\", \"Gaussian\", \"Bessel\", \"Mitchell\", \"Sinc\", \"Lanczos\", \"Blackman\"]\nClusteringMethods = [\"Single\", \"Complete\", \"Average\", \"Weighted\", \"Centroid\", \"Median\", \"Ward\"]\nColorMaps = [\"Viridis\", \"Plasma\", \"Inferno\", \"Magma\"]\n\nclass ColumnType(Enum): Time = 0; Name = 1; Value = 2; Longitude = 3; Latitude = 4; X = 5; Y = 6; Z = 7; Cluster = 8; Free = 9; Spatial = 10; NameGeoJSON = 11; FOV = 12; Count = 13\nColumns = {\n\tColumnType.Time: {\"time\", \"date\", \"year\"},\n\tColumnType.Name: {\"name\", \"orf\", \"uniqid\", \"face\", \"triangle\", \"iso_code\", \"continent\", \"country\", \"location\"},\n\tColumnType.Value: {\"value\", \"weight\", \"intensity\", \"in_tissue\"},\n\tColumnType.Longitude: {\"longitude\", \"long\", \"lon\"},\n\tColumnType.Latitude: {\"latitude\", \"lat\"},\n\tColumnType.X: {\"x\"},\n\tColumnType.Y: {\"y\"},\n\tColumnType.Z: {\"z\"},\n\tColumnType.Cluster: {\"cluster\"},\n\tColumnType.Free: {None},\n\tColumnType.Spatial: {\"spatial\"},\n\tColumnType.NameGeoJSON: {\"name\", \"admin\", \"iso_a3\", \"iso_a2\", \"iso\"},\n\tColumnType.FOV: {\"fov\"},\n\tColumnType.Count: {'n_genes_by_counts', 'log1p_n_genes_by_counts', 'total_counts', 'log1p_total_counts', 'pct_counts_in_top_50_genes', 'pct_counts_in_top_100_genes', 'pct_counts_in_top_200_genes', 'pct_counts_in_top_500_genes', 'total_counts_mt', 'log1p_total_counts_mt', 'pct_counts_mt', 'n_counts'}\n\t}\n\n\ndef Filter(columns, ctype: ColumnType, good: list = [], id=None, all=False, remove_unknown=False):\n\t\"\"\"\n\t@brief Filters available column names based on what input we want\n\t@param columns: The columns of the DataFrame (Usually just df.columns)\n\t@param ctype: The type of column we're looking for (Look at the ColumnType Enum)\n\t@param good: A list of column names on top of those defined by the type to be included\n\t@param id: An element id to update with a new value.\n\t@param all: Return all matches columns\n\t@return: A list of column names to use.\n\n\t@info This purpose of this function is to try and remove irrelevant columns from user selection,\n\tbut returning everything if by filtering so we remove all the columns. In essence, it folds the case\n\tof all columns, and performs a set intersection on the required column type. This set is then returned\n\tto the case of the original columns, and then good and bad are applied (Therefore, they are case-sensitive)\n\tSince both good and bad are applied after the intersection, they don't need to be valid names (So long as)\n\tthe application can handle that exception. Look at Geocoordinate to see how it uses a \"None\" and \"Uniform\"\n\tvalue in the good list, despite these values both not a valid ValueColumn, and not existing in the data.\n\n\tThe logic for the UI updating can be confusing, but in essence we don't just want to return the good\n\tlist, because that means we removed all actual columns. If this happens, we return all the columns, and\n\tadd the good list onto the START (So its the default), that way users can choose a column if Heatmapper\n\tdoesn't like their column names.\n\t\"\"\"\n\n\t# Fold cases\n\tfolded = []\n\tfor column in columns:\n\t\ttry:\n\t\t\tfolded.append(column.lower())\n\t\texcept Exception:\n\t\t\tfolded.append(column)\n\toptions = set(folded)\n\tif ctype != ColumnType.Free: options &= Columns[ctype]\n\n\tif remove_unknown:\n\t\tfor type in Columns:\n\t\t\tif type != ctype: options -= Columns[type]\n\n\tindices = [folded.index(value) for value in options]; indices.sort()\n\treassembled = [columns[index] for index in indices] + good\n\n\tif id:\n\t\tif reassembled == good:\n\t\t\toptions = set(folded)\n\t\t\tfor type in Columns:\n\t\t\t\tif type != ctype: options -= Columns[type]\n\t\t\tindices = [folded.index(value) for value in options]; indices.sort()\n\t\t\treassembled = good + [columns[index] for index in indices]\n\t\tui.update_select(id=id, choices=reassembled)\n\tif all: return reassembled\n\treturn reassembled[0] if reassembled and len(reassembled) > 0 else None\n\n\nclass Cache:\n\t\"\"\"\n\t@brief A class that encompasses fetching/storing web resources.\n\t\"\"\"\n\n\t@staticmethod\n\tdef HandleDataFrame(path, function, p=None):\n\t\t\"\"\"\n\t\t@brief Handle DataFrame's\n\t\t@param i: The binary of the file\n\t\t@param function: The pandas function to use to read the file.\n\t\t@returns A DataFrame\n\t\t\"\"\"\n\n\t\t# Read the table once.\n\t\tif p: p.inc(message=\"Reading Table...\")\n\t\tdf = function(path.resolve()).fillna(0)\n\n\t\t# If the first column value is a float, we assume it's data, and not column names.\n\t\t# Re-read the DataFrame with generic column names instead\n\t\ttry:\n\t\t\tfloat(df.columns[0])\n\t\t\tif p: p.inc(message=\"Generating incidices...\")\n\t\t\tdf = function(path.resolve(), header=None, names=[f\"Column {i}\" for i in range(df.shape[1])])\n\t\texcept ValueError: pass\n\t\treturn df\n\n\n\t@staticmethod\n\tdef DefaultHandler(path, p=None):\n\t\t\"\"\"\n\t\t@brief The default handler. It can handle CSVs, Excel files, Tables, and all other files will simply\n\t\tbe stored as strings of the file content\n\n\t\t@param n: The path to the file\n\t\t@returns: An object.\n\t\t\"\"\"\n\n\t\tsuffix = path.suffix\n\t\tif suffix == \".csv\": return Cache.HandleDataFrame(path, read_csv, p)\n\t\telif suffix in {\".xlsx\", \".xls\", \".odf\"}: return Cache.HandleDataFrame(path, read_excel, p)\n\t\telif suffix in {\".txt\", \".dat\", \".tsv\", \".tab\"}: return Cache.HandleDataFrame(path, read_table, p)\n\t\telse: return open(path.resolve(), \"r\").read()\n\n\n\tasync def _local(self, url):\n\t\tif not exists(url): return None\n\t\treturn open(url, \"rb\").read()\n\n\n\tdef __init__(self, project, DataHandler = DefaultHandler):\n\t\t\"\"\"\n\t\t@brief Initialize an instance of the Cache object.\n\t\t@param project: The name of the project. This is used to fetch web resources.\n\t\t@param DataHandler:\tThe function that should be called to process files. It should\n\t\t\t\t\t\t\t\t\t\t\t\ttake a name, and a binary stream, and return a DataFrame.\n\t\t\"\"\"\n\n\t\t# The primary is the unprocessed, fetched web resources\n\t\tself._primary = {}\n\n\t\t# The objects are anything that applications want to store\n\t\tself._objects = {}\n\n\t\t# The data handler for processing the binary files.\n\t\tself._handler = DataHandler\n\n\t\t# If we're in a Pyodide environment, we fetch resources from the web.\n\t\tif Pyodide:\n\t\t\tself._download = fetch\n\t\t\tself._source = f\"{Raw}/{project}/example_input/\"\n\n\t\t# Otherwise, we fetch locally.\n\t\telse:\n\t\t\tself._download = self._local\n\t\t\tself._source = \"../example_input/\"\n\n\n\tasync def Download(self, n, p=None):\n\t\t\"\"\"\n\t\t@brief Downloads any arbitrary URL and stores it in the cache\n\t\t@param n: The URL name\n\t\t@returns The handled data\n\n\t\t\"\"\"\n\t\tif n not in self._primary:\n\t\t\traw = await (fetch(n) if n.startswith(\"https://\") else self._download(n))\n\t\t\tif raw is None: return None\n\n\t\t\tpath = Path(n)\n\t\t\tif path.is_file():\n\t\t\t\tself._primary[n] = self._handler(path, p)\n\t\t\telse:\n\t\t\t\ttemp = NamedTemporaryFile(suffix=Path(n).suffix);\n\t\t\t\ttemp.write(raw);\n\t\t\t\ttemp.seek(0)\n\t\t\t\tself._primary[n] = self._handler(Path(temp.name), p)\n\t\ttry:\n\t\t\treturn deepcopy(self._primary[n])\n\t\texcept Exception:\n\t\t\treturn self._primary[n]\n\n\n\tasync def Load(self,\n\t\tinput,\n\t\tsource_file=None,\n\t\texample_file=None,\n\t\tsource=None,\n\t\tinput_switch=None,\n\t\tupload=\"Upload\",\n\t\texample=\"Example\",\n\t\tdefault=DataFrame(),\n\t\tp=None,\n\t\tp_name=\"file\",\n\t\twasm=True,\n\t\twasm_blacklist=tuple()\n\t\t):\n\n\t\t\"\"\"\n\t\t@brief Caches whatever the user has currently uploaded/selection, returning the identifier within the secondary cache.\n\t\t@param input: The Shiny input variable. Importantly, these must be defined:\n\t\t\tinput.File: The uploaded file\n\t\t\tinput.Example: The selected example file\n\t\t\tinput.SourceFile: Whether the user wants \"Upload\" or \"Example\"\n\t\t@param source_file: The input ID that should be used to fetch the file (Defaults to input.File() if None)\n\t\t@param example_file: The input ID that should be used to fetch th example (Defaults to input.Example() if None)\n\t\t@param input_switch:\tThe input ID to check for Upload/Example/Other. The value is compared against \"Upload\" for user\n\t\t\t\t\t\t\t\t\t\t\t\t\tuploaded items, and defaults to fetching example_file otherwise. (Defaults to input.SourceFile())\n\t\t@param upload: The value of the input_switch such that we should fetch a source file from source_file\n\t\t@param example: The value of the input_switch such that we should fetch an example from example_file\n\t\t@param default:\tThe object that should be returned if files cannot be fetched. Ensures that Load will always return an\n\t\t\t\t\t\t\t\t\t\tobject, avoiding the needing to check output. Defaults to a DataFrame. The object should be able to\n\t\t\t\t\t\t\t\t\t\tinitialize without arguments.\n\t\t@param p: A progress bar to increment; optional.\n\t\t@param p_name: What we're fetching, to be displayed in the progress bar; optional\n\t\t@param wasm: Whether this fetch can run in WebAssembly\n\t\t@param wasm_blacklist: A tuple of file extensions that should not be fetched in WebAssembly.\n\t\t@returns The data if it exists; default if no file can be found; 0 if there's a WebAssembly violation\n\t\t\"\"\"\n\n\t\tif not wasm and Pyodide:\n\t\t\tif p: p.close()\n\t\t\treturn 0\n\n\t\tif source_file is None: source_file = input.File()\n\t\tif example_file is None: example_file = input.Example()\n\t\tif source is None: source = self._source\n\t\tif input_switch is None: input_switch = input.SourceFile()\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input_switch == upload:\n\t\t\tif p: p.inc(message=f\"Loading Uploaded {p_name}...\")\n\t\t\tfile: list[FileInfo] | None = source_file\n\t\t\tif file is None:\n\t\t\t\tif p: p.close()\n\t\t\t\treturn default\n\n\t\t\tif p: p.inc(message=f\"Handling {p_name}...\")\n\t\t\t# The datapath can be immediately used to load examples, but we explicitly need to use\n\t\t\t# Local as a user uploaded file will always be fetched on disk.\n\t\t\tn = str(file[0][\"datapath\"])\n\t\t\tif n.endswith(wasm_blacklist) and Pyodide:\n\t\t\t\tif p: p.close()\n\t\t\t\treturn 0\n\t\t\tif n not in self._primary: self._primary[n] = self._handler(Path(n), p)\n\n\t\t# Example files, conversely, can be on disk or on a server depending on whether we're in a WASM environment.\n\t\telif input_switch == example:\n\t\t\tif p: p.inc(message=f\"Fetching {p_name}...\")\n\n\t\t\t# If we explicitly provide a URL, use it, but only in Pyodide (We still assume the file exists on disk when running\n\t\t\t# in server-mode).\n\t\t\tif example_file.startswith(\"https://\"):\n\t\t\t\tn = example_file if Pyodide else str(source + example_file.split(\"/\")[-1])\n\t\t\telse:\n\t\t\t\tn = str(source + example_file)\n\n\t\t\tif n.endswith(wasm_blacklist) and Pyodide:\n\t\t\t\tif p: p.close()\n\t\t\t\treturn 0\n\n\t\t\tif p: p.close()\n\t\t\treturn await self.Download(n)\n\n\t\t# If the application has a unique method of input (IE 3D's ID, don't handle it.)\n\t\telse:\n\t\t\tif p: p.close()\n\t\t\treturn None\n\n\t\tif p: p.close()\n\t\t# If the object cannot be copied, then we can just return it directly\n\t\ttry:\n\t\t\treturn deepcopy(self._primary[n])\n\t\texcept Exception:\n\t\t\treturn self._primary[n]\n\n\n\tdef Store(self, object, inputs):\n\t\t\"\"\"\n\t\t@brief Store arbitrary data in the Cache.\n\t\t@param object: The object to store\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\th = \"\".join(str(i) for i in inputs)\n\t\tself._objects[h] = object\n\n\n\tdef Get(self, inputs):\n\t\t\"\"\"\n\t\t@brief Retrieve arbitrary data in the Cache.\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\th = \"\".join(str(i) for i in inputs)\n\t\tif h in self._objects:\n\t\t\t\treturn self._objects[h]\n\t\telse: return None\n\n\tdef In(self, inputs):\n\t\th = \"\".join(str(i) for i in inputs)\n\t\treturn h in self._objects\n\n\n\tdef Invalidate(self, input):\n\t\tinvalid = []\n\t\tfor key, value in self._objects.items():\n\t\t\tif input in key:\n\t\t\t\tinvalid.append(key)\n\t\tfor i in invalid: del self._objects[i]\n\n\ndef NavBar():\n\t\"\"\"\n\t@brief Returns a Navigation Bar for each project, with the current project selected.\n\t@returns A list, containing a ui.panel_title, and a ui.navset_bar.\n\t\"\"\"\n\n\tSources = {\n\t\t\"expression\": f\"{URL}/site/expression/index.html\" if Pyodide else f\"{Server}:{Port}\",\n\t\t\"pairwise\": f\"{URL}/site/pairwise/index.html\" if Pyodide else f\"{Server}:{Port + 1}\",\n\t\t\"image\": f\"{URL}/site/image/index.html\" if Pyodide else f\"{Server}:{Port + 2}\",\n\t\t\"geomap\": f\"{URL}/site/geomap/index.html\" if Pyodide else f\"{Server}:{Port + 3}\",\n\t\t\"geocoordinate\": f\"{URL}/site/geocoordinate/index.html\" if Pyodide else f\"{Server}:{Port + 4}\",\n\t\t\"3d\": f\"{URL}/site/3d/index.html\" if Pyodide else f\"{Server}:{Port + 5}\",\n\t\t\"spatial\": f\"{Server}:{Port + 6}\",\n\t}\n\n\treturn (\n\t\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\t\tui.navset_bar(\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"expression\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Expression</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"pairwise\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Pairwise</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"image\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Image</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geomap\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geomap</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geocoordinate\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geocoordinate</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"3d\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">3D</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"spatial\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Spatial</a>')),\n\t\t\tui.nav_control(ui.HTML('<a href=https://github.com/WishartLab/heatmapper2/wiki target=\"_blank\" rel=\"noopener noreferrer\">About</a>')),\n\t\t\tui.nav_spacer(),\n\t\t\tui.nav_control(ui.input_dark_mode(id=\"mode\")),\n\t\t\ttitle=ui.HTML(\n\t\t\t\tf'<a href=\"{URL}\" target=\"_blank\" rel=\"noopener noreferrer\"> \\\n\t\t\t\t\t<img src=\"{Raw}/site/logo.png\" alt=\"Heatmapper\"> \\\n\t\t\t\t</a>'),\n\t\t),\n\t)\n\n\ndef FileSelection(examples, types, upload_label=None, multiple=False, default=\"Upload\", project=\"Overview\", extras=[]):\n\t\"\"\"\n\t@brief Returns the file selection dialog for the user to upload/select an example\n\t@param examples: Either a list of example file names, or a dictionary mapping\n\t@param types: The valid file extensions for user uploaded files.\n\t@param upload_label: The label for the upload input. Useful to define specifically what kind of files are needed\n\t@param multiple: Whether to accept multiple files.\n\t@param default: Whether to start on the example, or upload dialog\n\t@param project: The name of a project, to specify a specified header within the Interface documentation\n\t@param extras: Extra options for giving the application information no render. You are responsible for handling it.\n\t@returns A list, containing the necessary ui components for uploading/selecting\n\t@info The returns elements are named:\n\t\tinput.SourceFile: The ui.input_radio_buttons for whether the user wants to choose an \"Example\" or \"Upload\"\n\t\tinput.File: The ui.input_file for user uploaded files.\n\t\tinput.Example: The ui.input_select for an example file selection\n\t@info multiple=True is not handled properly by the Cache. You will need to create a function that properly handles\n\t\teach file (See spatial for an implementation)\n\t@info If you're examples are large files, or require significant computation, you may want to switch it to Upload instead.\n\t\"\"\"\n\n\treturn [\n\t\tui.HTML(f\"<a href='https://github.com/WishartLab/heatmapper2/wiki/Interface#{project}' target='_blank' rel='noopener noreferrer'>Help</a>\"),\n\n\t\tui.input_radio_buttons(\n\t\t\tid=\"SourceFile\",\n\t\t\tlabel=ui.HTML(\"Specify a File (<a href=https://github.com/WishartLab/heatmapper2/wiki/Format target='_blank' rel='noopener noreferrer'>Format</a>)\"),\n\t\t\tchoices=[\"Example\", \"Upload\"] + extras,\n\t\t\tselected=default,\n\t\t\tinline=True\n\t),\n\n\t\t# Only display an input dialog if the user is one Upload\n\t\tui.panel_conditional(\n\t\t\t\"input.SourceFile === 'Upload'\",\n\t\t\tui.input_file(id=\"File\", label=None, accept=types, multiple=multiple),\n\t\t),\n\t\tui.panel_conditional(\n\t\t\t\"input.SourceFile === 'Example'\",\n\t\t\tInlineify(ui.input_select, id=\"Example\", label=ui.input_action_link(id=\"ExampleInfo\", label=\"Example\"), choices=examples),\n\t\t),\n\t]\n\n\ndef TableOptions(config):\n\t\"\"\"\n\t@brief Return the options for Table Manipulation.\n\t@returns A conditional panel that provides a DataType, and a ResetButton.\n\t\"\"\"\n\treturn  ui.panel_conditional(\n\t\t\"input.MainTab === 'TableTab'\",\n\t\tconfig.Type.UI(ui.input_radio_buttons, make_inline=False, id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"], inline=True),\n\t\tui.input_action_button(id=\"Reset\", label=\"Reset Values\"),\n\t\tui.download_button(id=\"DownloadTable\", label=\"Download Table\"),\n\t),\n\n\ndef MainTab(*args, m_type=ui.output_plot):\n\treturn ui.navset_tab(\n\t\tui.nav_panel(\"Heatmap\",\n\t\t\tui.panel_conditional(\"input.UpdateToggle\", m_type(id=\"Heatmap\")),\n\t\t\tui.panel_conditional(\"!input.UpdateToggle\", m_type(id=\"HeatmapReactive\")),\n\t\t\tvalue=\"HeatmapTab\"\n\t\t),\n\t\tui.nav_panel(\"Table\", ui.output_data_frame(id=\"Table\"), value=\"TableTab\"),\n\t\t*args,\n\t\tid=\"MainTab\"\n\t)\n\n\ndef Inlineify(ui_element, widths=[4,8], gap=\"20px\", **kwargs):\n\tlabel = kwargs[\"label\"]\n\tkwargs[\"label\"] = None\n\treturn ui.layout_columns(\n\t\tlabel,\n\t\tui_element(**kwargs),\n\t\tcol_widths=widths,\n\t\tgap=gap,\n\t)\n\nclass Config:\n\t\"\"\"\n\t@brief A configuration entry.\n\t\"\"\"\n\n\tdef __init__(self, visible=True, **kwargs):\n\t\t\"\"\"\n\t\t@brief Create a configuration entry.\n\t\t@param default: The default value for an input.\n\t\t@param visible: Whether the input should be shown in the sidebar\n\t\t@param **kwargs: Arguments to be passed to the input.\n\t\t\"\"\"\n\t\tself.visible = visible\n\t\tself.kwargs = kwargs\n\t\tif \"selected\" in kwargs:\n\t\t\tself.default = kwargs[\"selected\"]\n\t\telif \"value\" in kwargs:\n\t\t\tself.default = kwargs[\"value\"]\n\t\telse:\n\t\t\tself.default = None\n\t\tself.resolve = None\n\n\tdef __call__(self):\n\t\ttry:\n\t\t\tresolved = self.resolve()\n\t\t\treturn self.default if resolved is None else resolved\n\t\texcept Exception:\n\t\t\treturn self.default\n\n\n\tdef Resolve(self, input):\n\t\tself.resolve = input\n\n\n\tdef UI(self, ui_element, make_inline=True, widths=[4,8], gap=\"20px\", conditional=None, *args, **kwargs):\n\t\t\"\"\"\n\t\t@brief Displays the configured UI.\n\t\t@param ui The Shiny interface element to use.\n\t\t@parram **kwargs: Additional arguments to be passed to the input.\n\t\t@note\tkeyword arguments passed to the Config object during initialization will overrule\n\t\t\t\t\targuments passed to this function. Duplicates are allowed.\n\t\t\"\"\"\n\n\t\tcombined = self.kwargs\n\n\t\tfor key in kwargs.keys():\n\t\t\tcombined[key] = kwargs[key]\n\n\t\tif \"selected\" in combined: combined[\"selected\"] = self()\n\t\telif \"value\" in combined: combined[\"value\"] = self()\n\n\t\tif self.visible:\n\t\t\tif make_inline and \"label\" in combined:\n\t\t\t\telement = Inlineify(ui_element, widths, gap, **combined)\n\t\t\telse: element = ui_element(*args, **combined)\n\n\t\t\t# There doesn't seem any good way to remove the conditional panel spacing.\n\t\t\t# Rather than having conditional configurations stick out due to inconsistent spacing\n\t\t\t# Just give all the panels the same spacing by putting them in true conditions.\n\t\t\treturn ui.panel_conditional(\"1 === 1\" if conditional is None else conditional, element, _add_ws=False)\n\n\nclass ConfigHandler(dict):\n\t\"\"\"\n\t@brief: A dictionary that can be accessed with dots, and can automatically resolve.\n\t\"\"\"\n\n\t__getattr__ = dict.get\n\t__setattr__ = dict.__setitem__\n\t__delattr__ = dict.__delitem__\n\n\n\tdef Resolve(self, input):\n\t\t\"\"\"\n\t\t@brief Resolves all stored objects.\n\t\t@param input The input to use for resolving.\n\t\t\"\"\"\n\t\tfor conf, var in self.items():\n\t\t\tvar.Resolve(input[conf])\n\n\ndef InitializeConfig(config, input):\n\t\"\"\"\n\t@brief Initializes the configuration variable.\n\t@param config: The configuration variable\n\t@param input: The Shiny input\n\n\tThis function will update each configuration's resolve member, so that\n\tif\n\t\"\"\"\n\tfor conf, var in config.items(): var.Resolve(input[conf])\n\n\ndef Error(message, exception=None):\n\tif exception:\n\t\tmessage = f\"{message} due to {type(exception).__name__}: {exception}\"\n\n\treturn ui.notification_show(ui=message, type=\"error\", duration=3)\n\ndef Msg(message): return ui.notification_show(ui=message, type=\"default\", duration=3)\n\n\ndef Update(): return ui.input_action_button(\n\t\tid=\"Update\",\n\t\tlabel=ui.layout_columns(\n\t\t\tui.panel_conditional(\"input.UpdateToggle\", \"Auto\"),\n\t\t\t\"Update\",\n\t\t\tui.input_switch(id=\"UpdateToggle\", label=None, value=True),\n\t\t\tcol_widths=[1,9,1],\n\t\t\tgap=\"1px\",\n\t\t\theight=\"1px\", \t# Make it as small as possible\n\t\t)\n\t)\n\n\ndef File(input):\n\tif input.SourceFile() == \"Upload\":\n\t\treturn \"None\" if input.File() is None else input.File()[0][\"name\"]\n\treturn input.Example()\n", "type": "text"}]