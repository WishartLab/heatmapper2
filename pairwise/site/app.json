[{"name": "app.py", "content": "#\n# Heatmapper\n# Pairwise\n#\n# This file contains the ShinyLive application for Pairwise Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshinylive export . [site]\n# Where [site] is the destination of the site folder.\n#\n# If you would rather deploy the application as a PyShiny application,\n# run the following command within this directory:\n#\t\tshiny run\n#\n#\n\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom matplotlib.pyplot import subplots, colorbar\nfrom scipy.spatial.distance import pdist, squareform\nfrom Bio.PDB import PDBParser\nfrom Bio import SeqIO\nfrom pandas import DataFrame, read_csv, read_excel, read_table\nfrom pathlib import Path\n\nfrom shared import Table, Cache, NavBar, FileSelection\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n\n\t# Information about the Examples\n\tInfo = {\n\t\t\"example1.txt\": \"This example dataset represents pairwise distances between C-alpha atoms in ubiquitin (1ubq).\",\n\t\t\"example2.txt\": \"This example dataset was generated randomly.\",\n\t\t\"example3.txt\": \"This example dataset was generated randomly.\"\n\t}\n\n\tdef HandleData(n, i):\n\t\tmatch Path(n).suffix:\n\t\t\tcase \".csv\": return read_csv(i)\n\t\t\tcase \".xlsx\": return read_excel(i)\n\t\t\tcase \".pdb\": return PDBMatrix(i)\n\t\t\tcase \".fasta\": return FASTAMatrix(i)\n\t\t\tcase _: return read_table(i)\n\tDataCache = Cache(\"pairwise\", HandleData)\n\n\n\tasync def ParseData():\n\t\t\"\"\"\n\t\t@brief Returns a table containing the pairwise matrix.\n\t\t@returns\tA DataFrame containing the data requested, formatted as a pairwise matrix, or\n\t\t\t\t\t\t\tan empty DataFrame if we're on Upload, but the user has not supplied a file.\n\t\t\"\"\"\n\t\tn = await DataCache.N(input)\n\t\tdf = await DataCache.Load(input)\n\n\t\tif n is None: return DataFrame()\n\t\tmatch Path(n).suffix:\n\t\t\tcase \".csv\": df = ChartMatrix(df)\n\t\t\tcase \".xlsx\": df = ChartMatrix(df)\n\t\t\tcase \".pdb\": pass\n\t\t\tcase \".fasta\": pass\n\t\t\tcase _: df = ChartMatrix(df)\n\n\t\t# Fix garbage data and return the resultant DataFrame.\n\t\treturn df.fillna(0)\n\n\n\tdef FASTAMatrix(file):\n\t\t\"\"\"\n\t\t@brief Computes the pairwise matrix from a FASTA file.\n\t\t@param file: The path to the FASTA File\n\t\t@returns a pairwise matrix.\n\t\t\"\"\"\n\n\t\t# Get information from the file\n\t\trecords = list(SeqIO.parse(open(file), \"fasta\"))\n\t\tsequences = [str(record.seq) for record in records]\n\t\tcolumn_names = [record.id for record in records]\n\n\t\t# Get our K-Mer value\n\t\tk = input.K()\n\n\t\t# Generate the value\n\t\tdictionary = {}\n\t\tfor x, seq in enumerate(sequences):\n\t\t\tkmers = [seq[i:i+k] for i in range(len(seq) - k + 1)]\n\t\t\tincrement = 1 / len(kmers)\n\t\t\tfor kmer in kmers:\n\t\t\t\t\tif kmer not in dictionary:\n\t\t\t\t\t\t\tdictionary[kmer] = [0.0] * len(sequences)\n\t\t\t\t\tdictionary[kmer][x] += increment\n\t\tfrequencies = DataFrame.from_dict(dictionary, orient='index')\n\n\t\t# Calculate matrix\n\t\tif input.MatrixType() == \"Distance\":\n\t\t\tdistances = pdist(frequencies.T, metric=input.DistanceMethod().lower())\n\t\t\treturn DataFrame(squareform(distances), index=column_names, columns=column_names)\n\t\telse:\n\t\t\treturn frequencies.corr(method=input.CorrelationMethod().lower())\n\n\n\tdef PDBMatrix(file):\n\t\t\"\"\"\n\t\t@brief Generates a pairwise matrix from a PDB file\n\t\t@param file: The path to a PDB file (Or BytesIO file if applicable)\n\t\t@returns The pairwise matrix.\n\t\t\"\"\"\n\n\t\tparser = PDBParser()\n\t\tstructure = parser.get_structure(\"protein\", file)\n\n\t\t# Extract atomic coordinates\n\t\tcoordinates = []\n\t\tfor model in structure:\n\t\t\tfor chain in model:\n\t\t\t\t\tif chain.id == input.Chain():\n\t\t\t\t\t\t\tfor residue in chain:\n\t\t\t\t\t\t\t\t\tfor atom in residue:\n\t\t\t\t\t\t\t\t\t\t\tcoordinates.append(atom.coord)\n\n\t\t# Calculate matrix\n\t\tif input.MatrixType() == \"Distance\":\n\t\t\tdistances = pdist(coordinates, metric=input.DistanceMethod().lower())\n\t\t\treturn DataFrame(squareform(distances))\n\t\telse:\n\t\t\treturn DataFrame(coordinates).corr(method=input.CorrelationMethod().lower())\n\n\n\tdef ChartMatrix(df):\n\t\t\"\"\"\n\t\t@brief Generates a pairwise matrix from charts\n\t\t@param df:\tThe DataFrame containing the data. This can either be a chart\n\t\t\t\t\t\t\t\tcontaining {x,y,z} columns outlining each point on a row, with\n\t\t\t\t\t\t\t\tan optional name column (Any fourth column), a chart to which\n\t\t\t\t\t\t\t\tan explicit \"Name\" column is provided, to which the first row\n\t\t\t\t\t\t\t\tand column are assumed variable names for an existing matrix,\n\t\t\t\t\t\t\t\tor the default, where it is assumed that the chart is an\n\t\t\t\t\t\t\t\tunlabeled collection either of points, or an existing matrix.\n\t\t@returns A DataFrame containing the provided data as a pairwise matrix\n\t\t\"\"\"\n\n\t\t# If \"Name\" is found, its assumed to be the label for the points.\n\t\tif \"Name\" in df:\n\t\t\tpoint_names = df[\"Name\"]\n\n\t\t# If explicit coordinates ar eprovided, use them, with the final column used as labels.\n\t\tif \"x\" in df.columns and \"y\" in df.columns and \"z\" in df.columns:\n\t\t\tcoordinates = df[[\"x\", \"y\", \"z\"]].values\n\t\t\tpoint_names = df[list(set(df.columns) - set([\"x\", \"y\", \"z\"]))[0]].values\n\n\t\telse:\n\n\t\t\t# If the first value is an integer, this is a distance matrix.\n\t\t\ttry:\n\t\t\t\tint(df.iloc[0,0])\n\t\t\t\tcoordinates = df.values\n\n\t\t\t# Otherwise, we assume the first row/column define the axis names.\n\t\t\texcept ValueError:\n\t\t\t\tcoordinates = df.iloc[:, 1:].values\n\n\t\t\tpoint_names = None\n\n\t\t# Calculate a distant matrix, and return it\n\t\tif input.MatrixType() == \"Distance\":\n\t\t\tdistances = pdist(coordinates, metric=input.DistanceMethod().lower())\n\t\t\treturn DataFrame(squareform(distances), index=point_names, columns=point_names)\n\t\telse:\n\t\t\treturn DataFrame(coordinates, index=point_names, columns=point_names).corr(method=input.CorrelationMethod().lower())\n\n\n\tasync def GenerateHeatmap():\n\t\t\"\"\"\n\t\t@brief Generates the Heatmap\n\t\t@returns The heatmap\n\t\t\"\"\"\n\n\t\tdf = await ParseData()\n\t\tfig, ax = subplots()\n\n\t\tim = ax.imshow(df, cmap=input.ColorMap().lower(), interpolation=input.Interpolation().lower())\n\n\t\t# Visibility of features\n\t\tif \"legend\" in input.Features(): colorbar(im, ax=ax, label=\"Distance\")\n\n\t\tif \"y\" in input.Features():\n\t\t\tax.tick_params(axis=\"y\", labelsize=input.TextSize())\n\t\t\tax.set_yticks(range(len(df.columns)))\n\t\t\tax.set_yticklabels(df.columns)\n\t\telse:\n\t\t\tax.set_yticklabels([])\n\n\t\tif \"x\" in input.Features():\n\t\t\tax.tick_params(axis=\"x\", labelsize=input.TextSize())\n\t\t\tax.set_xticks(range(len(df.columns)))\n\t\t\tax.set_xticklabels(df.columns, rotation=90)\n\t\telse:\n\t\t\tax.set_xticklabels([])\n\n\t\t# Annotate each cell with its value\n\t\tif \"label\" in input.Features():\n\t\t\tfor i in range(df.shape[0]):\n\t\t\t\t\tfor j in range(df.shape[1]):\n\t\t\t\t\t\t\tax.text(j, i, '{:.2f}'.format(df.iloc[i, j]), ha='center', va='center', color='white')\n\n\t\treturn ax\n\n\n\t@output\n\t@render.data_frame\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, ignore_none=False, ignore_init=False)\n\tasync def LoadedTable(): return await DataCache.Load(input)\n\n\n\t@output\n\t@render.plot\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, input.MatrixType, input.TextSize, input.DistanceMethod, input.CorrelationMethod, input.Interpolation, input.ColorMap, input.Features, input.Chain, input.K, ignore_none=False, ignore_init=False)\n\tasync def Heatmap(): return await GenerateHeatmap()\n\n\t@output\n\t@render.text\n\tdef ExampleInfo(): return Info[input.Example()]\n\n\n\t@render.download(filename=\"table.csv\")\n\tasync def DownloadTable(): df = await DataCache.Load(input); yield df.to_string()\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Update)\n\tasync def Update(): await DataCache.Update(input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Reset)\n\tasync def Reset(): await DataCache.Purge(input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.TableRow, input.TableCol, input.Example, input.File, input.Reset, input.Update)\n\tasync def UpdateTableValue():\n\t\t\"\"\"\n\t\t@brief Updates the label for the Value input to display the current value.\n\t\t\"\"\"\n\t\tdf = await DataCache.Load(input)\n\n\t\trows, columns = df.shape\n\t\trow, column = int(input.TableRow()), int(input.TableCol())\n\n\t\tif 0 <= row <= rows and 0 <= column <= columns:\n\t\t\tui.update_text(id=\"TableVal\", label=\"Value (\" + str(df.iloc[row, column]) + \")\"),\n\n\napp_ui = ui.page_fluid(\n\n\tNavBar(\"Pairwise\"),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\n\t\t\tFileSelection(\n\t\t\t\texamples={\"example1.txt\": \"Example 1\", \"example2.txt\": \"Example 2\", \"example3.txt\": \"Example 3\"},\n\t\t\t\ttypes=[\".csv\", \".txt\", \".xlsx\", \".pdb\", \".dat\", \".fasta\"]\n\t\t\t),\n\n\t\t\t# Specify Matrix Type\n\t\t\tui.input_radio_buttons(id=\"MatrixType\", label=\"Matrix Type\", choices=[\"Distance\", \"Correlation\"], selected=\"Distance\", inline=True),\n\n\t\t\t# Customize the text size of the axes.\n\t\t\tui.input_numeric(id=\"TextSize\", label=\"Text Size\", value=8, min=1, max=50, step=1),\n\n\t\t\t# https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MatrixType === 'Distance'\",\n\t\t\t\tui.input_select(id=\"DistanceMethod\", label=\"Distance Method\", choices=[\n\t\t\t\t\t\"Braycurtis\", \"Canberra\", \"Chebyshev\", \"Cityblock\", \"Correlation\", \"Cosine\", \"Dice\", \"Euclidean\", \"Hamming\", \"Jaccard\", \"Jensenshannon\", \"Kulczynski1\", \"Mahalanobis\", \"Matching\", \"Minkowski\", \"Rogerstanimoto\", \"Russellrao\", \"Seuclidean\", \"Sokalmichener\", \"Sokalsneath\", \"Sqeuclidean\", \"Yule\"], selected=\"Euclidean\"),\n\t\t\t),\n\n\t\t\t# https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.corr.html\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MatrixType === 'Correlation'\",\n\t\t\t\tui.input_select(id=\"CorrelationMethod\", label=\"Correlation Method\", choices=[\"Pearson\", \"Kendall\", \"Spearman\"], selected=\"Pearson\"),\n\t\t\t),\n\n\t\t\t# https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html\n\t\t\tui.input_select(id=\"Interpolation\", label=\"Interpolation\", choices=[\"None\", \"Antialiased\", \"Nearest\", \"Bilinear\", \"Bicubic\", \"Spline16\", \"Spline36\", \"Hanning\", \"Hamming\", \"Hermite\", \"Kaiser\", \"Quadric\", \"Catrom\", \"Gaussian\", \"Bessel\", \"Mitchell\", \"Sinc\", \"Lanczos\", \"Blackman\"], selected=\"Nearest\"),\n\n\t\t\t# Set the ColorMap used.\n\t\t\tui.input_select(id=\"ColorMap\", label=\"Color Map\", choices=[\"Viridis\", \"Plasma\", \"Inferno\", \"Magma\", \"Cividis\"], selected=\"Viridis\"),\n\n\t\t\t# Customize what aspects of the heatmap are visible\n\t\t\tui.input_checkbox_group(id=\"Features\", label=\"Heatmap Features\",\n\t\t\t\t\tchoices={\"x\": \"X Labels\", \"y\": \"Y Labels\", \"label\": \"Data Labels\", \"legend\": \"Legend\"},\n\t\t\t\t\tselected=[\"legend\"]),\n\n\t\t\t# Specify the PDB Chain\n\t\t\tui.input_text(\"Chain\", \"PDB Chain\", \"A\"),\n\n\t\t\t# Customize the K-mer to compute for FASTA sequences\n\t\t\tui.input_numeric(id=\"K\", label=\"K-Mer Length\", value=3, min=3, max=5, step=1),\n\n\t\t\t# Add the download buttons.\n\t\t\tui.download_button(\"DownloadTable\", \"Download Table\"),\n\t\t),\n\n\t\t# Add the main interface tabs.\n\t\tui.navset_tab(\n\t\t\t\tui.nav_panel(\"Interactive\", ui.output_plot(\"Heatmap\", height=\"90vh\")),\n\t\t\t\tTable\n\t\t),\n\t)\n)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "requirements.txt", "content": "biopython", "type": "text"}, {"name": "shared.py", "content": "#\n# Heatmapper\n# Shared\n#\n# This file contains shared functionality between Heatmapper applications. It is not a standalone application.\n# Due to the way ShinyLive exports applications, this file is symlinked into each project to reduce redundancy.\n#\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nfrom pandas import DataFrame, read_csv, read_excel, read_table\nfrom io import BytesIO\nfrom sys import modules\nfrom copy import deepcopy\nfrom pathlib import Path\n\n# If pyodide is found, we're running WebAssembly.\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tPyodide = True\n# Otherwise,\nelse:\n\tfrom os.path import exists\n\tPyodide = False\n\n\nTemporalColumns = {\"time\", \"date\"}\n\n\ndef Filter(columns, good_columns, bad_columns):\n\tret = None\n\tfor column in columns:\n\t\tlowered = column.lower()\n\t\tif lowered in good_columns:\n\t\t\treturn column\n\t\telif lowered in bad_columns:\n\t\t\tbreak\n\t\telif ret is not None:\n\t\t\tret = column\n\treturn ret\n\n\nclass Cache:\n\t\"\"\"\n\t@brief A class that encompasses fetching/storing web resources.\n\t\"\"\"\n\n\t@staticmethod\n\tdef DefaultHandler(n, i):\n\t\t\"\"\"\n\t\t@brief The default handler. It can handle csv, xlsx, and defaults all other files to read_table\n\t\t@param n: The name of the file. We use this for pattern matching against the suffix.\n\t\t@param i: The binary of the file (Either via read() or BytesIO())\n\t\t@returns: A null-filled DataFrame.\n\t\t\"\"\"\n\t\tmatch Path(n).suffix:\n\t\t\tcase \".csv\": df = read_csv(i)\n\t\t\tcase \".xlsx\": df = read_excel(i)\n\t\t\tcase _: df = read_table(i)\n\t\treturn df.fillna(0)\n\n\n\t@staticmethod\n\tasync def Remote(url): r = await pyfetch(url); return await r.bytes() if r.ok else None\n\n\n\t@staticmethod\n\tasync def Local(url): return open(url, \"rb\").read() if exists(url) else None\n\n\n\tdef __init__(self, project, DataHandler = DefaultHandler):\n\t\t\"\"\"\n\t\t@brief Initialize an instance of the Cache object.\n\t\t@param project: The name of the project. This is used to fetch web resources.\n\t\t@param DataHandler:\tThe function that should be called to process files. It should\n\t\t\t\t\t\t\t\t\t\t\t\ttake a name, and a binary stream, and return a DataFrame.\n\t\t\"\"\"\n\n\t\t# The primary cache is immutable, and is used when the resource has not been fetched before.\n\t\tself._primary = {}\n\n\t\t# The secondary cache is mutable, and is populated by the primary cache. Purge deletes from here.\n\t\tself._secondary = {}\n\n\t\t# The data handler for processing the binary files.\n\t\tself._handler = DataHandler\n\n\t\t# If we're in a Pyodide environment, we fetch resources from the web.\n\t\tif Pyodide:\n\t\t\tself.Download = lambda url: Cache.Remote(url)\n\t\t\tself.Source = \"https://raw.githubusercontent.com/kkernick/kkernick.github.io/main/{}/example_input/\".format(project)\n\n\t\t# Otherwise, we fetch locally.\n\t\telse:\n\t\t\tself.Download = lambda url: Cache.Local(url)\n\t\t\tself.Source = \"../example_input/\"\n\n\n\tasync def Load(self, input, copy=False):\n\t\tn = await self.N(input);\n\t\tdf = DataFrame() if n is None else self._secondary[n]\n\t\treturn deepcopy(df) if copy else df\n\n\n\tasync def N(self, input):\n\t\t\"\"\"\n\t\t@brief Caches whatever the user has currently uploaded/selection, returning the identifier within the secondary cache.\n\t\t@param input: The Shiny input variable. Importantly, these must be defined:\n\t\t\tinput.File: The uploaded file\n\t\t\tinput.Example: The selected example file\n\t\t\tinput.SourceFile: Whether the user wants \"Upload\" or \"Example\"\n\t\t@returns: The identifier. You should probably use Load() unless you need this.\n\t\t\"\"\"\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.File()\n\t\t\tif file is None: return None\n\t\t\tn = file[0][\"name\"]\n\n\t\t\t# Populate the base cache, if we need to\n\t\t\tif n not in self._primary: self._primary[n] = self._handler(n, read(file[0][\"datapath\"], \"wb\"))\n\n\t\telse:\n\t\t\tn = input.Example()\n\t\t\tif n not in self._primary: self._primary[n] = self._handler(n, BytesIO(await self.Download(self.Source + n)))\n\t\tif n not in self._secondary: self._secondary[n] = deepcopy(self._primary[n])\n\t\treturn n\n\n\n\tdef Cache(self): return self._secondary\n\n\n\tasync def Update(self, input):\n\t\t\"\"\"\n\t\t@brief Updates information within the secondary cache based on user selection\n\t\t@param input: The Shiny input. Importantly, these must be defined:\n\t\t\tinput.TableRow: The row to modify\n\t\t\tinput.TableCol: The column to modify\n\t\t\tinput.TableVal: What the user wants to set as the new value\n\t\t@info This function should be called on a reactive hook for a \"Update\" button.\n\t\t\"\"\"\n\n\t\t# Get the data\n\t\tdf = await self.Load(input)\n\t\trow_count, column_count = df.shape\n\t\trow, column = input.TableRow(), input.TableCol()\n\n\t\t# So long as row and column are sane, update.\n\t\tif row < row_count and column < column_count:\n\t\t\tmatch input.Type():\n\t\t\t\tcase \"Integer\": df.iloc[row, column] = int(input.TableVal())\n\t\t\t\tcase \"Float\": df.iloc[row, column] = float(input.TableVal())\n\t\t\t\tcase \"String\": df.iloc[row, column] = input.TableVal()\n\n\n\tasync def Purge(self, input):\n\t\t\"\"\"\n\t\t@brief Purges the secondary cache of whatever the user has uploaded/selected\n\t\t@param input: The Shiny input. See N() for required objects.\n\t\t@info This function should be called on a reactive hook for a \"Reset\" button.\n\t\t\"\"\"\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.File()\n\t\t\tif file is None: return None\n\t\t\tn = file[0][\"name\"]\n\t\telse:\n\t\t\tn = input.Example()\n\t\tdel self._secondary[n]\n\n\ndef NavBar(current):\n\t\"\"\"\n\t@brief Returns a Navigation Bar for each project, with the current project selected.\n\t@returns A list, containing a ui.panel_title, and a ui.navset_bar.\n\t\"\"\"\n\n\treturn [\n\t\t\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\n\t\tui.navset_bar(\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/expression/site/index.html>Expression</a>'), value=\"Expression\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/pairwise/site/index.html>Pairwise</a>'), value=\"Pairwise\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/image/site/index.html>Image</a>'), value=\"Image\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/geomap/site/index.html>Geomap</a>'), value=\"Geomap\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/geocoordinate/site/index.html>Geocoordinate</a>'), value=\"Geocoordinate\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/about/site/index.html>About</a>'), value=\"About\"),\n\t\t\t\ttitle=\"Heatmapper\",\n\t\t\t\tselected=current,\n\t\t)\n\t]\n\n\ndef FileSelection(examples, types):\n\t\"\"\"\n\t@brief Returns the file selection dialog for the user to upload/select an example\n\t@param examples: Either a list of example file names, or a dictionary mapping\n\t@param types: The valid file extensions for user uploaded files.\n\t@returns A list, containing the necessary ui components for uploading/selecting\n\t@info The returns elements are named:\n\t\tinput.SourceFile: The ui.input_radio_buttons for whether the user wants to choose an \"Example\" or \"Upload\"\n\t\tinput.File: The ui.input_file for user uploaded files.\n\t\tinput.Example: The ui.input_select for an example file selection\n\t\"\"\"\n\n\t# If the user needs help with the formatting.\n\treturn [ui.HTML('<a href=https://kkernick.github.io/about/site/index.html>Data Format</a>'),\n\n\t# Specify whether to use example files, or upload one.\n\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"], selected=\"Example\", inline=True),\n\n\t# Only display an input dialog if the user is one Upload\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Upload'\",\n\t\tui.input_file(\"File\", \"Choose a File\", accept=types, multiple=False),\n\t),\n\n\t# Otherwise, add the example selection and an info button.\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Example'\",\n\t\tui.layout_columns(\n\t\t\tui.input_select(id=\"Example\", label=None, choices=examples, multiple=False),\n\t\t\tui.popover(ui.input_action_link(id=\"ExampleInfoButton\", label=\"Info\"), ui.output_text(\"ExampleInfo\")),\n\t\t\tcol_widths=[10,2],\n\t\t)\n\t)]\n\n\n# The Table element\nTable = ui.nav_panel(\"Table\",\n\tui.layout_columns(\n\t\tui.input_numeric(\"TableRow\", \"Row\", 0),\n\t\tui.input_numeric(\"TableCol\", \"Column\", 0),\n\t\tui.input_text(\"TableVal\", \"Value\", 0),\n\t\tui.input_select(id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"]),\n\t\tcol_widths=[2,2,6,2],\n\t),\n\tui.layout_columns(\n\t\tui.input_action_button(\"Update\", \"Update\"),\n\t\tui.input_action_button(\"Reset\", \"Reset Values\"),\n\t),\n\tui.output_data_frame(\"LoadedTable\"),\n)\n", "type": "text"}]