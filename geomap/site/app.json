[{"name": "app.py", "content": "#\n# Heatmapper\n# Geomap\n#\n# This file contains the ShinyLive application for Geomap Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshinylive export . [site]\n# Where [site] is the destination of the site folder.\n#\n# If you would rather deploy the application as a PyShiny application,\n# run the following command within this directory:\n#\t\tshiny run\n#\n#\n\nfrom shiny import App, reactive, render, ui\nfrom folium import Map as FoliumMap, Choropleth\nfrom folium.plugins import TimeSliderChoropleth\nfrom pandas import DataFrame, to_datetime\nfrom branca.colormap import linear\nfrom pathlib import Path\nfrom json import loads\n\nfrom shared import Cache, NavBar, MainTab, FileSelection, Pyodide, Filter, ColumnType, TableValueUpdate, Raw\nfrom geojson import Mappings\n\n# Fine, Shiny\nimport branca, certifi, xyzservices\n\nURL = f\"{Raw}/geomap/data/\" if Pyodide else \"../data/\"\n\ndef server(input, output, session):\n\n\tInfo = {\n\t\t\"example1.txt\": \"This example file is from the Open Data Portal. The data is from a carbon monoxide emissions study conducted by Environment Canada. The three columns represent results from 1990, 2000, and 2013.\",\n\t\t\"example2.txt\": \"This example file is from Statistics Canada. The data is adapted from New cases and age-standardized rate for primary cancer (based on the February 2014 CCR tabulation file), by cancer type and sex, Canada, provinces and territories. The columns represent new cancer cases (age-standardized rate per 100,000 population) from 2006 to 2010.\",\n\t\t\"example3.txt\": \"This example file is from the U.S. Centers for Disease Control and Prevention. The data is from Diagnosed Diabetes, Age Adjusted Rate (per 100), Adults - Total, 2013.\",\n\t\t\"example6.csv\": \"COVID 19 information reported by the Canadian Government, available at https://open.canada.ca/data/en/dataset/261c32ab-4cfd-4f81-9dea-7b64065690dc/resource/39434379-45a1-43d5-aea7-a7a50113c291\"\n\t}\n\n\tdef HandleData(path):\n\t\t\"\"\"\n\t\t@brief A custom Data Handler for the Cache.\n\t\t@param path: Path to the file\n\t\t@returns A data object from the cache.\n\t\t@info This Data Handler supports geojson files as json\n\t\t\"\"\"\n\t\tif path.suffix == \".geojson\": return loads(path.open().read())\n\t\telse: return DataCache.DefaultHandler(path)\n\tDataCache = Cache(\"geomap\", DataHandler=HandleData)\n\n\n\tasync def LoadChoropleth(df, map, geojson, k_col, v_col):\n\t\t\"\"\"\n\t\t@brief Applies a Choropleth to a Folium Map\n\t\t@param df: The DataFrame that contains information to plot\n\t\t@param map: The Folium map\n\t\t@param geojson: The geojson information that contains territory information\n\t\t@param k_vol: The name of the column within df that contains names\n\t\t@param v_col: the name of the column within df that contains the values to plot.\n\t\t\"\"\"\n\t\tChoropleth(\n\t\t\t\tgeo_data=geojson,\n\t\t\t\tname=\"choropleth\",\n\t\t\t\tdata=df,\n\t\t\t\tcolumns=[k_col, v_col],\n\t\t\t\tkey_on=\"feature.properties.name\",\n\t\t\t\tfill_color=input.ColorMap().lower(),\n\t\t\t\tfill_opacity=input.Opacity(),\n\t\t\t\tline_opacity=input.Opacity(),\n\t\t\t\tlegend_name=\"Legend\",\n\t\t\t\tbins=input.Bins()\n\t\t).add_to(map)\n\n\n\tasync def LoadTemporalChoropleth(df, map, geojson, k_col, v_col):\n\t\t\"\"\"\n\t\t@brief Applies a TimeSliderChoropleth to a Folium map\n\t\t@param df: The DataFrame that contains data to plot\n\t\t@param map: The Folium map\n\t\t@param geojson: The geojson information that contains territory information\n\t\t@param k_col: The name of the column within df that contains names\n\t\t@param v_col: The name of the column within df that contains the values to plot.\n\t\t@info df can either contain a Time column, or all non key-columns will be handled as time columns.\n\t\t\"\"\"\n\t\t# Check if we have a dedicated time column, or separate columns for each time slot.\n\t\tcolumn = Filter(df.columns, ColumnType.Time, bad = [k_col, v_col], only_one=True, reject_unknown=True)\n\t\tvalues = v_col if column else df.columns[1:]\n\n\t\tcolor = input.ColorMap()\n\t\tif color == \"Inferno\": cmap = linear.inferno.scale\n\t\telif color == \"Magma\": cmap = linear.magma.scale\n\t\telif color == \"Plasma\": cmap = linear.plasma.scale\n\t\telif color == \"Viridis\": cmap = linear.viridis.scale\n\n\t\tm, M = df[values].values.min(), df[values].values.max()\n\t\tcolormap = cmap(m, M)\n\n\t\tstyle = {}\n\n\t\tif column:\n\t\t\tgrouped = df.groupby(k_col)\n\n\t\t\tfor i, (name, group) in enumerate(grouped):\n\t\t\t\tstyle[i] = {}\n\t\t\t\tfor a, row in group.iterrows():\n\n\t\t\t\t\t# If the year isn't parsable, pray that it just works without parsing :)\n\t\t\t\t\ttry: year = str(to_datetime(row[column].split()[0]).timestamp()).split('.')[0]\n\t\t\t\t\texcept Exception: year = row[column]\n\n\t\t\t\t\tstyle[i][year] = {'color': colormap(row[v_col]), 'opacity': input.Opacity()}\n\t\t\t\tfor feature in geojson[\"features\"]:\n\t\t\t\t\t\t\tif feature[\"properties\"][\"name\"] == name:\n\t\t\t\t\t\t\t\t\tfeature[\"id\"] = i\n\n\t\telse:\n\t\t\t# Convert DataFrame to style format\n\t\t\tfor i, row in df.iterrows():\n\t\t\t\t\tname = row[k_col]\n\t\t\t\t\tstyle[i] = {}\n\t\t\t\t\tfor year in df.columns[1:]:\n\t\t\t\t\t\tvalue = row[year]\n\n\t\t\t\t\t\t# If the year isn't parsable, pray that it just works without parsing :)\n\t\t\t\t\t\ttry: year = str(to_datetime(year.split()[0]).timestamp()).split('.')[0]\n\t\t\t\t\t\texcept Exception: pass\n\n\t\t\t\t\t\tstyle[i][year] = {'color': colormap(value), 'opacity': input.Opacity()}\n\t\t\t\t\tfor feature in geojson[\"features\"]:\n\t\t\t\t\t\tif feature[\"properties\"][\"name\"] == name:\n\t\t\t\t\t\t\t\tfeature[\"id\"] = i\n\n\t\tTimeSliderChoropleth(\n\t\t\t\tdata=geojson,\n\t\t\t\tstyledict=style,\n\t\t).add_to(map)\n\t\tcolormap.add_to(map)\n\n\n\tasync def LoadMap():\n\t\t\"\"\"\n\t\t@brief Generates a map with the provided information\n\t\t@returns the Folium.Map\n\t\t\"\"\"\n\n\t\twith ui.Progress() as p:\n\n\t\t\tp.inc(message=\"Loading input...\")\n\t\t\tdf = await DataCache.Load(input)\n\n\t\t\tp.inc(message=\"Loading GeoJSON...\")\n\t\t\tgeojson = await DataCache.Load(\n\t\t\t\tinput,\n\t\t\t\tsource_file=input.JSONUpload(),\n\t\t\t\texample_file=input.JSONSelection(),\n\t\t\t\tsource=URL,\n\t\t\t\tinput_switch=input.JSONFile(),\n\t\t\t\tdefault=None\n\t\t\t)\n\n\t\t\tp.inc(message=\"Formatting...\")\n\t\t\tk_col, v_col = input.KeyColumn(), input.ValueColumn()\n\t\t\tif k_col not in df or v_col not in df: return\n\n\t\t\t# Give a placeholder map if nothing is selected, which should never really be the case.\n\t\t\tif df.empty or geojson is None: return FoliumMap((53.5213, -113.5213), tiles=input.MapType(), zoom_start=15)\n\n\t\t\t# Create map\n\t\t\tmap = FoliumMap(tiles=input.MapType())\n\n\t\t\tif type(input.ROI()) is tuple:\n\t\t\t\tm, M = df[v_col].min(), df[v_col].max()\n\t\t\t\tl, u = input.ROI()[0], input.ROI()[1]\n\t\t\t\tif l >= m and u <= M:\n\t\t\t\t\toob = []\n\t\t\t\t\tfor index, row in df.iterrows():\n\t\t\t\t\t\tv = row[v_col]\n\t\t\t\t\t\tif v < l or v > u: oob.append(index)\n\t\t\t\t\tdf = df.drop(oob)\n\n\t\t\t# Load the choropleth.\n\t\t\tp.inc(message=\"Plotting...\")\n\t\t\tif input.Temporal(): await LoadTemporalChoropleth(df, map, geojson, k_col, v_col)\n\t\t\telse: await LoadChoropleth(df, map, geojson, k_col, v_col)\n\n\t\t\tmap.fit_bounds(map.get_bounds())\n\t\t\treturn map\n\n\n\t@output\n\t@render.data_frame\n\t@reactive.event(input.SourceFile, input.File, input.Example, input.Update, input.Reset)\n\tasync def LoadedTable(): return await DataCache.Load(input)\n\n\n\t@output\n\t@render.ui\n\t@reactive.event(input.SourceFile, input.File, input.Example, input.Update, input.Reset, input.JSONFile, input.JSONSelection, input.JSONUpload, input.Temporal, input.KeyColumn, input.ValueColumn, input.MapType, input.ColorMap, input.Opacity, input.Bins, input.ROI)\n\tasync def Heatmap(): return await LoadMap()\n\n\n\t@output\n\t@render.data_frame\n\t@reactive.event(input.JSONFile, input.JSONSelection, input.JSONUpload)\n\tasync def GeoJSON():\n\t\tgeojson = await DataCache.Load(\n\t\t\tinput,\n\t\t\tsource_file=input.JSONUpload(),\n\t\t\texample_file=input.JSONSelection(),\n\t\t\tsource=URL,\n\t\t\tinput_switch=input.JSONFile(),\n\t\t\tdefault=None\n\t\t)\n\t\tif geojson is None: return\n\t\tnames = [feature['properties']['name'] for feature in geojson['features']]\n\t\treturn DataFrame({'Name': names})\n\n\n\t@output\n\t@render.text\n\t@reactive.event(input.SourceFile, input.Example)\n\tdef ExampleInfo(): return Info[input.Example()]\n\n\n\t@render.download(filename=\"table.csv\")\n\tasync def DownloadTable(): yield (await DataCache.Load(input)).to_string()\n\n\n\t@render.download(filename=\"heatmap.html\")\n\tasync def DownloadHeatmap(): yield (await LoadMap()).get_root().render()\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Example, input.File, input.Reset, input.Update, input.Temporal)\n\tasync def UpdateColumns():\n\t\tdf = await DataCache.Load(input)\n\t\tkey = Filter(df.columns, ColumnType.Name, only_one=True, ui_element=\"KeyColumn\")\n\t\tFilter(df.columns, ColumnType.Value, bad=[key], ui_element=\"ValueColumn\")\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Update)\n\tasync def Update(): await DataCache.Update(input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Reset)\n\tasync def Reset(): await DataCache.Purge(input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.SourceFile, input.File, input.Example, input.TableRow, input.TableCol, input.Update, input.Reset)\n\tasync def UpdateTableValue(): TableValueUpdate(await DataCache.Load(input), input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.SourceFile, input.File, input.Example, input.Update, input.Reset, input.ValueColumn)\n\tasync def UpdateROI():\n\t\tdf = await DataCache.Load(input)\n\t\tv_col = input.ValueColumn()\n\t\tif v_col not in df: ui.update_slider(id=\"ROI\", value=0, min=0, max=0)\n\t\telse:\n\t\t\tm, M = int(df[v_col].min()), int(df[v_col].max())\n\t\t\tui.update_slider(id=\"ROI\", value=(m, M), min=m, max=M)\n\n\napp_ui = ui.page_fluid(\n\n\tNavBar(\"Geomap\"),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\n\t\t\tFileSelection(\n\t\t\t\texamples={\"example1.txt\": \"Example 1\", \"example2.txt\": \"Example 2\", \"example3.txt\": \"Example 3\", \"example6.csv\": \"Example 4\"},\n\t\t\t\ttypes=[\".csv\", \".txt\", \".dat\", \".tsv\", \".tab\", \".xlsx\", \".xls\", \".odf\"],\n\t\t\t\tproject=\"Geomap\"\n\t\t\t),\n\n\t\t\tui.input_radio_buttons(id=\"JSONFile\", label=\"Specify a GeoJSON File\", choices=[\"Provided\", \"Upload\"], selected=\"Provided\", inline=True),\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.JSONFile === 'Upload'\",\n\t\t\t\tui.input_file(\"JSONUpload\", \"Choose a File\", accept=[\".geojson\"], multiple=False),\n\t\t\t),\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.JSONFile === 'Provided'\",\n\t\t\t\tui.input_select(id=\"JSONSelection\", label=None, choices=Mappings, multiple=False, selected=\"canada.geojson\"),\n\t\t\t),\n\n\t\t\tui.input_checkbox(id=\"Temporal\", label=\"Temporal Choropleth\"),\n\n\t\t\tui.input_select(id=\"KeyColumn\", label=\"Key\", choices=[], multiple=False),\n\t\t\tui.input_select(id=\"ValueColumn\", label=\"Value\", choices=[], multiple=False),\n\n\t\t\t# Only OpenStreatMap and CartoDB Positron seem to work.\n\t\t\tui.input_radio_buttons(id=\"MapType\", label=\"Map Type\", choices=[\"OpenStreetMap\", \"CartoDB Positron\"], selected=\"CartoDB Positron\"),\n\n\t\t\tui.input_select(id=\"ColorMap\", label=\"Color Map\", choices=[\"Inferno\", \"Magma\", \"Plasma\", \"Viridis\"], selected=\"Viridis\"),\n\t\t\tui.input_slider(id=\"Opacity\", label=\"Heatmap Opacity\", value=0.5, min=0.0, max=1.0, step=0.1),\n\t\t\tui.input_slider(id=\"Bins\", label=\"Number of Colors\", value=8, min=3, max=8, step=1),\n\t\t\tui.input_slider(id=\"ROI\", label=\"Range of Interest\", value=(0,0), min=0, max=100),\n\n\t\t\t# Add the download buttons.\n\t\t\t\"Download\",\n\t\t\tui.download_button(\"DownloadHeatmap\", \"Heatmap\"),\n\t\t\tui.download_button(\"DownloadTable\", \"Table\"),\n\n\t\t\tid=\"SidebarPanel\",\n\t\t),\n\n\t\tMainTab(ui.nav_panel(\"GeoJSON\", ui.output_data_frame(\"GeoJSON\")), m_type=ui.output_ui),\n\t)\n)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "geojson.py", "content": "# Generated from dictionary.sh\nMappings = { \"africa.geojson\": \"Africa\", \"akron.geojson\": \"Akron\", \"alameda.geojson\": \"Alameda\", \"albany.geojson\": \"Albany\", \"albuquerque.geojson\": \"Albuquerque\", \"amsterdam.geojson\": \"Amsterdam\", \"amusement-parks.geojson\": \"Amusement Parks\", \"anchorage.geojson\": \"Anchorage\", \"angers.geojson\": \"Angers\", \"angers-loire-metropole.geojson\": \"Angers Loire Metropole\", \"antwerp.geojson\": \"Antwerp\", \"apulia.geojson\": \"Apulia\", \"arlingtonva.geojson\": \"Arlingtonva\", \"asia.geojson\": \"Asia\", \"athens.geojson\": \"Athens\", \"atlanta.geojson\": \"Atlanta\", \"augsburg.geojson\": \"Augsburg\", \"austin.geojson\": \"Austin\", \"australia.geojson\": \"Australia\", \"austria-oberoesterreich.geojson\": \"Austria Oberoesterreich\", \"austria-states.geojson\": \"Austria States\", \"austria-steiermark.geojson\": \"Austria Steiermark\", \"bad-belzig.geojson\": \"Bad Belzig\", \"badenwuerttemberg-kreise.geojson\": \"Badenwuerttemberg Kreise\", \"baltimore.geojson\": \"Baltimore\", \"bari.geojson\": \"Bari\", \"basel.geojson\": \"Basel\", \"bayern.geojson\": \"Bayern\", \"belgium-arrondissements.geojson\": \"Belgium Arrondissements\", \"berlin.geojson\": \"Berlin\", \"bern-districts.geojson\": \"Bern Districts\", \"bern-quarters.geojson\": \"Bern Quarters\", \"birmingham.geojson\": \"Birmingham\", \"blacksburg.geojson\": \"Blacksburg\", \"blumenau.geojson\": \"Blumenau\", \"bogota.geojson\": \"Bogota\", \"boston.geojson\": \"Boston\", \"brandenburg.geojson\": \"Brandenburg\", \"brandenburg-municipalities.geojson\": \"Brandenburg Municipalities\", \"braunschweig.geojson\": \"Braunschweig\", \"brazil-states.geojson\": \"Brazil States\", \"bremen.geojson\": \"Bremen\", \"bronx.geojson\": \"Bronx\", \"brooklyn.geojson\": \"Brooklyn\", \"buenos-aires.geojson\": \"Buenos Aires\", \"calgary.geojson\": \"Calgary\", \"california-counties.geojson\": \"California Counties\", \"california-vista-points.geojson\": \"California Vista Points\", \"caltrain-stations.geojson\": \"Caltrain Stations\", \"canada.geojson\": \"Canada\", \"canberra.geojson\": \"Canberra\", \"caribbean-islands.geojson\": \"Caribbean Islands\", \"chapel-hill.geojson\": \"Chapel Hill\", \"charlotte.geojson\": \"Charlotte\", \"charlottesville.geojson\": \"Charlottesville\", \"chemnitz.geojson\": \"Chemnitz\", \"chesapeake.geojson\": \"Chesapeake\", \"chicago.geojson\": \"Chicago\", \"china.geojson\": \"China\", \"cincinnati.geojson\": \"Cincinnati\", \"cleveland.geojson\": \"Cleveland\", \"cologne.geojson\": \"Cologne\", \"colorado-counties.geojson\": \"Colorado Counties\", \"columbus.geojson\": \"Columbus\", \"copenhagen.geojson\": \"Copenhagen\", \"cuba.geojson\": \"Cuba\", \"dallas.geojson\": \"Dallas\", \"dane-county-municipalities.geojson\": \"Dane County Municipalities\", \"denmark-municipalities.geojson\": \"Denmark Municipalities\", \"denver.geojson\": \"Denver\", \"des-moines.geojson\": \"Des Moines\", \"detroit.geojson\": \"Detroit\", \"dresden.geojson\": \"Dresden\", \"dublin.geojson\": \"Dublin\", \"duesseldorf.geojson\": \"Duesseldorf\", \"durham.geojson\": \"Durham\", \"edmonton.geojson\": \"Edmonton\", \"eindhoven.geojson\": \"Eindhoven\", \"enschede.geojson\": \"Enschede\", \"esztergom.geojson\": \"Esztergom\", \"europe-1914.geojson\": \"Europe 1914\", \"europe-1938.geojson\": \"Europe 1938\", \"europe-capitals.geojson\": \"Europe Capitals\", \"europe.geojson\": \"Europe\", \"fairbanks.geojson\": \"Fairbanks\", \"fargo.geojson\": \"Fargo\", \"fort-lauderdale.geojson\": \"Fort Lauderdale\", \"france-departments.geojson\": \"France Departments\", \"france-regions.geojson\": \"France Regions\", \"frankfurt-main.geojson\": \"Frankfurt Main\", \"freiburg.geojson\": \"Freiburg\", \"geneva.geojson\": \"Geneva\", \"germany-capitals.geojson\": \"Germany Capitals\", \"germany.geojson\": \"Germany\", \"ghent.geojson\": \"Ghent\", \"gisborne.geojson\": \"Gisborne\", \"grand-rapids.geojson\": \"Grand Rapids\", \"greece-prefectures.geojson\": \"Greece Prefectures\", \"greece-regions.geojson\": \"Greece Regions\", \"hamburg.geojson\": \"Hamburg\", \"hampton.geojson\": \"Hampton\", \"hartford.geojson\": \"Hartford\", \"henderson.geojson\": \"Henderson\", \"honolulu.geojson\": \"Honolulu\", \"houston.geojson\": \"Houston\", \"hungary.geojson\": \"Hungary\", \"illinois-counties.geojson\": \"Illinois Counties\", \"india.geojson\": \"India\", \"indianapolis.geojson\": \"Indianapolis\", \"iran-provinces.geojson\": \"Iran Provinces\", \"ireland-counties.geojson\": \"Ireland Counties\", \"isle-of-man.geojson\": \"Isle Of Man\", \"italy-provinces.geojson\": \"Italy Provinces\", \"italy-regions.geojson\": \"Italy Regions\", \"james-city-county.geojson\": \"James City County\", \"japan.geojson\": \"Japan\", \"kaiserslautern.geojson\": \"Kaiserslautern\", \"kansas-city.geojson\": \"Kansas City\", \"korea.geojson\": \"Korea\", \"las-vegas.geojson\": \"Las Vegas\", \"leipzig.geojson\": \"Leipzig\", \"le-mans-cantons.geojson\": \"Le Mans Cantons\", \"lexington.geojson\": \"Lexington\", \"liberia-central.geojson\": \"Liberia Central\", \"liberia-east.geojson\": \"Liberia East\", \"liberia.geojson\": \"Liberia\", \"liberia-west.geojson\": \"Liberia West\", \"lombardy.geojson\": \"Lombardy\", \"london.geojson\": \"London\", \"london-underground.geojson\": \"London Underground\", \"long-beach.geojson\": \"Long Beach\", \"los-angeles-county.geojson\": \"Los Angeles County\", \"los-angeles.geojson\": \"Los Angeles\", \"louisville.geojson\": \"Louisville\", \"luxembourg-cantons.geojson\": \"Luxembourg Cantons\", \"luxembourg-communes.geojson\": \"Luxembourg Communes\", \"luzern.geojson\": \"Luzern\", \"macon.geojson\": \"Macon\", \"madrid-districts.geojson\": \"Madrid Districts\", \"madrid.geojson\": \"Madrid\", \"malaysia.geojson\": \"Malaysia\", \"manhattan-bridges.geojson\": \"Manhattan Bridges\", \"manhattan.geojson\": \"Manhattan\", \"melbourne.geojson\": \"Melbourne\", \"mexico.geojson\": \"Mexico\", \"miami.geojson\": \"Miami\", \"middle_east_countries.geojson\": \"Middle_east_countries\", \"milan.geojson\": \"Milan\", \"milwaukee.geojson\": \"Milwaukee\", \"minneapolis-cities.geojson\": \"Minneapolis Cities\", \"minneapolis.geojson\": \"Minneapolis\", \"mississauga.geojson\": \"Mississauga\", \"montreal.geojson\": \"Montreal\", \"moscow.geojson\": \"Moscow\", \"muenster.geojson\": \"Muenster\", \"new-haven.geojson\": \"New Haven\", \"new-orleans.geojson\": \"New Orleans\", \"new-york-areas-of-interest.geojson\": \"New York Areas Of Interest\", \"new-york-city-boroughs.geojson\": \"New York City Boroughs\", \"new-york-counties.geojson\": \"New York Counties\", \"nordrhein-westfalen.geojson\": \"Nordrhein Westfalen\", \"norfolk.geojson\": \"Norfolk\", \"north-america.geojson\": \"North America\", \"north-carolina-cities.geojson\": \"North Carolina Cities\", \"oakland.geojson\": \"Oakland\", \"oceania.geojson\": \"Oceania\", \"oklahoma-cities.geojson\": \"Oklahoma Cities\", \"oklahoma-counties.geojson\": \"Oklahoma Counties\", \"olympia.geojson\": \"Olympia\", \"oman.geojson\": \"Oman\", \"oman-provinces.geojson\": \"Oman Provinces\", \"orlando.geojson\": \"Orlando\", \"pakistan.geojson\": \"Pakistan\", \"paris.geojson\": \"Paris\", \"peaks.geojson\": \"Peaks\", \"philadelphia.geojson\": \"Philadelphia\", \"phoenix.geojson\": \"Phoenix\", \"pittsburgh.geojson\": \"Pittsburgh\", \"poland.geojson\": \"Poland\", \"poland-parks.geojson\": \"Poland Parks\", \"porirua.geojson\": \"Porirua\", \"portland.geojson\": \"Portland\", \"portugal.geojson\": \"Portugal\", \"potsdam.geojson\": \"Potsdam\", \"prague.geojson\": \"Prague\", \"providence.geojson\": \"Providence\", \"quebec.geojson\": \"Quebec\", \"queens.geojson\": \"Queens\", \"raleigh.geojson\": \"Raleigh\", \"red-deer.geojson\": \"Red Deer\", \"richmond.geojson\": \"Richmond\", \"riga.geojson\": \"Riga\", \"rio-de-janeiro.geojson\": \"Rio De Janeiro\", \"rochester.geojson\": \"Rochester\", \"rockville.geojson\": \"Rockville\", \"roller-coasters-fastest-steel.geojson\": \"Roller Coasters Fastest Steel\", \"romania.geojson\": \"Romania\", \"rome-rioni.geojson\": \"Rome Rioni\", \"rotterdam.geojson\": \"Rotterdam\", \"russia.geojson\": \"Russia\", \"sacramento.geojson\": \"Sacramento\", \"salt-lake-city.geojson\": \"Salt Lake City\", \"san-antonio.geojson\": \"San Antonio\", \"san-diego.geojson\": \"San Diego\", \"san-francisco.geojson\": \"San Francisco\", \"san-jose.geojson\": \"San Jose\", \"saskatoon.geojson\": \"Saskatoon\", \"savannah.geojson\": \"Savannah\", \"seattle.geojson\": \"Seattle\", \"seoul.geojson\": \"Seoul\", \"serbia.geojson\": \"Serbia\", \"silicon-valley.geojson\": \"Silicon Valley\", \"south-africa.geojson\": \"South Africa\", \"south-america.geojson\": \"South America\", \"southeast-asia.geojson\": \"Southeast Asia\", \"spain-communities.geojson\": \"Spain Communities\", \"spain-provinces.geojson\": \"Spain Provinces\", \"springfield.geojson\": \"Springfield\", \"stamford.geojson\": \"Stamford\", \"staten-island.geojson\": \"Staten Island\", \"st-louis.geojson\": \"St Louis\", \"st-petersburg.geojson\": \"St Petersburg\", \"surrey.geojson\": \"Surrey\", \"sweden-counties.geojson\": \"Sweden Counties\", \"switzerland.geojson\": \"Switzerland\", \"sydney.geojson\": \"Sydney\", \"szczecin.geojson\": \"Szczecin\", \"taiwan.geojson\": \"Taiwan\", \"tampa.geojson\": \"Tampa\", \"the-hague.geojson\": \"The Hague\", \"the-netherlands.geojson\": \"The Netherlands\", \"thessaloniki.geojson\": \"Thessaloniki\", \"toronto.geojson\": \"Toronto\", \"tucson.geojson\": \"Tucson\", \"turkey.geojson\": \"Turkey\", \"turku.geojson\": \"Turku\", \"ulm.geojson\": \"Ulm\", \"united-kingdom.geojson\": \"United Kingdom\", \"united-kingdom-regions.geojson\": \"United Kingdom Regions\", \"united-states-1810.geojson\": \"United States 1810\", \"united-states-big-cities.geojson\": \"United States Big Cities\", \"united-states.geojson\": \"United States\", \"united-states-international-airports.geojson\": \"United States International Airports\", \"united-states-mlb-stadiums.geojson\": \"United States Mlb Stadiums\", \"unna.geojson\": \"Unna\", \"utrecht.geojson\": \"Utrecht\", \"vancouver.geojson\": \"Vancouver\", \"venice.geojson\": \"Venice\", \"venlo.geojson\": \"Venlo\", \"vermont-counties.geojson\": \"Vermont Counties\", \"vienna.geojson\": \"Vienna\", \"villetta.geojson\": \"Villetta\", \"washington.geojson\": \"Washington\", \"wellington.geojson\": \"Wellington\", \"west-linn.geojson\": \"West Linn\", \"west-palm-beach.geojson\": \"West Palm Beach\", \"wiesenburg.geojson\": \"Wiesenburg\", \"williamsburg.geojson\": \"Williamsburg\", \"windsor.geojson\": \"Windsor\", \"winterthur.geojson\": \"Winterthur\", \"zurich-city.geojson\": \"Zurich City\", \"zurich.geojson\": \"Zurich\", \"world.geojson\": \"World\"}\n", "type": "text"}, {"name": "requirements.txt", "content": "folium", "type": "text"}, {"name": "shared.py", "content": "#\n# Heatmapper\n# Shared\n#\n# This file contains shared functionality between Heatmapper applications. It is not a standalone application.\n# Due to the way ShinyLive exports applications, this file is symlinked into each project to reduce redundancy.\n#\n\nfrom shiny import ui\nfrom shiny.types import FileInfo\nfrom pandas import DataFrame, read_csv, read_excel, read_table\nfrom io import BytesIO\nfrom tempfile import NamedTemporaryFile\nfrom sys import modules\nfrom pathlib import Path\nfrom enum import Enum\nfrom os.path import exists\nfrom copy import deepcopy\n\n# Used for fetching web resources in a variety of fashions.\nURL = \"https://wishartlab.github.io/heatmapper2\"\nRaw = \"https://raw.githubusercontent.com/WishartLab/heatmapper2/main\"\n\n# Define the Server and Port of the Shiny instances (Port is incremented)\n# Change these if Heatmapper is running on a server.\nServer = \"http://35.208.86.138\"\nPort = 8000\n\n# Detect the running environment\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tPyodide = True\nelse:\n\tPyodide = False\n\n# MatPlotLib Colors\nColors = [\"Blue\", \"Orange\", \"Green\", \"Red\", \"Purple\", \"Brown\", \"Pink\", \"Gray\", \"Olive\", \"Cyan\", \"White\", \"Yellow\"]\n\nclass ColumnType(Enum): Time = 0; Name = 1; Value = 2; Longitude = 3; Latitude = 4; X = 5; Y = 6; Z = 7; Cluster = 8; Free = 9; Spatial = 10;\nColumns = {\n\tColumnType.Time: {\"time\", \"date\", \"year\"},\n\tColumnType.Name: {\"name\", \"orf\", \"uniqid\", \"face\", \"triangle\"},\n\tColumnType.Value: {\"value\", \"weight\", \"intensity\", \"in_tissue\"},\n\tColumnType.Longitude: {\"longitude\", \"long\"},\n\tColumnType.Latitude: {\"latitude\", \"lat\"},\n\tColumnType.X: {\"x\"},\n\tColumnType.Y: {\"y\"},\n\tColumnType.Z: {\"z\"},\n\tColumnType.Cluster: {\"cell type\", \"celltype_mapped_refined\", \"cluster\", \"cell_class\", \"cell_subclass\", \"cell_cluster\"},\n\tColumnType.Free: {None},\n\tColumnType.Spatial: {\"spatial\"}\n}\n\n\ndef Filter(columns, ctype: ColumnType, good: list = [], bad: list = [], only_one=False, ui_element=None, reject_unknown=False):\n\t\"\"\"\n\t@brief Filters available column names based on what input we want\n\t@param columns: The columns of the DataFrame (Usually just df.columns)\n\t@param ctype: The type of column we're looking for (Look at the ColumnType Enum)\n\t@param good: A list of column names on top of those defined by the type to be included\n\t@param bad: A list of column names on top of those defined by the type to be excluded from the result.\n\t@param only_one: Only return a single result, so the variable can be used immediately.\n\t@param ui_element: An optional Shiny selection input to update.\n\t@param reject_unknown: Only include columns explicitly defined\n\t@return: A list of column names to use.\n\t\"\"\"\n\n\t# Fold cases\n\tfolded = [column.lower() for column in columns]\n\n\t# Add and remove what user asked for, filtering None\n\toptions = set(folded)\n\tif bad: options -= set([b.lower() for b in bad if b])\n\tif good: options &= set([g.lower() for g in good if g])\n\n\t# Take an intersection of our columns and the type we want. If there is a match, return those\n\t# Otherwise, remove all columns we know it shouldn't be, and return that instead.\n\tintersection = options & Columns[ctype]\n\tif intersection or reject_unknown: options = intersection\n\telse:\n\t\tfor key, value in Columns.items():\n\t\t\tif key != ctype: options -= value\n\n\t# Get the valid indices, and sort them in ascending order\n\tindices = [folded.index(value) for value in options]\n\tindices.sort()\n\n\t# Get the original column names, without case-folding, and return as a list.\n\treassembled = [columns[index] for index in indices]\n\tif not reassembled: return None\n\n\t# Update a UI element, if one was provided\n\tif ui_element is not None: ui.update_select(id=ui_element, choices=reassembled, selected=reassembled[0])\n\treturn reassembled[0] if only_one else reassembled\n\n\nclass Cache:\n\t\"\"\"\n\t@brief A class that encompasses fetching/storing web resources.\n\t\"\"\"\n\n\t@staticmethod\n\tdef HandleDataFrame(path, function):\n\t\t\"\"\"\n\t\t@brief Handle DataFrame's\n\t\t@param i: The binary of the file\n\t\t@param function: The pandas function to use to read the file.\n\t\t@returns A DataFrame\n\t\t\"\"\"\n\n\t\t# Read the table once.\n\t\tdf = function(path.resolve()).fillna(0)\n\n\t\t# If the first column value is a float, we assume it's data, and not column names.\n\t\t# Re-read the DataFrame with generic column names instead\n\t\ttry:\n\t\t\tfloat(df.columns[0])\n\t\t\tdf = function(path.resolve(), header=None, names=[f\"Column {i}\" for i in range(df.shape[1])])\n\t\texcept ValueError: pass\n\t\treturn df\n\n\n\t@staticmethod\n\tdef DefaultHandler(path):\n\t\t\"\"\"\n\t\t@brief The default handler. It can handle csv, xlsx, and defaults all other files to read_table\n\t\t@param n: The path to the file\n\t\t@returns: An object, if the provided file is supported, None otherwise.\n\t\t\"\"\"\n\n\t\tsuffix = path.suffix\n\t\tif suffix == \".csv\": return Cache.HandleDataFrame(path, read_csv)\n\t\telif suffix == \".xlsx\" or suffix == \".xls\" or suffix == \".odf\": return Cache.HandleDataFrame(path, read_excel)\n\t\telse: return Cache.HandleDataFrame(path, read_table)\n\n\n\tasync def _remote(self, url):\n\t\t\tr = await pyfetch(url);\n\t\t\tif not r.ok: return None\n\t\t\treturn await r.bytes()\n\n\n\tasync def _local(self, url):\n\t\tif not exists(url): return None\n\t\treturn Path(url)\n\n\n\tdef __init__(self, project, DataHandler = DefaultHandler):\n\t\t\"\"\"\n\t\t@brief Initialize an instance of the Cache object.\n\t\t@param project: The name of the project. This is used to fetch web resources.\n\t\t@param DataHandler:\tThe function that should be called to process files. It should\n\t\t\t\t\t\t\t\t\t\t\t\ttake a name, and a binary stream, and return a DataFrame.\n\t\t\"\"\"\n\n\t\t# The primary is the unprocessed, fetched web resources\n\t\tself._primary = {}\n\n\t\t# The objects are anything that applications want to store\n\t\tself._objects = {}\n\n\t\t# The data handler for processing the binary files.\n\t\tself._handler = DataHandler\n\n\t\t# If we're in a Pyodide environment, we fetch resources from the web.\n\t\tif Pyodide:\n\t\t\tself._download = lambda url: self._remote(url)\n\t\t\tself._source = f\"{Raw}/{project}/example_input/\"\n\n\t\t# Otherwise, we fetch locally.\n\t\telse:\n\t\t\tself._download = lambda url: self._local(url)\n\t\t\tself._source = \"../example_input/\"\n\n\n\tasync def Load(self, input, source_file=None, example_file=None, source=None, input_switch=None, default=DataFrame()):\n\t\t\"\"\"\n\t\t@brief Caches whatever the user has currently uploaded/selection, returning the identifier within the secondary cache.\n\t\t@param input: The Shiny input variable. Importantly, these must be defined:\n\t\t\tinput.File: The uploaded file\n\t\t\tinput.Example: The selected example file\n\t\t\tinput.SourceFile: Whether the user wants \"Upload\" or \"Example\"\n\t\t@param source_file: The input ID that should be used to fetch the file (Defaults to input.File() if None)\n\t\t@param example_file: The input ID that should be used to fetch th example (Defaults to input.Example() if None)\n\t\t@param input_switch:\tThe input ID to check for Upload/Example/Other. The value is compared against \"Upload\" for user\n\t\t\t\t\t\t\t\t\t\t\t\t\tuploaded items, and defaults to fetching example_file otherwise. (Defaults to input.SourceFile())\n\t\t@param default:\tThe object that should be returned if files cannot be fetched. Ensures that Load will always return an\n\t\t\t\t\t\t\t\t\t\tobject, avoiding the needing to check output. Defaults to a DataFrame. The object should be able to\n\t\t\t\t\t\t\t\t\t\tinitialize without arguments.\n\t\t@param return_n: Return the filename for post-processing.\n\t\t\"\"\"\n\n\t\tif source_file is None: source_file = input.File()\n\t\tif example_file is None: example_file = input.Example()\n\t\tif source is None: source = self._source\n\t\tif input_switch is None: input_switch = input.SourceFile()\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input_switch == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = source_file\n\t\t\tif file is None: return default\n\n\t\t\t# The datapath can be immediately used to load examples, but we explicitly need to use\n\t\t\t# Local as a user uploaded file will always be fetched on disk.\n\t\t\tn = str(file[0][\"datapath\"])\n\t\t\tpath = Path(n)\n\n\t\t# Example files, conversely, can be on disk or on a server depending on whether we're in a WASM environment.\n\t\telse:\n\t\t\tn = str(source + example_file)\n\t\t\traw = await self._download(n)\n\n\t\t\t# WASM needs a temporary file, but they are deleted out of their scope.\n\t\t\tif Pyodide:\n\t\t\t\ttemp = NamedTemporaryFile(suffix=Path(n).suffix); \n\t\t\t\ttemp.write(BytesIO(raw).read()); temp.seek(0)\n\t\t\t\tif n not in self._primary: self._primary[n] = self._handler(Path(temp.name))\n\t\t\telif n not in self._primary: self._primary[n] = self._handler(raw)\n\n\t\treturn deepcopy(self._primary[n])\n\n\n\tdef Store(self, object, inputs):\n\t\t\"\"\"\n\t\t@brief Store arbitrary data in the Cache.\n\t\t@param object: The object to store\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\th = \"\".join(str(i) for i in inputs)\n\t\tself._objects[h] = object\n\n\n\tdef Get(self, inputs):\n\t\t\"\"\"\n\t\t@brief Retrieve arbitrary data in the Cache.\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\th = \"\".join(str(i) for i in inputs)\n\t\tif h in self._objects:\n\t\t\t\treturn self._objects[h]\n\t\telse: return None\n\n\ndef NavBar():\n\t\"\"\"\n\t@brief Returns a Navigation Bar for each project, with the current project selected.\n\t@returns A list, containing a ui.panel_title, and a ui.navset_bar.\n\t\"\"\"\n\n\tSources = {\n\t\t\"expression\": f\"{URL}/expression/site/index.html\" if Pyodide else f\"{Server}:{Port}\",\n\t\t\"pairwise\": f\"{URL}/pairwise/site/index.html\" if Pyodide else f\"{Server}:{Port + 1}\",\n\t\t\"image\": f\"{URL}/image/site/index.html\" if Pyodide else f\"{Server}:{Port + 2}\",\n\t\t\"geomap\": f\"{URL}/geomap/site/index.html\" if Pyodide else f\"{Server}:{Port + 3}\",\n\t\t\"geocoordinate\": f\"{URL}/geocoordinate/site/index.html\" if Pyodide else f\"{Server}:{Port + 4}\",\n\t\t\"3d\": f\"{Server}:{Port + 5}\",\n\t\t\"spatial\": f\"{Server}:{Port + 6}\",\n\t}\n\n\treturn (\n\t\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\t\tui.navset_bar(\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"expression\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Expression</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"pairwise\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Pairwise</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"image\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Image</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geomap\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geomap</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geocoordinate\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geocoordinate</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"3d\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">3D</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"spatial\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Spatial</a>')),\n\t\t\tui.nav_control(ui.HTML('<a href=https://github.com/WishartLab/heatmapper2/wiki target=\"_blank\" rel=\"noopener noreferrer\">About</a>')),\n\t\t\tui.nav_spacer(),\n\t\t\tui.nav_control(ui.input_dark_mode(id=\"mode\")),\n\t\t\ttitle=\"Heatmapper\",\n\t\t),\n\t)\n\n\ndef FileSelection(examples, types, upload_label=\"Choose a File\", multiple=False, default=\"Example\", project=\"Overview\"):\n\t\"\"\"\n\t@brief Returns the file selection dialog for the user to upload/select an example\n\t@param examples: Either a list of example file names, or a dictionary mapping\n\t@param types: The valid file extensions for user uploaded files.\n\t@param upload_label: The label for the upload input. Useful to define specifically what kind of files are needed\n\t@param multiple: Whether to accept multiple files. \n\t@param default: Whether to start on the example, or upload dialog\n\t@param project: The name of a project, to specify a specified header within the Interface documentation\n\t@returns A list, containing the necessary ui components for uploading/selecting\n\t@info The returns elements are named:\n\t\tinput.SourceFile: The ui.input_radio_buttons for whether the user wants to choose an \"Example\" or \"Upload\"\n\t\tinput.File: The ui.input_file for user uploaded files.\n\t\tinput.Example: The ui.input_select for an example file selection\n\t@info multiple=True is not handled properly by the Cache. You will need to create a function that properly handles\n\t\teach file (See spatial for an implementation)\n\t@info If you're examples are large files, or require significant computation, you may want to switch it to Upload instead.\n\t\"\"\"\n\n\t# If the user needs help with the formatting.\n\treturn [\n\tui.layout_columns(\n\t\tui.HTML(\"<a href=https://github.com/WishartLab/heatmapper2/wiki/Format target='_blank' rel='noopener noreferrer'>Format</a>\"),\n\t\tui.HTML(f\"<a href='https://github.com/WishartLab/heatmapper2/wiki/Interface#{project}' target='_blank' rel='noopener noreferrer'>Help</a>\"),\n\t\tcol_widths=[6,6]\n\t),\n\n\t# Specify whether to use example files, or upload one.\n\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"], selected=default, inline=True),\n\n\t# Only display an input dialog if the user is one Upload\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Upload'\",\n\t\tui.input_file(\"File\", upload_label, accept=types, multiple=multiple),\n\t),\n\n\t# Otherwise, add the example selection and an info button.\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Example'\",\n\t\tui.layout_columns(\n\t\t\tui.input_select(id=\"Example\", label=None, choices=examples, multiple=False),\n\t\t\tui.popover(ui.input_action_link(id=\"ExampleInfoButton\", label=\"Info\"), ui.output_text(\"ExampleInfo\")),\n\t\t\tcol_widths=[7,3],\n\t\t)\n\t),\n\t]\n\n\ndef TableOptions():\n\t\"\"\"\n\t@brief Return the options for Table Manipulation.\n\t@returns A conditional panel that provides a DataType, and a ResetButton.\n\t\"\"\"\n\treturn  ui.panel_conditional(\n\t\t\"input.MainTab === 'TableTab'\",\n\t\tui.input_radio_buttons(id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"], inline=True),\n\t\tui.input_action_button(id=\"Reset\", label=\"Reset Values\"),\n\t),\n\n\ndef ColorMap():\n\t\"\"\"\n\t@brief Returns a ColorMap input Selection\n\t@returns\tA list of UI elements. Firstly, a header that contained a toggle for custom ColorMaps.\n\t\t\t\t\t\tThen, two conditional panels based on the status of the toggle. If the user wants\n\t\t\t\t\t\tcustom color maps, then provide a selectize.js selection box that allows for multiple\n\t\t\t\t\t\tselections. These options are used to define the gradient, low to high. If not, just a\n\t\t\t\t\t\tcollection of predefined maps, where the keys must be split on spaces to generate a map\n\t\t\t\t\t\tthat MatPlotLib can use.\n\t\"\"\"\n\treturn [\n\t\tui.layout_columns(\"Color Map\", ui.input_checkbox(id=\"Custom\", label=\"Custom\")),\n\t\tui.panel_conditional(\n\t\t\t\"input.Custom\",\n\t\t\t\tui.input_select(\n\t\t\t\tid=\"CustomColors\",\n\t\t\t\tlabel=None,\n\t\t\t\tchoices=Colors,\n\t\t\t\tselected=[\"Blue\", \"White\", \"Yellow\"],\n\t\t\t\tmultiple=True,\n\t\t\t\tselectize=True,\n\t\t\t),\n\t\t),\n\t\tui.panel_conditional(\n\t\t\t\"!input.Custom\",\n\t\t\tui.input_select(id=\"ColorMap\", label=None, choices={\n\t\t\t\t\t\"Blue White Yellow\": \"Blue/Yellow\",\n\t\t\t\t\t\"Red Black Green\": \"Red/Green\",\n\t\t\t\t\t\"Pink White Green\": \"Pink/Green\",\n\t\t\t\t\t\"Blue Green Yellow\": \"Blue/Green/Yellow\",\n\t\t\t\t\t\"Black Gray White\": \"Grayscale\",\n\t\t\t\t\t\"Red Orange Yellow Green Blue Indigo Violet\": \"Rainbow\",\n\t\t\t\t}\n\t\t\t),\n\t\t)]\n\n\ndef MainTab(*args, m_type=ui.output_plot):\n\treturn ui.navset_tab(\n\t\tui.nav_panel(\"Heatmap\", m_type(id=\"Heatmap\", height=\"90vh\"), value=\"HeatmapTab\"),\n\t\tui.nav_panel(\"Table\", ui.output_data_frame(id=\"Table\"), value=\"TableTab\"),\n\t\t*args,\n\t\tid=\"MainTab\"\n\t)\n", "type": "text"}]