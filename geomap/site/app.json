[{"name": "app.py", "content": "#\n# Heatmapper\n# Geomap\n#\n# This file contains the ShinyLive application for Geomap Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshinylive export . [site]\n# Where [site] is the destination of the site folder.\n#\n# If you would rather deploy the application as a PyShiny application,\n# run the following command within this directory:\n#\t\tshiny run\n#\n#\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom folium import Map as FoliumMap, Choropleth\nfrom folium.plugins import TimeSliderChoropleth\nfrom pandas import DataFrame, to_datetime\nfrom branca.colormap import linear\nfrom json import loads\nfrom shapely.geometry import shape\n\nfrom shared import Cache, NavBar, MainTab, FileSelection, Pyodide, Filter, ColumnType, FillColumnSelection, TableValueUpdate\n\n# Fine, Shiny\nimport branca, certifi, xyzservices\n\n\n# Generated from dictionary.sh\nMappings = { \"africa.geojson\": \"Africa\", \"akron.geojson\": \"Akron\", \"alameda.geojson\": \"Alameda\", \"albany.geojson\": \"Albany\", \"albuquerque.geojson\": \"Albuquerque\", \"amsterdam.geojson\": \"Amsterdam\", \"amusement-parks.geojson\": \"Amusement Parks\", \"anchorage.geojson\": \"Anchorage\", \"angers.geojson\": \"Angers\", \"angers-loire-metropole.geojson\": \"Angers Loire Metropole\", \"antwerp.geojson\": \"Antwerp\", \"apulia.geojson\": \"Apulia\", \"arlingtonva.geojson\": \"Arlingtonva\", \"asia.geojson\": \"Asia\", \"athens.geojson\": \"Athens\", \"atlanta.geojson\": \"Atlanta\", \"augsburg.geojson\": \"Augsburg\", \"austin.geojson\": \"Austin\", \"australia.geojson\": \"Australia\", \"austria-oberoesterreich.geojson\": \"Austria Oberoesterreich\", \"austria-states.geojson\": \"Austria States\", \"austria-steiermark.geojson\": \"Austria Steiermark\", \"bad-belzig.geojson\": \"Bad Belzig\", \"badenwuerttemberg-kreise.geojson\": \"Badenwuerttemberg Kreise\", \"baltimore.geojson\": \"Baltimore\", \"bari.geojson\": \"Bari\", \"basel.geojson\": \"Basel\", \"bayern.geojson\": \"Bayern\", \"belgium-arrondissements.geojson\": \"Belgium Arrondissements\", \"berlin.geojson\": \"Berlin\", \"bern-districts.geojson\": \"Bern Districts\", \"bern-quarters.geojson\": \"Bern Quarters\", \"birmingham.geojson\": \"Birmingham\", \"blacksburg.geojson\": \"Blacksburg\", \"blumenau.geojson\": \"Blumenau\", \"bogota.geojson\": \"Bogota\", \"boston.geojson\": \"Boston\", \"brandenburg.geojson\": \"Brandenburg\", \"brandenburg-municipalities.geojson\": \"Brandenburg Municipalities\", \"braunschweig.geojson\": \"Braunschweig\", \"brazil-states.geojson\": \"Brazil States\", \"bremen.geojson\": \"Bremen\", \"bronx.geojson\": \"Bronx\", \"brooklyn.geojson\": \"Brooklyn\", \"buenos-aires.geojson\": \"Buenos Aires\", \"calgary.geojson\": \"Calgary\", \"california-counties.geojson\": \"California Counties\", \"california-vista-points.geojson\": \"California Vista Points\", \"caltrain-stations.geojson\": \"Caltrain Stations\", \"canada.geojson\": \"Canada\", \"canberra.geojson\": \"Canberra\", \"caribbean-islands.geojson\": \"Caribbean Islands\", \"chapel-hill.geojson\": \"Chapel Hill\", \"charlotte.geojson\": \"Charlotte\", \"charlottesville.geojson\": \"Charlottesville\", \"chemnitz.geojson\": \"Chemnitz\", \"chesapeake.geojson\": \"Chesapeake\", \"chicago.geojson\": \"Chicago\", \"china.geojson\": \"China\", \"cincinnati.geojson\": \"Cincinnati\", \"cleveland.geojson\": \"Cleveland\", \"cologne.geojson\": \"Cologne\", \"colorado-counties.geojson\": \"Colorado Counties\", \"columbus.geojson\": \"Columbus\", \"copenhagen.geojson\": \"Copenhagen\", \"cuba.geojson\": \"Cuba\", \"dallas.geojson\": \"Dallas\", \"dane-county-municipalities.geojson\": \"Dane County Municipalities\", \"denmark-municipalities.geojson\": \"Denmark Municipalities\", \"denver.geojson\": \"Denver\", \"des-moines.geojson\": \"Des Moines\", \"detroit.geojson\": \"Detroit\", \"dresden.geojson\": \"Dresden\", \"dublin.geojson\": \"Dublin\", \"duesseldorf.geojson\": \"Duesseldorf\", \"durham.geojson\": \"Durham\", \"edmonton.geojson\": \"Edmonton\", \"eindhoven.geojson\": \"Eindhoven\", \"enschede.geojson\": \"Enschede\", \"esztergom.geojson\": \"Esztergom\", \"europe-1914.geojson\": \"Europe 1914\", \"europe-1938.geojson\": \"Europe 1938\", \"europe-capitals.geojson\": \"Europe Capitals\", \"europe.geojson\": \"Europe\", \"fairbanks.geojson\": \"Fairbanks\", \"fargo.geojson\": \"Fargo\", \"fort-lauderdale.geojson\": \"Fort Lauderdale\", \"france-departments.geojson\": \"France Departments\", \"france-regions.geojson\": \"France Regions\", \"frankfurt-main.geojson\": \"Frankfurt Main\", \"freiburg.geojson\": \"Freiburg\", \"geneva.geojson\": \"Geneva\", \"germany-capitals.geojson\": \"Germany Capitals\", \"germany.geojson\": \"Germany\", \"ghent.geojson\": \"Ghent\", \"gisborne.geojson\": \"Gisborne\", \"grand-rapids.geojson\": \"Grand Rapids\", \"greece-prefectures.geojson\": \"Greece Prefectures\", \"greece-regions.geojson\": \"Greece Regions\", \"hamburg.geojson\": \"Hamburg\", \"hampton.geojson\": \"Hampton\", \"hartford.geojson\": \"Hartford\", \"henderson.geojson\": \"Henderson\", \"honolulu.geojson\": \"Honolulu\", \"houston.geojson\": \"Houston\", \"hungary.geojson\": \"Hungary\", \"illinois-counties.geojson\": \"Illinois Counties\", \"india.geojson\": \"India\", \"indianapolis.geojson\": \"Indianapolis\", \"iran-provinces.geojson\": \"Iran Provinces\", \"ireland-counties.geojson\": \"Ireland Counties\", \"isle-of-man.geojson\": \"Isle Of Man\", \"italy-provinces.geojson\": \"Italy Provinces\", \"italy-regions.geojson\": \"Italy Regions\", \"james-city-county.geojson\": \"James City County\", \"japan.geojson\": \"Japan\", \"kaiserslautern.geojson\": \"Kaiserslautern\", \"kansas-city.geojson\": \"Kansas City\", \"korea.geojson\": \"Korea\", \"las-vegas.geojson\": \"Las Vegas\", \"leipzig.geojson\": \"Leipzig\", \"le-mans-cantons.geojson\": \"Le Mans Cantons\", \"lexington.geojson\": \"Lexington\", \"liberia-central.geojson\": \"Liberia Central\", \"liberia-east.geojson\": \"Liberia East\", \"liberia.geojson\": \"Liberia\", \"liberia-west.geojson\": \"Liberia West\", \"lombardy.geojson\": \"Lombardy\", \"london.geojson\": \"London\", \"london-underground.geojson\": \"London Underground\", \"long-beach.geojson\": \"Long Beach\", \"los-angeles-county.geojson\": \"Los Angeles County\", \"los-angeles.geojson\": \"Los Angeles\", \"louisville.geojson\": \"Louisville\", \"luxembourg-cantons.geojson\": \"Luxembourg Cantons\", \"luxembourg-communes.geojson\": \"Luxembourg Communes\", \"luzern.geojson\": \"Luzern\", \"macon.geojson\": \"Macon\", \"madrid-districts.geojson\": \"Madrid Districts\", \"madrid.geojson\": \"Madrid\", \"malaysia.geojson\": \"Malaysia\", \"manhattan-bridges.geojson\": \"Manhattan Bridges\", \"manhattan.geojson\": \"Manhattan\", \"melbourne.geojson\": \"Melbourne\", \"mexico.geojson\": \"Mexico\", \"miami.geojson\": \"Miami\", \"middle_east_countries.geojson\": \"Middle_east_countries\", \"milan.geojson\": \"Milan\", \"milwaukee.geojson\": \"Milwaukee\", \"minneapolis-cities.geojson\": \"Minneapolis Cities\", \"minneapolis.geojson\": \"Minneapolis\", \"mississauga.geojson\": \"Mississauga\", \"montreal.geojson\": \"Montreal\", \"moscow.geojson\": \"Moscow\", \"muenster.geojson\": \"Muenster\", \"new-haven.geojson\": \"New Haven\", \"new-orleans.geojson\": \"New Orleans\", \"new-york-areas-of-interest.geojson\": \"New York Areas Of Interest\", \"new-york-city-boroughs.geojson\": \"New York City Boroughs\", \"new-york-counties.geojson\": \"New York Counties\", \"nordrhein-westfalen.geojson\": \"Nordrhein Westfalen\", \"norfolk.geojson\": \"Norfolk\", \"north-america.geojson\": \"North America\", \"north-carolina-cities.geojson\": \"North Carolina Cities\", \"oakland.geojson\": \"Oakland\", \"oceania.geojson\": \"Oceania\", \"oklahoma-cities.geojson\": \"Oklahoma Cities\", \"oklahoma-counties.geojson\": \"Oklahoma Counties\", \"olympia.geojson\": \"Olympia\", \"oman.geojson\": \"Oman\", \"oman-provinces.geojson\": \"Oman Provinces\", \"orlando.geojson\": \"Orlando\", \"pakistan.geojson\": \"Pakistan\", \"paris.geojson\": \"Paris\", \"peaks.geojson\": \"Peaks\", \"philadelphia.geojson\": \"Philadelphia\", \"phoenix.geojson\": \"Phoenix\", \"pittsburgh.geojson\": \"Pittsburgh\", \"poland.geojson\": \"Poland\", \"poland-parks.geojson\": \"Poland Parks\", \"porirua.geojson\": \"Porirua\", \"portland.geojson\": \"Portland\", \"portugal.geojson\": \"Portugal\", \"potsdam.geojson\": \"Potsdam\", \"prague.geojson\": \"Prague\", \"providence.geojson\": \"Providence\", \"quebec.geojson\": \"Quebec\", \"queens.geojson\": \"Queens\", \"raleigh.geojson\": \"Raleigh\", \"red-deer.geojson\": \"Red Deer\", \"richmond.geojson\": \"Richmond\", \"riga.geojson\": \"Riga\", \"rio-de-janeiro.geojson\": \"Rio De Janeiro\", \"rochester.geojson\": \"Rochester\", \"rockville.geojson\": \"Rockville\", \"roller-coasters-fastest-steel.geojson\": \"Roller Coasters Fastest Steel\", \"romania.geojson\": \"Romania\", \"rome-rioni.geojson\": \"Rome Rioni\", \"rotterdam.geojson\": \"Rotterdam\", \"russia.geojson\": \"Russia\", \"sacramento.geojson\": \"Sacramento\", \"salt-lake-city.geojson\": \"Salt Lake City\", \"san-antonio.geojson\": \"San Antonio\", \"san-diego.geojson\": \"San Diego\", \"san-francisco.geojson\": \"San Francisco\", \"san-jose.geojson\": \"San Jose\", \"saskatoon.geojson\": \"Saskatoon\", \"savannah.geojson\": \"Savannah\", \"seattle.geojson\": \"Seattle\", \"seoul.geojson\": \"Seoul\", \"serbia.geojson\": \"Serbia\", \"silicon-valley.geojson\": \"Silicon Valley\", \"south-africa.geojson\": \"South Africa\", \"south-america.geojson\": \"South America\", \"southeast-asia.geojson\": \"Southeast Asia\", \"spain-communities.geojson\": \"Spain Communities\", \"spain-provinces.geojson\": \"Spain Provinces\", \"springfield.geojson\": \"Springfield\", \"stamford.geojson\": \"Stamford\", \"staten-island.geojson\": \"Staten Island\", \"st-louis.geojson\": \"St Louis\", \"st-petersburg.geojson\": \"St Petersburg\", \"surrey.geojson\": \"Surrey\", \"sweden-counties.geojson\": \"Sweden Counties\", \"switzerland.geojson\": \"Switzerland\", \"sydney.geojson\": \"Sydney\", \"szczecin.geojson\": \"Szczecin\", \"taiwan.geojson\": \"Taiwan\", \"tampa.geojson\": \"Tampa\", \"the-hague.geojson\": \"The Hague\", \"the-netherlands.geojson\": \"The Netherlands\", \"thessaloniki.geojson\": \"Thessaloniki\", \"toronto.geojson\": \"Toronto\", \"tucson.geojson\": \"Tucson\", \"turkey.geojson\": \"Turkey\", \"turku.geojson\": \"Turku\", \"ulm.geojson\": \"Ulm\", \"united-kingdom.geojson\": \"United Kingdom\", \"united-kingdom-regions.geojson\": \"United Kingdom Regions\", \"united-states-1810.geojson\": \"United States 1810\", \"united-states-big-cities.geojson\": \"United States Big Cities\", \"united-states.geojson\": \"United States\", \"united-states-international-airports.geojson\": \"United States International Airports\", \"united-states-mlb-stadiums.geojson\": \"United States Mlb Stadiums\", \"unna.geojson\": \"Unna\", \"utrecht.geojson\": \"Utrecht\", \"vancouver.geojson\": \"Vancouver\", \"venice.geojson\": \"Venice\", \"venlo.geojson\": \"Venlo\", \"vermont-counties.geojson\": \"Vermont Counties\", \"vienna.geojson\": \"Vienna\", \"villetta.geojson\": \"Villetta\", \"washington.geojson\": \"Washington\", \"wellington.geojson\": \"Wellington\", \"west-linn.geojson\": \"West Linn\", \"west-palm-beach.geojson\": \"West Palm Beach\", \"wiesenburg.geojson\": \"Wiesenburg\", \"williamsburg.geojson\": \"Williamsburg\", \"windsor.geojson\": \"Windsor\", \"winterthur.geojson\": \"Winterthur\", \"zurich-city.geojson\": \"Zurich City\", \"zurich.geojson\": \"Zurich\", \"world.geojson\": \"World\"}\n\ndef server(input: Inputs, output: Outputs, session: Session):\n\n\n\n\tInfo = {\n\t\t\"example1.txt\": \"This example file is from the Open Data Portal. The data is from a carbon monoxide emissions study conducted by Environment Canada. The three columns represent results from 1990, 2000, and 2013.\",\n\t\t\"example2.txt\": \"This example file is from Statistics Canada. The data is adapted from New cases and age-standardized rate for primary cancer (based on the February 2014 CCR tabulation file), by cancer type and sex, Canada, provinces and territories. The columns represent new cancer cases (age-standardized rate per 100,000 population) from 2006 to 2010.\",\n\t\t\"example3.txt\": \"This example file is from the U.S. Centers for Disease Control and Prevention. The data is from Diagnosed Diabetes, Age Adjusted Rate (per 100), Adults - Total, 2013.\",\n\t\t\"example6.csv\": \"COVID 19 information reported by the Canadian Government, available at https://open.canada.ca/data/en/dataset/261c32ab-4cfd-4f81-9dea-7b64065690dc/resource/39434379-45a1-43d5-aea7-a7a50113c291\"\n\t}\n\n\tDataCache = Cache(\"geomap\")\n\n\n\tdef LoadJSON():\n\t\t\"\"\"\n\t\t@brief Returns the GeoJSON depending on whether the user wants to use a provided one, or their own.\n\t\t@returns Either the path to the uploaded file, or the URL to the one provided by us (Folium supports both)\n\t\t\"\"\"\n\n\t\tURL = \"https://raw.githubusercontent.com/WishartLab/heatmapper2/main/geomap/data/\" if Pyodide else \"../data/\"\n\n\t\tif input.JSONFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.JSONUpload()\n\t\t\tif file is None:\n\t\t\t\treturn URL + \"canada.geojson\"\n\t\t\treturn file[0][\"datapath\"]\n\t\telse:\n\t\t\treturn URL + input.JSONSelection()\n\n\n\tdef LoadChoropleth(df, map, k_col, v_col):\n\n\t\t# Add the heatmap and return.\n\t\tChoropleth(\n\t\t\t\tgeo_data=LoadJSON(),\n\t\t\t\tname=\"choropleth\",\n\t\t\t\tdata=df,\n\t\t\t\tcolumns=[k_col, v_col],\n\t\t\t\tkey_on=\"feature.properties.name\",\n\t\t\t\tfill_color=input.ColorMap().lower(),\n\t\t\t\tfill_opacity=input.Opacity(),\n\t\t\t\tline_opacity=input.Opacity(),\n\t\t\t\tlegend_name=\"Legend\",\n\t\t\t\tbins=input.Bins()\n\t\t).add_to(map)\n\n\n\tasync def LoadTemporalChoropleth(df, map, k_col, v_col):\n\t\tgeojson = await DataCache.Download(LoadJSON())\n\t\tgeojson = loads(geojson.decode('utf-8'))\n\n\t\t# Check if we have a dedicated time column, or separate columns for each time slot.\n\t\tcolumn = Filter(df.columns, ColumnType.Time, bad = [k_col, v_col], only_one=True)\n\t\tvalues = v_col if column else df.columns[1:]\n\n\t\tmatch input.ColorMap():\n\t\t\tcase \"Inferno\": cmap = linear.inferno.scale\n\t\t\tcase \"Magma\": cmap = linear.magma.scale\n\t\t\tcase \"Plasma\": cmap = linear.plasma.scale\n\t\t\tcase \"Viridis\": cmap = linear.viridis.scale\n\t\tm, M = df[values].values.min(), df[values].values.max()\n\t\tcolormap = cmap(m, M)\n\n\t\tstyle = {}\n\n\t\tif column:\n\t\t\tgrouped = df.groupby(k_col)\n\n\t\t\tfor i, (name, group) in enumerate(grouped):\n\t\t\t\tstyle[i] = {}\n\t\t\t\tfor a, row in group.iterrows():\n\n\t\t\t\t\t# If the year isn't parsable, pray that it just works without parsing :)\n\t\t\t\t\ttry: year = str(to_datetime(row[column].split()[0]).timestamp()).split('.')[0]\n\t\t\t\t\texcept Exception: year = row[column]\n\n\t\t\t\t\tstyle[i][year] = {'color': colormap(row[v_col]), 'opacity': input.Opacity()}\n\t\t\t\tfor feature in geojson[\"features\"]:\n\t\t\t\t\t\t\tif feature[\"properties\"][\"name\"] == name:\n\t\t\t\t\t\t\t\t\tfeature[\"id\"] = i\n\n\t\telse:\n\t\t\t# Convert DataFrame to style format\n\t\t\tfor i, row in df.iterrows():\n\t\t\t\t\tname = row[k_col]\n\t\t\t\t\tstyle[i] = {}\n\t\t\t\t\tfor year in df.columns[1:]:\n\t\t\t\t\t\tvalue = row[year]\n\n\t\t\t\t\t\t# If the year isn't parsable, pray that it just works without parsing :)\n\t\t\t\t\t\ttry: year = str(to_datetime(year.split()[0]).timestamp()).split('.')[0]\n\t\t\t\t\t\texcept Exception: pass\n\n\t\t\t\t\t\tstyle[i][year] = {'color': colormap(value), 'opacity': input.Opacity()}\n\t\t\t\t\tfor feature in geojson[\"features\"]:\n\t\t\t\t\t\tif feature[\"properties\"][\"name\"] == name:\n\t\t\t\t\t\t\t\tfeature[\"id\"] = i\n\n\t\tTimeSliderChoropleth(\n\t\t\t\tdata=geojson,\n\t\t\t\tstyledict=style,\n\t\t).add_to(map)\n\t\tcolormap.add_to(map)\n\n\n\tasync def LoadMap():\n\t\t\"\"\"\n\t\t@brief Generates a map with the provided information\n\t\t@returns the Folium.Map\n\t\t\"\"\"\n\n\t\tdf = await DataCache.Load(input, copy=True)\n\t\tk_col, v_col = input.KeyColumn(), input.ValueColumn()\n\n\t\t# If the columns aren't defined, or aren't valid, don't do anything.\n\t\tif k_col not in df or v_col not in df: return\n\n\t\t# Give a placeholder map if nothing is selected, which should never really be the case.\n\t\tif df.empty: return FoliumMap((53.5213, -113.5213), tiles=input.MapType(), zoom_start=15)\n\n\t\t# Create map\n\t\tmap = FoliumMap(tiles=input.MapType())\n\n\t\tif type(input.ROI()) is tuple:\n\t\t\tm, M = df[v_col].min(), df[v_col].max()\n\t\t\tl, u = input.ROI()[0], input.ROI()[1]\n\t\t\tif l >= m and u <= M:\n\t\t\t\toob = []\n\t\t\t\tfor index, row in df.iterrows():\n\t\t\t\t\tv = row[v_col]\n\t\t\t\t\tif v < l or v > u: oob.append(index)\n\t\t\t\tdf = df.drop(oob)\n\n\t\t# Load the choropleth.\n\t\tif input.Temporal(): await LoadTemporalChoropleth(df, map, k_col, v_col)\n\t\telse: LoadChoropleth(df, map, k_col, v_col)\n\n\t\tmap.fit_bounds(map.get_bounds())\n\t\treturn map\n\n\n\t@output\n\t@render.data_frame\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, ignore_none=False, ignore_init=False)\n\tasync def LoadedTable(): return await DataCache.Load(input)\n\n\n\t@output\n\t@render.ui\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, input.KeyColumn, input.ValueColumn, input.JSONSelection, input.JSONUpload, input.Temporal, input.MapType, input.ColorMap, input.Opacity, input.Bins, input.ROI, ignore_none=False, ignore_init=False)\n\tasync def Heatmap(): return await LoadMap()\n\n\t@output\n\t@render.data_frame\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, input.JSONSelection, input.JSONUpload, ignore_none=False, ignore_init=False)\n\tasync def GeoJSON():\n\t\tgeojson = await DataCache.Download(LoadJSON())\n\t\tgeojson = loads(geojson.decode('utf-8'))\n\n\t\tnames = [feature['properties']['name'] for feature in geojson['features']]\n\t\treturn DataFrame({'Name': names})\n\n\n\t@output\n\t@render.text\n\tdef ExampleInfo(): return Info[input.Example()]\n\n\n\t@render.download(filename=\"table.csv\")\n\tasync def DownloadTable(): df = await DataCache.Load(input); yield df.to_string()\n\n\n\t@render.download(filename=\"heatmap.html\")\n\tasync def DownloadHeatmap(): m = await DataCache.Load(input); yield m.get_root().render()\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Example, input.File, input.Reset, input.Update, input.Temporal)\n\tasync def UpdateColumns():\n\t\tdf = await DataCache.Load(input)\n\t\tkey = FillColumnSelection(df.columns, ColumnType.Name, \"KeyColumn\")\n\t\tFillColumnSelection(df.columns, ColumnType.Value, \"ValueColumn\", bad = [key])\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Update)\n\tasync def Update(): await DataCache.Update(input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Reset)\n\tasync def Reset(): await DataCache.Purge(input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.TableRow, input.TableCol, input.Example, input.File, input.Reset, input.Update)\n\tasync def UpdateTableValue(): TableValueUpdate(await DataCache.Load(input), input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, input.ValueColumn,ignore_none=False, ignore_init=False)\n\tasync def UpdateROI():\n\t\tdf = await DataCache.Load(input)\n\t\tv_col = input.ValueColumn()\n\n\t\tif v_col not in df: ui.update_slider(id=\"ROI\", value=0, min=0, max=0)\n\t\telse:\n\t\t\tm, M = int(df[v_col].min()), int(df[v_col].max())\n\t\t\tui.update_slider(id=\"ROI\", value=(m, M), min=m, max=M)\n\n\napp_ui = ui.page_fluid(\n\n\tNavBar(\"Geomap\"),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\n\t\t\tFileSelection(\n\t\t\t\texamples={\"example1.txt\": \"Example 1\", \"example2.txt\": \"Example 2\", \"example3.txt\": \"Example 3\", \"example6.csv\": \"Example 4\"},\n\t\t\t\ttypes=[\".csv\", \".txt\", \".xlsx\"]\n\t\t\t),\n\n\t\t\tui.input_radio_buttons(id=\"JSONFile\", label=\"Specify a GeoJSON File\", choices=[\"Provided\", \"Upload\"], selected=\"Provided\", inline=True),\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.JSONFile === 'Upload'\",\n\t\t\t\tui.input_file(\"JSONUpload\", \"Choose a File\", accept=[\".geojson\"], multiple=False),\n\t\t\t),\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.JSONFile === 'Provided'\",\n\t\t\t\tui.input_select(id=\"JSONSelection\", label=None, choices=Mappings, multiple=False, selected=\"canada.geojson\"),\n\t\t\t),\n\n\t\t\tui.input_checkbox(id=\"Temporal\", label=\"Temporal Choropleth\"),\n\n\t\t\tui.input_select(id=\"KeyColumn\", label=\"Key\", choices=[], multiple=False),\n\t\t\tui.input_select(id=\"ValueColumn\", label=\"Value\", choices=[], multiple=False),\n\n\t\t\t# Only OpenStreatMap and CartoDB Positron seem to work.\n\t\t\tui.input_radio_buttons(id=\"MapType\", label=\"Map Type\", choices=[\"OpenStreetMap\", \"CartoDB Positron\"], selected=\"CartoDB Positron\"),\n\n\t\t\tui.input_select(id=\"ColorMap\", label=\"Color Map\", choices=[\"Inferno\", \"Magma\", \"Plasma\", \"Viridis\"], selected=\"Viridis\"),\n\n\t\t\tui.input_slider(id=\"Opacity\", label=\"Heatmap Opacity\", value=0.5, min=0.0, max=1.0, step=0.1),\n\t\t\tui.input_slider(id=\"Bins\", label=\"Number of Colors\", value=8, min=3, max=8, step=1),\n\n\t\t\tui.input_slider(id=\"ROI\", label=\"Range of Interest\", value=(0,0), min=0, max=100),\n\n\t\t\t# Add the download buttons.\n\t\t\t\"Download\",\n\t\t\tui.download_button(\"DownloadHeatmap\", \"Heatmap\"),\n\t\t\tui.download_button(\"DownloadTable\", \"Table\"),\n\n\t\t\tid=\"SidebarPanel\",\n\t\t),\n\n\t\tMainTab(ui.nav_panel(\"GeoJSON\", ui.output_data_frame(\"GeoJSON\")), m_type=ui.output_ui),\n\t)\n)\n\napp = App(app_ui, server)", "type": "text"}, {"name": "requirements.txt", "content": "folium", "type": "text"}, {"name": "shared.py", "content": "#\n# Heatmapper\n# Shared\n#\n# This file contains shared functionality between Heatmapper applications. It is not a standalone application.\n# Due to the way ShinyLive exports applications, this file is symlinked into each project to reduce redundancy.\n#\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nfrom pandas import DataFrame, read_csv, read_excel, read_table\nfrom io import BytesIO\nfrom sys import modules\nfrom copy import deepcopy\nfrom pathlib import Path\nfrom enum import Enum\n\n\n# If pyodide is found, we're running WebAssembly.\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tPyodide = True\n# Otherwise,\nelse:\n\tfrom os.path import exists\n\tPyodide = False\n\n\nclass ColumnType(Enum):\n\tTime = 0\n\tName = 1\n\tValue = 2\n\tLongitude = 3\n\tLatitude = 4\n\tX = 5\n\tY = 6\n\nColumns = {\n\tColumnType.Time: {\"time\", \"date\", \"year\"},\n\tColumnType.Name: {\"name\", \"orf\", \"uniqid\"},\n\tColumnType.Value: {\"value\", \"weight\", \"intensity\"},\n\tColumnType.Longitude: {\"longitude\", \"long\"},\n\tColumnType.Latitude: {\"latitude\", \"lat\"},\n\n\t# This may seem redundant, but it handles case-folding\n\tColumnType.X: {\"x\"},\n\tColumnType.Y: {\"y\"}\n}\n\n\ndef Filter(columns, ctype: ColumnType, good: list = [], bad: list = [], only_one=False, return_unknown=False):\n\t\"\"\"\n\t@brief Filters available column names based on what input we want\n\t@param columns: The columns of the DataFrame (Usually just df.columns)\n\t@param ctype: The type of column we're looking for (Look at the ColumnType Enum)\n\t@param good: A list of column names on top of those defined by the type to be included\n\t@param bad: A list of column names on top of those defined by the type to be excluded from the result.\n\t@return: A list of column names to use.\n\t@info Results are\n\t\"\"\"\n\n\t# Fold cases\n\tfolded = [column.lower() for column in columns]\n\n\t# Add and remove what user asked for, filtering None\n\toptions = set(folded)\n\tif bad: options -= set([b.lower() for b in bad if b])\n\tif good: options &= set([g.lower() for g in good if g])\n\n\t# If we hit the column type, take the intersection, otherwise take the difference\n\tfor key, value in Columns.items():\n\n\t\t# If we exclude unknown values, we always overwrite.\n\t\t# If we aren't excluding unknowns, we replace if the intersection yielded *something*\n\t\tif key == ctype:\n\t\t\tintersection = options & value\n\t\t\tif not return_unknown or intersection: options = intersection\n\t\telse: options -= value\n\n\tif options:\n\t\t# Get the valid indices, and sort them in ascending order\n\t\tindices = [folded.index(value) for value in options]\n\t\tindices.sort()\n\n\t\t# Get the original column names, without case-folding, and return as a list.\n\t\treturn columns[indices[0]] if only_one else [columns[index] for index in indices]\n\telse:\n\t\treturn None\n\n\ndef FillColumnSelection(columns, ctype, name, bad = []):\n\t\"\"\"\n\t@brief Updates a column name selection dialog\n\t@param columns The list of columns to choose from\n\t@param ctype: The type of column we're looking for\n\t@param default: The default index if there are no valid columns\n\t@param name: The name of the ui element to update.\n\t\"\"\"\n\n\t# Filter the columns\n\tnames = Filter(columns, ctype, bad = bad)\n\n\t# If we've got some choices, choose the first as the default.\n\tif names: selected = names[0]\n\n\t# If we don't, allow unknown variables and take from that one\n\t# This removes ones we know aren't correct (like \"time\" for when we want a value)\n\telse:\n\t\tnames = Filter(columns, ctype, bad = bad, return_unknown=True)\n\t\tif not names: return None\n\t\tselected = names[0]\n\n\t# Update the ui\n\tui.update_select(id=name, choices=names, selected=selected)\n\treturn selected\n\n\nclass Cache:\n\t\"\"\"\n\t@brief A class that encompasses fetching/storing web resources.\n\t\"\"\"\n\n\t@staticmethod\n\tdef DefaultHandler(n, i):\n\t\t\"\"\"\n\t\t@brief The default handler. It can handle csv, xlsx, and defaults all other files to read_table\n\t\t@param n: The name of the file. We use this for pattern matching against the suffix.\n\t\t@param i: The binary of the file (Either via read() or BytesIO())\n\t\t@returns: A null-filled DataFrame.\n\t\t\"\"\"\n\n\t\t# Get the function\n\t\tmatch Path(n).suffix:\n\t\t\tcase \".csv\": func = read_csv\n\t\t\tcase \".xlsx\": func = read_excel\n\t\t\tcase _: df = func = read_table\n\n\t\t# Read the table once.\n\t\tdf = func(i).fillna(0)\n\n\t\t# If the first column value is a float, we assume it's data, and not column names.\n\t\t# Re-read the DataFrame with generic column names instead\n\t\ttry:\n\t\t\tfloat(df.columns[0])\n\t\t\ti.seek(0)\n\t\t\tdf = func(i, header=None, names=[f\"Column {i}\" for i in range(df.shape[1])])\n\t\texcept ValueError: pass\n\t\treturn df\n\n\n\t@staticmethod\n\tasync def Remote(url): r = await pyfetch(url); return await r.bytes() if r.ok else None\n\n\n\t@staticmethod\n\tasync def Local(url): return open(url, \"rb\").read() if exists(url) else None\n\n\n\tdef __init__(self, project, DataHandler = DefaultHandler):\n\t\t\"\"\"\n\t\t@brief Initialize an instance of the Cache object.\n\t\t@param project: The name of the project. This is used to fetch web resources.\n\t\t@param DataHandler:\tThe function that should be called to process files. It should\n\t\t\t\t\t\t\t\t\t\t\t\ttake a name, and a binary stream, and return a DataFrame.\n\t\t\"\"\"\n\n\t\t# The primary cache is immutable, and is used when the resource has not been fetched before.\n\t\tself._primary = {}\n\n\t\t# The secondary cache is mutable, and is populated by the primary cache. Purge deletes from here.\n\t\tself._secondary = {}\n\n\t\t# The data handler for processing the binary files.\n\t\tself._handler = DataHandler\n\n\t\t# If we're in a Pyodide environment, we fetch resources from the web.\n\t\tif Pyodide:\n\t\t\tself.Download = lambda url: Cache.Remote(url)\n\t\t\tself.Source = \"https://raw.githubusercontent.com/WishartLab/heatmapper2/main/{}/example_input/\".format(project)\n\n\t\t# Otherwise, we fetch locally.\n\t\telse:\n\t\t\tself.Download = lambda url: Cache.Local(url)\n\t\t\tself.Source = \"../example_input/\"\n\n\n\tasync def Load(self, input, copy=False):\n\t\tn = await self.N(input);\n\t\tdf = DataFrame() if n is None else self._secondary[n]\n\t\treturn deepcopy(df) if copy else df\n\n\n\tasync def N(self, input):\n\t\t\"\"\"\n\t\t@brief Caches whatever the user has currently uploaded/selection, returning the identifier within the secondary cache.\n\t\t@param input: The Shiny input variable. Importantly, these must be defined:\n\t\t\tinput.File: The uploaded file\n\t\t\tinput.Example: The selected example file\n\t\t\tinput.SourceFile: Whether the user wants \"Upload\" or \"Example\"\n\t\t@returns: The identifier. You should probably use Load() unless you need this.\n\t\t\"\"\"\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.File()\n\t\t\tif file is None: return None\n\t\t\tn = file[0][\"name\"]\n\n\t\t\t# Populate the base cache, if we need to\n\t\t\tif n not in self._primary: source = open(file[0][\"datapath\"], 'r')\n\n\t\telse:\n\t\t\tn = input.Example()\n\t\t\tif n not in self._primary: source = BytesIO(await self.Download(self.Source + n))\n\n\t\tif n not in self._primary: self._primary[n] = self._handler(n, source)\n\t\tif n not in self._secondary: self._secondary[n] = deepcopy(self._primary[n])\n\t\treturn n\n\n\n\tdef Cache(self): return self._secondary\n\n\n\tasync def Update(self, input):\n\t\t\"\"\"\n\t\t@brief Updates information within the secondary cache based on user selection\n\t\t@param input: The Shiny input. Importantly, these must be defined:\n\t\t\tinput.TableRow: The row to modify\n\t\t\tinput.TableCol: The column to modify\n\t\t\tinput.TableVal: What the user wants to set as the new value\n\t\t@info This function should be called on a reactive hook for a \"Update\" button.\n\t\t\"\"\"\n\n\t\t# Get the data\n\t\tdf = await self.Load(input)\n\t\trow_count, column_count = df.shape\n\t\trow, column = input.TableRow(), input.TableCol()\n\n\t\t# So long as row and column are sane, update.\n\t\tif row < row_count and column < column_count:\n\t\t\tmatch input.Type():\n\t\t\t\tcase \"Integer\": df.iloc[row, column] = int(input.TableVal())\n\t\t\t\tcase \"Float\": df.iloc[row, column] = float(input.TableVal())\n\t\t\t\tcase \"String\": df.iloc[row, column] = input.TableVal()\n\n\n\tasync def Purge(self, input):\n\t\t\"\"\"\n\t\t@brief Purges the secondary cache of whatever the user has uploaded/selected\n\t\t@param input: The Shiny input. See N() for required objects.\n\t\t@info This function should be called on a reactive hook for a \"Reset\" button.\n\t\t\"\"\"\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.File()\n\t\t\tif file is None: return None\n\t\t\tn = file[0][\"name\"]\n\t\telse:\n\t\t\tn = input.Example()\n\t\tdel self._secondary[n]\n\n\ndef TableValueUpdate(df, input):\n\t\"\"\"\n\t@brief Updates the value displayed in the TableVal based on the current selection\n\t@param df The DataFrame\n\t@param input The shiny input\n\t\"\"\"\n\n\trows, columns = df.shape\n\trow, column = int(input.TableRow()), int(input.TableCol())\n\tif 0 <= row <= rows and 0 <= column <= columns:\n\t\tui.update_text(id=\"TableVal\", label=\"Value (\" + str(df.iloc[row, column]) + \")\"),\n\n\ndef NavBar(current):\n\t\"\"\"\n\t@brief Returns a Navigation Bar for each project, with the current project selected.\n\t@returns A list, containing a ui.panel_title, and a ui.navset_bar.\n\t\"\"\"\n\n\treturn [\n\t\t\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\n\t\tui.navset_bar(\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://wishartlab.github.io/heatmapper2/expression/site/index.html>Expression</a>'), value=\"Expression\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://wishartlab.github.io/heatmapper2/pairwise/site/index.html>Pairwise</a>'), value=\"Pairwise\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://wishartlab.github.io/heatmapper2/image/site/index.html>Image</a>'), value=\"Image\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://wishartlab.github.io/heatmapper2/geomap/site/index.html>Geomap</a>'), value=\"Geomap\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://wishartlab.github.io/heatmapper2/geocoordinate/site/index.html>Geocoordinate</a>'), value=\"Geocoordinate\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://wishartlab.github.io/heatmapper2/about/site/index.html>About</a>'), value=\"About\"),\n\t\t\t\ttitle=\"Heatmapper\",\n\t\t\t\tselected=current,\n\t\t)\n\t]\n\n\ndef FileSelection(examples, types):\n\t\"\"\"\n\t@brief Returns the file selection dialog for the user to upload/select an example\n\t@param examples: Either a list of example file names, or a dictionary mapping\n\t@param types: The valid file extensions for user uploaded files.\n\t@returns A list, containing the necessary ui components for uploading/selecting\n\t@info The returns elements are named:\n\t\tinput.SourceFile: The ui.input_radio_buttons for whether the user wants to choose an \"Example\" or \"Upload\"\n\t\tinput.File: The ui.input_file for user uploaded files.\n\t\tinput.Example: The ui.input_select for an example file selection\n\t\"\"\"\n\n\t# If the user needs help with the formatting.\n\treturn [ui.HTML('<a href=https://wishartlab.github.io/heatmapper2/about/site/index.html>Data Format</a>'),\n\n\t# Specify whether to use example files, or upload one.\n\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"], selected=\"Example\", inline=True),\n\n\t# Only display an input dialog if the user is one Upload\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Upload'\",\n\t\tui.input_file(\"File\", \"Choose a File\", accept=types, multiple=False),\n\t),\n\n\t# Otherwise, add the example selection and an info button.\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Example'\",\n\t\tui.layout_columns(\n\t\t\tui.input_select(id=\"Example\", label=None, choices=examples, multiple=False),\n\t\t\tui.popover(ui.input_action_link(id=\"ExampleInfoButton\", label=\"Info\"), ui.output_text(\"ExampleInfo\")),\n\t\t\tcol_widths=[10,2],\n\t\t)\n\t)]\n\n\ndef MainTab(*args, m_type=ui.output_plot):\n\treturn ui.navset_tab(\n\t\tui.nav_panel(\"Interactive\", m_type(\"Heatmap\", height=\"75vh\"), value=\"Interactive\"),\n\t\tui.nav_panel(\"Table\",\n\t\t\tui.layout_columns(\n\t\t\t\tui.input_numeric(\"TableRow\", \"Row\", 0),\n\t\t\t\tui.input_numeric(\"TableCol\", \"Column\", 0),\n\t\t\t\tui.input_text(\"TableVal\", \"Value\", 0),\n\t\t\t\tui.input_select(id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"]),\n\t\t\t\tcol_widths=[2,2,6,2],\n\t\t\t),\n\t\t\tui.layout_columns(\n\t\t\t\tui.input_action_button(\"Update\", \"Update\"),\n\t\t\t\tui.input_action_button(\"Reset\", \"Reset Values\"),\n\t\t\t),\n\t\t\tui.output_data_frame(\"LoadedTable\")\n\t\t),\n\t\t*args,\n\t\tid=\"MainTab\"\n\t)", "type": "text"}]