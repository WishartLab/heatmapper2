[{"name": "app.py", "content": "#\n# Heatmapper\n# Expression\n#\n# This file contains the ShinyLive application for Expression Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshinylive export . [site]\n# Where [site] is the destination of the site folder.\n#\n# If you would rather deploy the application as a PyShiny application,\n# run the following command within this directory:\n#\t\tshiny run\n#\n#\n\n\nfrom shiny import App, reactive, render, ui, types\nfrom matplotlib.pyplot import figure, subplots, colorbar\nfrom matplotlib.colors import LinearSegmentedColormap\nfrom scipy.cluster import hierarchy\nfrom scipy.stats import zscore\nfrom pandas import DataFrame\n\nfrom shared import Cache, NavBar, MainTab, FileSelection, Filter, ColumnType, TableValueUpdate, Colors\n\n\ndef server(input, output, session):\n\t# Information about the Examples\n\tInfo = {\n\t\t\"example1.txt\": \"This example dataset is sample input retrieved from the website for the Ashley Lab Heatmap Builder.\",\n\t\t\"example2.txt\": \"This example dataset is sample input retrieved from an online tutorial by Yan Cui (ycui2@uthsc.edu).\",\n\t\t\"example3.txt\": \"This example dataset is retrieved from the online supplement to Eisen et al. (1998), which is a very well known paper about cluster analysis and visualization. The details of how the data was collected are outlined in the paper.\"\n\t}\n\n\tDataCache = Cache(\"expression\")\n\tData = reactive.value(DataFrame())\n\n\t@reactive.effect\n\t@reactive.event(input.SourceFile, input.File, input.Example, input.Reset)\n\tasync def UpdateData(): \n\t\t\"\"\"\n\t\t@brief Updates the reactive Data when input changes.\n\n\t\tData is a reactive value that contains the current state of the input DataFrame. Rather than fetching it on each use\n\t\t(Even from a Cache), we store it as a variable to provide immediate access. This function queries the cache when the \n\t\tsource file changes, or the user explicitly resets the data.\n\t\t\"\"\"\n\t\tData.set((await DataCache.Load(input)).copy(deep=True))\n\n\n\tdef GetData(): \n\t\t\"\"\"\n\t\t@brief Get the Data variable\n\n\t\tData is the static state of user input, and does not reflect the state of the user-modified table in the Table. However, \n\t\tthe data_view() function of the Table will throw a SilentException if it hasn't been initialized (The user hasn't navigated\n\t\tto the Table table). Therefore, we either need to return the raw variable if the Table hasn't been initialized, or the \n\t\tdata_view() if it has.\n\t\t\"\"\"\n\t\ttry: return Table.data_view()\n\t\texcept types.SilentException: return Data()\n\n\n\tdef ProcessData(df):\n\t\t\"\"\"\n\t\t@brief Extracts the labels for each axis, and returns it alongside a DataFrame containing only the relevant data.\n\t\t@returns\tA list containing the labels for the y axis, a list containing the labels for the x axis, and a\n\t\t\t\t\t\t\tDataFrame containing the loaded data without those two columns.\n\t\t\"\"\"\n\n\t\tname = input.NameColumn()\n\t\tif name not in df: return None, None , None\n\n\t\t# Drop the naming columns before linkage.\n\t\tdata = df.drop(columns=Filter(df.columns, ColumnType.Name))\n\t\tx_labels = [\"X\" + name if list(data.columns).count(name) == 1 else \"X\" + name + f\".{i+1}\" for i, name in enumerate(data.columns)]\n\t\treturn list(df[name]), x_labels, data\n\n\n\tdef GenerateDendrogram(data, ax, orientation, progress, labels = [], invert=False):\n\t\t\"\"\"\n\t\t@brief General dendrogram generator.\n\t\t@param data: The DataFrame that contains the data to generate the dendrogram from.\n\t\t@param ax: The MatPlotLib Axis to assign tick marks to\n\t\t@param orientation: What orientation we should set the dendrogram to be. Can be \"Left\", \"Right\", \"Top\", or \"Bottom\"\n\t\t@param labels: An optional list of labels to add the dendrogram, labelling the X axis on Left/Right, and the Y on Top/Bottom\n\t\t@param invert: Whether to invert the DataFrame to generate Columnar dendrograms.\n\t\t@returns The dendrogram, mostly useful to aligning the Heatmap to the new ordering.\n\t\t\"\"\"\n\n\t\tif progress is not None: progress.inc(message=\"Creating linkage matrix...\")\n\t\tmatrix = hierarchy.linkage(data.values.T if invert else data.values, method=input.ClusterMethod().lower(), metric=input.DistanceMethod().lower())\n\n\t\tif progress is not None: progress.inc(message=\"Creating dendrogram...\")\n\t\tdendrogram = hierarchy.dendrogram(matrix, ax=ax, orientation=orientation.lower())\n\n\t\t# If there are labels, sort them according to the dendrogram.\n\t\tif labels: labels = [labels[i] for i in dendrogram[\"leaves\"]]\n\n\t\t# Add ticks depending on the orientation.\n\t\tif orientation == \"Left\" or orientation == \"Right\":\n\t\t\tax.set_xticks([])\n\t\t\tax.set_yticklabels(labels, fontsize=input.TextSize())\n\t\telse:\n\t\t\tax.set_yticks([])\n\t\t\tax.set_xticklabels(labels, fontsize=input.TextSize())\n\n\t\treturn dendrogram\n\n\n\tdef RenderDendrogram(data, labels, invert, progress):\n\t\t\"\"\"\n\t\t@brief Renders a Dendrogram\n\t\t@param data: The DataFrame\n\t\t@param labels: The labels for the Dendrogram\n\t\t@param invert: Whether to invert (Use for Column Dendrograms)\n\t\t@pararm progress: The progress bar to update when generating the Dendrogram.\n\t\t\"\"\"\n\t\tif data is None: return\n\n\t\tfig = figure(figsize=(12, 10))\n\t\tax = fig.add_subplot(111)\n\n\t\tax.spines[\"top\"].set_visible(False)\n\t\tax.spines[\"right\"].set_visible(False)\n\t\tax.spines[\"bottom\"].set_visible(False)\n\t\tax.spines[\"left\"].set_visible(False)\n\n\t\tGenerateDendrogram(data, ax, input.Orientation(), progress, labels, invert=invert)\n\t\treturn fig\n\n\n\t@render.data_frame\n\tdef Table():  return render.DataGrid(Data(), editable=True)\n\n\n\t@Table.set_patch_fn\n\tdef UpdateTable(*, patch: render.CellPatch) -> render.CellValue:\n\t\tif input.Type() == \"Integer\": value = int(patch[\"value\"])\n\t\telif input.Type() == \"Float\": value = float(patch[\"value\"])\n\t\telse: value = patch[\"value\"]\n\t\treturn value\n\n\n\t@render.plot\n\tdef Heatmap(): \n\t\t\"\"\"\n\t\t@brief Generates the Heatmap\n\t\t@returns The heatmap\n\t\t\"\"\"\n\n\t\twith ui.Progress() as p:\n\t\t\tp.inc(message=\"Reading input...\")\n\t\t\tindex_labels, x_labels, data = ProcessData(GetData())\n\t\t\tif data is None: return\n\n\t\t\t# Create a figure with a heatmap and associated dendrograms\n\t\t\tp.inc(message=\"Plotting...\")\n\t\t\tfig = figure(figsize=(12, 10))\n\n\t\t\tgs = fig.add_gridspec(4, 2, height_ratios=[2, 8, 1, 1], width_ratios=[2, 8], hspace=0, wspace=0)\n\n\t\t\t# If we render the row dendrogram, we change the order of the index labels to match the dendrogram.\n\t\t\t# However, if we aren't rendering it, and thus row_dendrogram isn't defined, we simply assign df\n\t\t\t# To data, so the order changes when turning the toggle.\n\t\t\tif \"row\" in input.Features():\n\t\t\t\tax_row = fig.add_subplot(gs[1, 0])\n\t\t\t\trow_dendrogram = GenerateDendrogram(data, ax_row, \"Left\", progress=p)\n\t\t\t\tax_row.axis(\"off\")\n\t\t\t\tleaves = row_dendrogram[\"leaves\"]\n\t\t\t\tleaves.reverse()\n\n\t\t\t\tindex_labels = [index_labels[i] for i in leaves]\n\t\t\t\tdf = data.iloc[leaves]\n\t\t\telse:\n\t\t\t\tdf = data\n\n\t\t\t# If we render the column dendrogram.\n\t\t\tif \"col\" in input.Features():\n\t\t\t\tax_col = fig.add_subplot(gs[0, 1])\n\t\t\t\tcol_dendrogram = GenerateDendrogram(data, ax_col, \"Top\", invert=True, progress=p)\n\t\t\t\tax_col.axis(\"off\")\n\n\t\t\t# Handle scaling\n\t\t\tif input.ScaleType() != \"None\": df = zscore(df, axis=1 if input.ScaleType() == \"Row\" else 0)\n\t\t\t\n\t\t\t# Render the heatmap.\n\t\t\tax_heatmap = fig.add_subplot(gs[1, 1])\n\n\t\t\tcolors = input.CustomColors() if input.Custom() else input.ColorMap().split()\n\n\t\t\theatmap = ax_heatmap.imshow(\n\t\t\t\tdf,\n\t\t\t\tcmap=LinearSegmentedColormap.from_list(\"ColorMap\", colors, N=input.Bins()),\n\t\t\t\tinterpolation=input.Interpolation().lower(),\n\t\t\t\taspect=\"auto\",\n\t\t\t)\n\n\t\t\t# If we render the Y axis.\n\t\t\tif \"y\" in input.Features():\n\t\t\t\tax_heatmap.set_yticks(range(len(index_labels)))\n\t\t\t\tax_heatmap.set_yticklabels(index_labels, fontsize=input.TextSize())\n\t\t\t\tax_heatmap.yaxis.tick_right()\n\t\t\telse:\n\t\t\t\tax_heatmap.set_yticklabels([])\n\n\t\t\t# If we render the X axis.\n\t\t\tif \"x\" in input.Features():\n\t\t\t\tax_heatmap.set_xticks(range(len(x_labels)))\n\t\t\t\tax_heatmap.set_xticklabels(x_labels, rotation=90, fontsize=input.TextSize())\n\t\t\telse:\n\t\t\t\tax_heatmap.set_xticklabels([])\n\n\t\t\t# If we render the legend.\n\t\t\tif \"legend\" in input.Features():\n\t\t\t\tax_cbar = fig.add_subplot(gs[3, 1])\n\t\t\t\tcbar = fig.colorbar(heatmap, cax=ax_cbar, orientation=\"horizontal\")\n\t\t\t\tcbar.ax.tick_params(labelsize=input.TextSize())\n\t\t\treturn fig\n\n\n\t@output\n\t@render.plot\n\tdef RowDendrogram(): \n\t\tindex_labels, _, data = ProcessData(GetData()); \n\t\twith ui.Progress() as p:\n\t\t\treturn RenderDendrogram(data=data, labels=index_labels, invert=False, progress=p)\n\n\n\t@output\n\t@render.plot\n\tdef ColumnDendrogram():\n\t _, x_labels, data = ProcessData(GetData()); \n\t with ui.Progress() as p:\n\t \treturn RenderDendrogram(data=data, labels=x_labels, invert=True, progress=p)\n\n\n\t@output\n\t@render.text\n\t@reactive.event(input.SourceFile, input.Example)\n\tdef ExampleInfo(): return Info[input.Example()]\n\n\n\t@render.download(filename=\"table.csv\")\n\tdef DownloadTable(): yield GetData().to_string()\n\n\n\t@reactive.Effect\n\tdef UpdateColumnSelection(): Filter(GetData().columns, ColumnType.Name, ui_element=\"NameColumn\")\n\n\napp_ui = ui.page_fluid(\n\n\tNavBar(),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\n\t\t\tFileSelection(\n\t\t\t\texamples={\"example1.txt\": \"Example 1\", \"example2.txt\": \"Example 2\", \"example3.txt\": \"Example 3\"},\n\t\t\t\ttypes=[\".csv\", \".txt\", \".dat\", \".tsv\", \".tab\", \".xlsx\", \".xls\", \".odf\"],\n\t\t\t\tproject=\"Expression\"\n\t\t\t),\n\n\t\t\t# The column that holds names for the data.\n\t\t\tui.input_select(id=\"NameColumn\", label=\"Names\", choices=[], multiple=False),\n\n\t\t\t# https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.linkage.html\n\t\t\tui.input_select(id=\"ClusterMethod\", label=\"Clustering Method\", choices=[\"Single\", \"Complete\", \"Average\", \"Weighted\", \"Centroid\", \"Median\", \"Ward\"], selected=\"Average\"),\n\n\t\t\t# https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html#scipy.spatial.distance.pdist\n\t\t\tui.input_select(id=\"DistanceMethod\", label=\"Distance Method\", choices=[\"Braycurtis\", \"Canberra\", \"Chebyshev\", \"Cityblock\", \"Correlation\", \"Cosine\", \"Dice\", \"Euclidean\", \"Hamming\", \"Jaccard\", \"Jensenshannon\", \"Kulczynski1\", \"Mahalanobis\", \"Matching\", \"Minkowski\", \"Rogerstanimoto\", \"Russellrao\", \"Seuclidean\", \"Sokalmichener\", \"Sokalsneath\", \"Sqeuclidean\", \"Yule\"], selected=\"Euclidean\"),\n\n\t\t\t# Customize the text size of the axes.\n\t\t\tui.input_numeric(id=\"TextSize\", label=\"Text Size\", value=8, min=1, max=50, step=1),\n\n\t\t\t# Settings pertaining to the Heatmap view.\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'HeatmapTab'\",\n\t\t\t\tui.br(),\n\n\t\t\t\t# Define how the colors are scaled.\n\t\t\t\tui.input_select(id=\"ScaleType\", label=\"Scale Type\", choices=[\"Row\", \"Column\", \"None\"], selected=\"Row\"),\n\n\t\t\t\t# https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html\n\t\t\t\tui.input_select(\n\t\t\t\t\tid=\"Interpolation\", \n\t\t\t\t\tlabel=\"Interpolation\", \n\t\t\t\t\tchoices=[\"None\", \"Antialiased\", \"Nearest\", \"Bilinear\", \"Bicubic\", \"Spline16\", \"Spline36\", \"Hanning\", \"Hamming\", \"Hermite\", \"Kaiser\", \"Quadric\", \"Catrom\", \"Gaussian\", \"Bessel\", \"Mitchell\", \"Sinc\", \"Lanczos\", \"Blackman\"], \n\t\t\t\t\tselected=\"Nearest\",\n\t\t\t\t),\n\n\t\t\t\tui.layout_columns(\n\t\t\t\t\t\"Color Map\",\n\t\t\t\t\tui.input_checkbox(id=\"Custom\", label=\"Custom\"),\n\t\t\t\t),\n\t\t\t\tui.panel_conditional(\n\t\t\t\t\t\"input.Custom\",\n\t\t\t\t\t\tui.input_select(\n\t\t\t\t\t\tid=\"CustomColors\",\n\t\t\t\t\t\tlabel=None,\n\t\t\t\t\t\tchoices=Colors,\n\t\t\t\t\t\tselected=[\"Blue\", \"White\", \"Yellow\"],\n\t\t\t\t\t\tmultiple=True,\n\t\t\t\t\t\tselectize=True,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tui.panel_conditional(\n\t\t\t\t\t\"!input.Custom\",\n\t\t\t\t\tui.input_select(id=\"ColorMap\", label=None, choices={\n\t\t\t\t\t\t\t\"Blue White Yellow\": \"Blue/Yellow\",\n\t\t\t\t\t\t\t\"Red Black Green\": \"Red/Green\",\n\t\t\t\t\t\t\t\"Pink White Green\": \"Pink/Green\",\n\t\t\t\t\t\t\t\"Blue Green Yellow\": \"Blue/Green/Yellow\",\n\t\t\t\t\t\t\t\"Black Gray White\": \"Grayscale\",\n\t\t\t\t\t\t\t\"Red Orange Yellow Green Blue Indigo Violet\": \"Rainbow\",\n\t\t\t\t\t\t}\n\t\t\t\t\t),\n\t\t\t\t),\n\n\t\t\t\tui.input_slider(id=\"Bins\", label=\"Number of Bins\", value=50, min=3, max=100, step=1),\n\n\t\t\t\t# Toggle rendering features. All are on by default.\n\t\t\t\tui.input_checkbox_group(id=\"Features\", label=\"Visibility\",\n\t\t\t\t\tchoices={\"row\": \"Row Dendrogram\", \"col\": \"Column Dendrogram\", \"x\": \"X Labels\", \"y\": \"Y Labels\", \"legend\": \"Legend\"},\n\t\t\t\t\tselected=[\"row\", \"col\", \"x\", \"y\", \"legend\"])\n\t\t\t),\n\n\t\t\t# Settings pertaining to the dendrogram view.\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'RowTab' || input.MainTab === 'ColumnTab'\",\n\t\t\t\tui.br(),\n\n\t\t\t\t# Define the Orientation of the dendrogram in the Tab\n\t\t\t\tui.input_select(id=\"Orientation\", label=\"Dendrogram Orientation\", choices=[\"Top\", \"Bottom\", \"Left\", \"Right\"], selected=\"Left\"),\n\t\t\t),\n\n\t\t\t# Add the download buttons. You can download the heatmap by right clicking it :)\n\t\t\tui.download_button(\"DownloadTable\", \"Download Table\"),\n\n\t\t\tid=\"SidebarPanel\",\n\t\t),\n\n\t\t# Add the main interface tabs.\n\t\tMainTab(\n\t\t\tui.nav_panel(\"Row Dendrogram\", ui.output_plot(\"RowDendrogram\", height=\"90vh\"), value=\"RowTab\"),\n\t\t\tui.nav_panel(\"Column Dendrogram\", ui.output_plot(\"ColumnDendrogram\", height=\"90vh\"), value=\"ColumnTab\"),\n\t\t),\n\t)\n)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "shared.py", "content": "#\n# Heatmapper\n# Shared\n#\n# This file contains shared functionality between Heatmapper applications. It is not a standalone application.\n# Due to the way ShinyLive exports applications, this file is symlinked into each project to reduce redundancy.\n#\n\nfrom shiny import ui\nfrom shiny.types import FileInfo\nfrom pandas import DataFrame, read_csv, read_excel, read_table\nfrom io import BytesIO\nfrom tempfile import NamedTemporaryFile\nfrom sys import modules\nfrom pathlib import Path\nfrom enum import Enum\nfrom os.path import exists\n\n# Used for fetching web resources in a variety of fashions.\nURL = \"https://wishartlab.github.io/heatmapper2\"\nRaw = \"https://raw.githubusercontent.com/WishartLab/heatmapper2/main\"\n\n# Define the Server and Port of the Shiny instances (Port is incremented)\n# Change these if Heatmapper is running on a server.\nServer = \"http://35.208.86.138\"\nPort = 8000\n\n# Detect the running environment\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tPyodide = True\nelse:\n\tPyodide = False\n\n# MatPlotLib Colors\nColors = [\"Blue\", \"Orange\", \"Green\", \"Red\", \"Purple\", \"Brown\", \"Pink\", \"Gray\", \"Olive\", \"Cyan\", \"White\", \"Yellow\"]\n\nclass ColumnType(Enum): Time = 0; Name = 1; Value = 2; Longitude = 3; Latitude = 4; X = 5; Y = 6; Z = 7; Cluster = 8; Free = 9; Spatial = 10;\nColumns = {\n\tColumnType.Time: {\"time\", \"date\", \"year\"},\n\tColumnType.Name: {\"name\", \"orf\", \"uniqid\", \"face\", \"triangle\"},\n\tColumnType.Value: {\"value\", \"weight\", \"intensity\", \"in_tissue\"},\n\tColumnType.Longitude: {\"longitude\", \"long\"},\n\tColumnType.Latitude: {\"latitude\", \"lat\"},\n\tColumnType.X: {\"x\"},\n\tColumnType.Y: {\"y\"},\n\tColumnType.Z: {\"z\"},\n\tColumnType.Cluster: {\"cell type\", \"celltype_mapped_refined\", \"cluster\", \"cell_class\", \"cell_subclass\", \"cell_cluster\"},\n\tColumnType.Free: {None},\n\tColumnType.Spatial: {\"spatial\"}\n}\n\n\ndef Filter(columns, ctype: ColumnType, good: list = [], bad: list = [], only_one=False, ui_element=None, reject_unknown=False):\n\t\"\"\"\n\t@brief Filters available column names based on what input we want\n\t@param columns: The columns of the DataFrame (Usually just df.columns)\n\t@param ctype: The type of column we're looking for (Look at the ColumnType Enum)\n\t@param good: A list of column names on top of those defined by the type to be included\n\t@param bad: A list of column names on top of those defined by the type to be excluded from the result.\n\t@param only_one: Only return a single result, so the variable can be used immediately.\n\t@param ui_element: An optional Shiny selection input to update.\n\t@param reject_unknown: Only include columns explicitly defined\n\t@return: A list of column names to use.\n\t\"\"\"\n\n\t# Fold cases\n\tfolded = [column.lower() for column in columns]\n\n\t# Add and remove what user asked for, filtering None\n\toptions = set(folded)\n\tif bad: options -= set([b.lower() for b in bad if b])\n\tif good: options &= set([g.lower() for g in good if g])\n\n\t# Take an intersection of our columns and the type we want. If there is a match, return those\n\t# Otherwise, remove all columns we know it shouldn't be, and return that instead.\n\tintersection = options & Columns[ctype]\n\tif intersection or reject_unknown: options = intersection\n\telse:\n\t\tfor key, value in Columns.items():\n\t\t\tif key != ctype: options -= value\n\n\t# Get the valid indices, and sort them in ascending order\n\tindices = [folded.index(value) for value in options]\n\tindices.sort()\n\n\t# Get the original column names, without case-folding, and return as a list.\n\treassembled = [columns[index] for index in indices]\n\tif not reassembled: return None\n\n\t# Update a UI element, if one was provided\n\tif ui_element is not None: ui.update_select(id=ui_element, choices=reassembled, selected=reassembled[0])\n\treturn reassembled[0] if only_one else reassembled\n\n\nclass Cache:\n\t\"\"\"\n\t@brief A class that encompasses fetching/storing web resources.\n\t\"\"\"\n\n\t@staticmethod\n\tdef HandleDataFrame(path, function):\n\t\t\"\"\"\n\t\t@brief Handle DataFrame's\n\t\t@param i: The binary of the file\n\t\t@param function: The pandas function to use to read the file.\n\t\t@returns A DataFrame\n\t\t\"\"\"\n\n\t\t# Read the table once.\n\t\tdf = function(path.resolve()).fillna(0)\n\n\t\t# If the first column value is a float, we assume it's data, and not column names.\n\t\t# Re-read the DataFrame with generic column names instead\n\t\ttry:\n\t\t\tfloat(df.columns[0])\n\t\t\tdf = function(path.resolve(), header=None, names=[f\"Column {i}\" for i in range(df.shape[1])])\n\t\texcept ValueError: pass\n\t\treturn df\n\n\n\t@staticmethod\n\tdef DefaultHandler(path):\n\t\t\"\"\"\n\t\t@brief The default handler. It can handle csv, xlsx, and defaults all other files to read_table\n\t\t@param n: The path to the file\n\t\t@returns: An object, if the provided file is supported, None otherwise.\n\t\t\"\"\"\n\n\t\tsuffix = path.suffix\n\t\tif suffix == \".csv\": return Cache.HandleDataFrame(path, read_csv)\n\t\telif suffix == \".xlsx\" or suffix == \".xls\" or suffix == \".odf\": return Cache.HandleDataFrame(path, read_excel)\n\t\telse: return Cache.HandleDataFrame(path, read_table)\n\n\n\tasync def _remote(self, url):\n\t\tif url not in self._primary:\n\t\t\tr = await pyfetch(url);\n\t\t\tif not r.ok: return None\n\t\t\telse: self._primary[url] = await r.bytes()\n\t\treturn self._primary[url]\n\n\n\tasync def _local(self, url):\n\t\tif not exists(url): return None\n\t\treturn Path(url)\n\n\n\tdef _local_sync(self, url):\n\t\tif not exists(url): return None\n\t\treturn Path(url)\n\n\n\tdef __init__(self, project, DataHandler = DefaultHandler):\n\t\t\"\"\"\n\t\t@brief Initialize an instance of the Cache object.\n\t\t@param project: The name of the project. This is used to fetch web resources.\n\t\t@param DataHandler:\tThe function that should be called to process files. It should\n\t\t\t\t\t\t\t\t\t\t\t\ttake a name, and a binary stream, and return a DataFrame.\n\t\t\"\"\"\n\n\t\t# The primary cache now serves as a file agnostic cache, containing the raw bytes of files.\n\t\tself._primary = {}\n\n\t\t# The Secondary cache now serves as the transformed output through the handler. There is now\n\t\t# no need to specify mutability because the primary cache doesn't contain data that can be changed.\n\t\t# It serves solely as a cache for the Handler if the user throws out whatever is in the secondary.\n\t\tself._secondary = {}\n\n\t\t# The data handler for processing the binary files.\n\t\tself._handler = DataHandler\n\n\t\t# If we're in a Pyodide environment, we fetch resources from the web.\n\t\tif Pyodide:\n\t\t\tself._download = lambda url: self._remote(url)\n\t\t\tself._source = f\"{Raw}/{project}/example_input/\"\n\n\t\t# Otherwise, we fetch locally.\n\t\telse:\n\t\t\tself._download = lambda url: self._local(url)\n\t\t\tself._source = \"../example_input/\"\n\n\n\tdef SyncLoad(self, input, source_file=None, example_file=None, source=None, input_switch=None, default=DataFrame(), return_n=False):\n\t\t\"\"\"\n\t\t@brief A synchronous loading function that only supports local files\n\t\t@info See Load() for more information\n\t\t\"\"\"\n\t\tif source_file is None: source_file = input.File()\n\t\tif example_file is None: example_file = input.Example()\n\t\tif source is None: source = self._source\n\t\tif input_switch is None: input_switch = input.SourceFile()\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input_switch == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = source_file\n\t\t\tif file is None: return (None, default) if return_n else default\n\n\t\t\t# The datapath can be immediately used to load examples, but we explicitly need to use\n\t\t\t# Local as a user uploaded file will always be fetched on disk.\n\t\t\tn = str(file[0][\"datapath\"])\n\t\t\tpath = Path(n)\n\n\t\t# Example files, conversely, can be on disk or on a server depending on whether we're in a WASM environment.\n\t\telse:\n\t\t\tn = str(source + example_file)\n\t\t\tpath = self._local_sync(n)\n\t\t\n\t\t# If the secondary cache hasn't been populated (Or was purge by the user), populate it.\n\t\tif n not in self._secondary:\n\t\t\tself._secondary[n] = self._handler(path)\n\n\t\treturn (n, self._secondary[n]) if return_n else self._secondary[n]\n\n\n\tasync def Load(self, input, source_file=None, example_file=None, source=None, input_switch=None, default=DataFrame(), return_n=False):\n\t\t\"\"\"\n\t\t@brief Caches whatever the user has currently uploaded/selection, returning the identifier within the secondary cache.\n\t\t@param input: The Shiny input variable. Importantly, these must be defined:\n\t\t\tinput.File: The uploaded file\n\t\t\tinput.Example: The selected example file\n\t\t\tinput.SourceFile: Whether the user wants \"Upload\" or \"Example\"\n\t\t@param source_file: The input ID that should be used to fetch the file (Defaults to input.File() if None)\n\t\t@param example_file: The input ID that should be used to fetch th example (Defaults to input.Example() if None)\n\t\t@param input_switch:\tThe input ID to check for Upload/Example/Other. The value is compared against \"Upload\" for user\n\t\t\t\t\t\t\t\t\t\t\t\t\tuploaded items, and defaults to fetching example_file otherwise. (Defaults to input.SourceFile())\n\t\t@param default:\tThe object that should be returned if files cannot be fetched. Ensures that Load will always return an\n\t\t\t\t\t\t\t\t\t\tobject, avoiding the needing to check output. Defaults to a DataFrame. The object should be able to\n\t\t\t\t\t\t\t\t\t\tinitialize without arguments.\n\t\t@param return_n: Return the filename for post-processing.\n\t\t\"\"\"\n\n\t\tif source_file is None: source_file = input.File()\n\t\tif example_file is None: example_file = input.Example()\n\t\tif source is None: source = self._source\n\t\tif input_switch is None: input_switch = input.SourceFile()\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input_switch == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = source_file\n\t\t\tif file is None: return (None, default) if return_n else default\n\n\t\t\t# The datapath can be immediately used to load examples, but we explicitly need to use\n\t\t\t# Local as a user uploaded file will always be fetched on disk.\n\t\t\tn = str(file[0][\"datapath\"])\n\t\t\tpath = Path(n)\n\n\t\t# Example files, conversely, can be on disk or on a server depending on whether we're in a WASM environment.\n\t\telse:\n\t\t\tn = str(source + example_file)\n\t\t\traw = await self._download(n)\n\t\t\tif type(raw) is bytes:\n\t\t\t\ttemp = NamedTemporaryFile(suffix=Path(n).suffix); temp.write(BytesIO(raw).read()); temp.seek(0)\n\t\t\t\tpath = Path(temp.name)\n\t\t\telse: path = raw\n\n\t\t# If the secondary cache hasn't been populated (Or was purge by the user), populate it.\n\t\tif n not in self._secondary:\n\t\t\tself._secondary[n] = self._handler(path)\n\n\t\treturn (n, self._secondary[n]) if return_n else self._secondary[n]\n\n\n\tasync def Update(self, input):\n\t\t\"\"\"\n\t\t@brief Updates information within the secondary cache based on user selection\n\t\t@param input: The Shiny input. Importantly, these must be defined:\n\t\t\tinput.TableRow: The row to modify\n\t\t\tinput.TableCol: The column to modify\n\t\t\tinput.TableVal: What the user wants to set as the new value\n\t\t@info This function should be called on a reactive hook for a \"Update\" button.\n\t\t\"\"\"\n\n\t\t# Get the data\n\t\tdf = await self.Load(input)\n\t\tif not type(df) is DataFrame: return\n\n\t\trow_count, column_count = df.shape\n\t\trow, column = input.TableRow(), input.TableCol()\n\n\t\t# So long as row and column are sane, update.\n\t\tif row < row_count and column < column_count:\n\t\t\ttry:\n\t\t\t\tif input.Type() == \"Integer\": df.iloc[row, column] = int(input.TableVal())\n\t\t\t\telif input.Type() == \"Float\": df.iloc[row, column] = float(input.TableVal())\n\t\t\t\telse: df.iloc[row, column] = input.TableVal()\n\t\t\texcept ValueError: pass\n\n\n\tasync def Purge(self, input, source_file=None, example_file=None, source=None):\n\t\t\"\"\"\n\t\t@brief Purges the secondary cache of whatever the user has uploaded/selected\n\t\t@param input: The Shiny input. See N() for required objects.\n\t\t@param source_file: The source ID, defaults to input.File()\n\t\t@param example_file: The example ID, defaults to input.Example()\n\t\t@param source: The path that should be appending to the path for fetching. \n\t\t@info This function should be called on a reactive hook for a \"Reset\" button.\n\t\t\"\"\"\n\n\t\tif source_file is None: source_file = input.File()\n\t\tif example_file is None: example_file = input.Example()\n\t\tif source is None: source = self._source\n\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = source_file\n\t\t\tif file is None: return None\n\t\t\tn = file[0][\"datapath\"]\n\t\telse: n = source + example_file\n\t\tdel self._secondary[n]\n\n\ndef TableValueUpdate(df, input):\n\t\"\"\"\n\t@brief Updates the value displayed in the TableVal based on the current selection\n\t@param df The DataFrame\n\t@param input The shiny input\n\t\"\"\"\n\n\tif not df.empty:\n\t\trows, columns = df.shape\n\t\ttry:\n\t\t\trow, column = int(input.TableRow()), int(input.TableCol())\n\t\t\tif 0 <= row <= rows and 0 <= column <= columns:\n\t\t\t\tui.update_text(id=\"TableVal\", label=\"Value (\" + str(df.iloc[row, column]) + \")\")\n\t\texcept TypeError: pass\n\n\ndef NavBar():\n\t\"\"\"\n\t@brief Returns a Navigation Bar for each project, with the current project selected.\n\t@returns A list, containing a ui.panel_title, and a ui.navset_bar.\n\t\"\"\"\n\n\tSources = {\n\t\t\"expression\": f\"{URL}/expression/site/index.html\" if Pyodide else f\"{Server}:{Port}\",\n\t\t\"pairwise\": f\"{URL}/pairwise/site/index.html\" if Pyodide else f\"{Server}:{Port + 1}\",\n\t\t\"image\": f\"{URL}/image/site/index.html\" if Pyodide else f\"{Server}:{Port + 2}\",\n\t\t\"geomap\": f\"{URL}/geomap/site/index.html\" if Pyodide else f\"{Server}:{Port + 3}\",\n\t\t\"geocoordinate\": f\"{URL}/geocoordinate/site/index.html\" if Pyodide else f\"{Server}:{Port + 4}\",\n\t\t\"3d\": f\"{Server}:{Port + 5}\",\n\t\t\"spatial\": f\"{Server}:{Port + 6}\",\n\t}\n\n\treturn (\n\t\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\t\tui.navset_bar(\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"expression\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Expression</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"pairwise\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Pairwise</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"image\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Image</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geomap\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geomap</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"geocoordinate\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Geocoordinate</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"3d\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">3D</a>')),\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"{Sources[\"spatial\"]}\" target=\"_blank\" rel=\"noopener noreferrer\">Spatial</a>')),\n\t\t\tui.nav_control(ui.HTML('<a href=https://github.com/WishartLab/heatmapper2/wiki target=\"_blank\" rel=\"noopener noreferrer\">About</a>')),\n\t\t\tui.nav_spacer(),\n\t\t\tui.nav_control(ui.input_dark_mode(id=\"mode\")),\n\t\t\ttitle=\"Heatmapper\",\n\t\t),\n\t)\n\n\ndef FileSelection(examples, types, upload_label=\"Choose a File\", multiple=False, default=\"Example\", project=\"Overview\"):\n\t\"\"\"\n\t@brief Returns the file selection dialog for the user to upload/select an example\n\t@param examples: Either a list of example file names, or a dictionary mapping\n\t@param types: The valid file extensions for user uploaded files.\n\t@param upload_label: The label for the upload input. Useful to define specifically what kind of files are needed\n\t@param multiple: Whether to accept multiple files. \n\t@param default: Whether to start on the example, or upload dialog\n\t@param project: The name of a project, to specify a specified header within the Interface documentation\n\t@returns A list, containing the necessary ui components for uploading/selecting\n\t@info The returns elements are named:\n\t\tinput.SourceFile: The ui.input_radio_buttons for whether the user wants to choose an \"Example\" or \"Upload\"\n\t\tinput.File: The ui.input_file for user uploaded files.\n\t\tinput.Example: The ui.input_select for an example file selection\n\t@info multiple=True is not handled properly by the Cache. You will need to create a function that properly handles\n\t\teach file (See spatial for an implementation)\n\t@info If you're examples are large files, or require significant computation, you may want to switch it to Upload instead.\n\t\"\"\"\n\n\t# If the user needs help with the formatting.\n\treturn [\n\tui.layout_columns(\n\t\tui.HTML(\"<a href=https://github.com/WishartLab/heatmapper2/wiki/Format target='_blank' rel='noopener noreferrer'>Format</a>\"),\n\t\tui.HTML(f\"<a href='https://github.com/WishartLab/heatmapper2/wiki/Interface#{project}' target='_blank' rel='noopener noreferrer'>Help</a>\"),\n\t\tcol_widths=[6,6]\n\t),\n\n\t# Specify whether to use example files, or upload one.\n\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"], selected=default, inline=True),\n\n\t# Only display an input dialog if the user is one Upload\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Upload'\",\n\t\tui.input_file(\"File\", upload_label, accept=types, multiple=multiple),\n\t),\n\n\t# Otherwise, add the example selection and an info button.\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Example'\",\n\t\tui.layout_columns(\n\t\t\tui.input_select(id=\"Example\", label=None, choices=examples, multiple=False),\n\t\t\tui.popover(ui.input_action_link(id=\"ExampleInfoButton\", label=\"Info\"), ui.output_text(\"ExampleInfo\")),\n\t\t\tcol_widths=[7,3],\n\t\t)\n\t),\n\t]\n\n\ndef MainTab(*args, m_type=ui.output_plot):\n\treturn ui.navset_tab(\n\t\tui.nav_panel(\"Heatmap\", m_type(id=\"Heatmap\", height=\"90vh\"), value=\"HeatmapTab\"),\n\t\tui.nav_panel(\"Table\",\n\t\t\tui.layout_columns(\n\t\t\t\tui.input_select(id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"]),\n\t\t\t\tui.input_action_button(\"Reset\", \"Reset Values\"),\n\t\t\t),\n\t\t\tui.output_data_frame(id=\"Table\"),\n\t\t\tvalue=\"TableTab\"\n\t\t),\n\t\t*args,\n\t\tid=\"MainTab\"\n\t)\n", "type": "text"}]