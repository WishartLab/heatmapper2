[{"name": "app.py", "content": "#\n# Heatmapper\n# Expression\n#\n# This file contains the ShinyLive application for Expression Heatmapper.\n# It can be run with the following command within this directory:\n#\t\tshinylive export . [site]\n# Where [site] is the destination of the site folder.\n#\n# If you would rather deploy the application as a PyShiny application,\n# run the following command within this directory:\n#\t\tshiny run\n#\n#\n\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom matplotlib.pyplot import figure, subplots, colorbar\nfrom matplotlib.colors import Normalize\nfrom scipy.cluster import hierarchy\nfrom pandas import DataFrame\n\nfrom shared import Table, Cache, NavBar, FileSelection\n\ndef server(input: Inputs, output: Outputs, session: Session):\n\t# Information about the Examples\n\tInfo = {\n\t\t\"example1.txt\": \"This example dataset is sample input retrieved from the website for the Ashley Lab Heatmap Builder.\",\n\t\t\"example2.txt\": \"This example dataset is sample input retrieved from an online tutorial by Yan Cui (ycui2@uthsc.edu).\",\n\t\t\"example3.txt\": \"This example dataset is retrieved from the online supplement to Eisen et al. (1998), which is a very well known paper about cluster analysis and visualization. The details of how the data was collected are outlined in the paper.\"\n\t}\n\n\tDataCache = Cache(\"expression\")\n\n\n\tasync def ProcessData():\n\t\t\"\"\"\n\t\t@brief Extracts the labels for each axis, and returns it alongside a DataFrame containing only the relevant data.\n\t\t@returns\tA list containing the labels for the y axis, a list containing the labels for the x axis, and a\n\t\t\t\t\t\t\tDataFrame containing the loaded data without those two columns.\n\t\t\"\"\"\n\t\tdf = await DataCache.Load(input)\n\n\t\tnames = [\"NAME\", \"ORF\", \"UNIQID\"]\n\n\t\tfor name in names:\n\t\t\tif name in df.columns:\n\t\t\t\tindex_labels = df[name]\n\t\t\t\tbreak\n\n\t\t# Drop the naming columns before linkage.\n\t\tdata = df.drop(columns=[col for col in names if col in df.columns])\n\t\tx_labels = [\"X\" + name if list(data.columns).count(name) == 1 else \"X\" + name + f\".{i+1}\" for i, name in enumerate(data.columns)]\n\n\t\treturn list(index_labels), x_labels, data\n\n\n\tdef GenerateDendrogram(data, ax, orientation, labels = [], invert=False):\n\t\t\"\"\"\n\t\t@brief General dendrogram generator.\n\t\t@param data: The DataFrame that contains the data to generate the dendrogram from.\n\t\t@param ax: The MatPlotLib Axis to assign tick marks to\n\t\t@param orientation: What orientation we should set the dendrogram to be. Can be \"Left\", \"Right\", \"Top\", or \"Bottom\"\n\t\t@param labels: An optional list of labels to add the dendrogram, labelling the X axis on Left/Right, and the Y on Top/Bottom\n\t\t@param invert: Whether to invert the DataFrame to generate Columnar dendrograms.\n\t\t@returns The dendrogram, mostly useful to aligning the Heatmap to the new ordering.\n\t\t\"\"\"\n\n\t\tmatrix = hierarchy.linkage(data.values.T if invert else data.values, method=input.ClusterMethod().lower(), metric=input.DistanceMethod().lower())\n\t\tdendrogram = hierarchy.dendrogram(matrix, ax=ax, orientation=orientation.lower())\n\n\t\t# If there are labels, sort them according to the dendrogram.\n\t\tif labels: labels = [labels[i] for i in dendrogram[\"leaves\"]]\n\n\t\t# Add ticks depending on the orientation.\n\t\tmatch orientation:\n\t\t\tcase \"Left\" | \"Right\":\n\t\t\t\tax.set_xticks([])\n\t\t\t\tax.set_yticklabels(labels, fontsize=input.TextSize())\n\t\t\tcase \"Top\" | \"Bottom\":\n\t\t\t\tax.set_yticks([])\n\t\t\t\tax.set_xticklabels(labels, fontsize=input.TextSize())\n\n\t\treturn dendrogram\n\n\n\tasync def GenerateHeatmap():\n\t\t\"\"\"\n\t\t@brief Generates the Heatmap\n\t\t@returns The heatmap\n\t\t\"\"\"\n\n\t\tindex_labels, x_labels, data = await ProcessData()\n\n\t\t# Create a figure with a heatmap and associated dendrograms\n\t\tfig = figure(figsize=(12, 10))\n\t\tgs = fig.add_gridspec(4, 2, height_ratios=[2, 8, 1, 1], width_ratios=[2, 8], hspace=0, wspace=0)\n\n\t\t# If we render the row dendrogram, we change the order of the index labels to match the dendrogram.\n\t\t# However, if we aren't rendering it, and thus row_dendrogram isn't defined, we simply assign df\n\t\t# To data, so the order changes when turning the toggle.\n\t\tif \"row\" in input.Features():\n\t\t\tax_row = fig.add_subplot(gs[1, 0])\n\t\t\trow_dendrogram = GenerateDendrogram(data, ax_row, \"Left\")\n\t\t\tax_row.axis(\"off\")\n\t\t\tindex_labels = [index_labels[i] for i in row_dendrogram[\"leaves\"]]\n\t\t\tdf = data.iloc[row_dendrogram[\"leaves\"]]\n\t\telse:\n\t\t\tdf = data\n\n\t\t# If we render the column dendrogram.\n\t\tif \"col\" in input.Features():\n\t\t\tax_col = fig.add_subplot(gs[0, 1])\n\t\t\tcol_dendrogram = GenerateDendrogram(data, ax_col, \"Top\", invert=True)\n\t\t\tax_col.axis(\"off\")\n\n\t\t# Handle normalization\n\t\tmatch input.ScaleType():\n\t\t\tcase \"Row\": df = df.div(df.max(axis=1), axis=0)\n\t\t\tcase \"Column\": df = df.div(df.max(axis=0), axis=1)\n\n\t\t# Render the heatmap.\n\t\tax_heatmap = fig.add_subplot(gs[1, 1])\n\t\theatmap = ax_heatmap.imshow(\n\t\t\tdf,\n\t\t\tcmap=input.ColorMap().lower(),\n\t\t\tinterpolation=input.Interpolation().lower(),\n\t\t\taspect=\"auto\",\n\t\t)\n\n\t\t# If we render the Y axis.\n\t\tif \"y\" in input.Features():\n\t\t\tax_heatmap.set_yticks(range(len(index_labels)))\n\t\t\tax_heatmap.set_yticklabels(index_labels, fontsize=input.TextSize())\n\t\t\tax_heatmap.yaxis.tick_right()\n\t\telse:\n\t\t\tax_heatmap.set_yticklabels([])\n\n\t\t# If we render the X axis.\n\t\tif \"x\" in input.Features():\n\t\t\tax_heatmap.set_xticks(range(len(x_labels)))\n\t\t\tax_heatmap.set_xticklabels(x_labels, rotation=90, fontsize=input.TextSize())\n\t\telse:\n\t\t\tax_heatmap.set_xticklabels([])\n\n\t\t# If we render the legend.\n\t\tif \"legend\" in input.Features():\n\t\t\tax_cbar = fig.add_subplot(gs[3, 1])\n\t\t\tcbar = fig.colorbar(heatmap, cax=ax_cbar, orientation=\"horizontal\")\n\n\t\treturn fig\n\n\n\t@output\n\t@render.data_frame\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, ignore_none=False, ignore_init=False)\n\tasync def LoadedTable(): return await DataCache.Load(input)\n\n\t@output\n\t@render.plot\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, input.ClusterMethod, input.DistanceMethod, input.TextSize, input.ScaleType, input.Interpolation, input.ColorMap, input.Features, ignore_none=False, ignore_init=False)\n\tasync def Heatmap(): return await GenerateHeatmap()\n\n\n\t@output\n\t@render.plot\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, input.Orientation, input.ClusterMethod, input.DistanceMethod, input.TextSize, ignore_none=False, ignore_init=False)\n\tasync def RowDendrogram():\n\t\tindex_labels, _, data = await ProcessData()\n\n\t\tfig = figure(figsize=(12, 10))\n\t\tax = fig.add_subplot(111)\n\n\t\tax.spines[\"top\"].set_visible(False)\n\t\tax.spines[\"right\"].set_visible(False)\n\t\tax.spines[\"bottom\"].set_visible(False)\n\t\tax.spines[\"left\"].set_visible(False)\n\n\t\tGenerateDendrogram(data, ax, input.Orientation(), index_labels)\n\t\treturn fig\n\n\n\t@output\n\t@render.plot\n\t@reactive.event(input.Update, input.Reset, input.Example, input.File, input.Orientation, input.ClusterMethod, input.DistanceMethod, input.TextSize, ignore_none=False, ignore_init=False)\n\tasync def ColumnDendrogram():\n\t\t_, x_labels, data = await ProcessData()\n\n\t\tfig = figure(figsize=(12, 10))\n\t\tax = fig.add_subplot(111)\n\n\t\tax.spines[\"top\"].set_visible(False)\n\t\tax.spines[\"right\"].set_visible(False)\n\t\tax.spines[\"bottom\"].set_visible(False)\n\t\tax.spines[\"left\"].set_visible(False)\n\n\t\tGenerateDendrogram(data, ax, input.Orientation(), x_labels, invert=True)\n\t\treturn fig\n\n\n\t@output\n\t@render.text\n\tdef ExampleInfo(): return Info[input.Example()]\n\n\n\t@render.download(filename=\"table.csv\")\n\tasync def DownloadTable(): df = await LoadData(); yield df.to_string()\n\n\t@reactive.Effect\n\t@reactive.event(input.Update)\n\tasync def Update(): await DataCache.Update(input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.Reset)\n\tasync def Reset(): await DataCache.Purge(input)\n\n\n\t@reactive.Effect\n\t@reactive.event(input.TableRow, input.TableCol, input.Example, input.File, input.Reset, input.Update)\n\tasync def UpdateTableValue():\n\t\t\"\"\"\n\t\t@brief Updates the label for the Value input to display the current value.\n\t\t\"\"\"\n\t\tdf = await DataCache.Load(input)\n\n\t\trows, columns = df.shape\n\t\trow, column = int(input.TableRow()), int(input.TableCol())\n\n\t\tif 0 <= row <= rows and 0 <= column <= columns:\n\t\t\tui.update_text(id=\"TableVal\", label=\"Value (\" + str(df.iloc[row, column]) + \")\"),\n\n\napp_ui = ui.page_fluid(\n\n\tNavBar(\"Expression\"),\n\n\tui.layout_sidebar(\n\t\tui.sidebar(\n\n\t\t\tFileSelection(\n\t\t\t\texamples={\"example1.txt\": \"Example 1\", \"example2.txt\": \"Example 2\", \"example3.txt\": \"Example 3\"},\n\t\t\t\ttypes=[\".csv\", \".txt\", \".xlsx\", \".pdb\", \".dat\"]\n\t\t\t),\n\n\t\t\t# https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.linkage.html\n\t\t\tui.input_select(id=\"ClusterMethod\", label=\"Clustering Method\", choices=[\"Single\", \"Complete\", \"Average\", \"Weighted\", \"Centroid\", \"Median\", \"Ward\"], selected=\"Average\"),\n\n\t\t\t# https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html#scipy.spatial.distance.pdist\n\t\t\tui.input_select(id=\"DistanceMethod\", label=\"Distance Method\", choices=[\"Braycurtis\", \"Canberra\", \"Chebyshev\", \"Cityblock\", \"Correlation\", \"Cosine\", \"Dice\", \"Euclidean\", \"Hamming\", \"Jaccard\", \"Jensenshannon\", \"Kulczynski1\", \"Mahalanobis\", \"Matching\", \"Minkowski\", \"Rogerstanimoto\", \"Russellrao\", \"Seuclidean\", \"Sokalmichener\", \"Sokalsneath\", \"Sqeuclidean\", \"Yule\"], selected=\"Euclidean\"),\n\n\t\t\t# Customize the text size of the axes.\n\t\t\tui.input_numeric(id=\"TextSize\", label=\"Text Size\", value=8, min=1, max=50, step=1),\n\n\t\t\t# Settings pertaining to the Heatmap view.\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'Interactive'\",\n\t\t\t\tui.br(),\n\n\t\t\t\t# Define how the colors are scaled.\n\t\t\t\tui.input_select(id=\"ScaleType\", label=\"Scale Type\", choices=[\"Row\", \"Column\", \"None\"], selected=\"None\"),\n\n\t\t\t\t# https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html\n\t\t\t\tui.input_select(id=\"Interpolation\", label=\"Interpolation\", choices=[\"None\", \"Antialiased\", \"Nearest\", \"Bilinear\", \"Bicubic\", \"Spline16\", \"Spline36\", \"Hanning\", \"Hamming\", \"Hermite\", \"Kaiser\", \"Quadric\", \"Catrom\", \"Gaussian\", \"Bessel\", \"Mitchell\", \"Sinc\", \"Lanczos\", \"Blackman\"], selected=\"Nearest\"),\n\n\t\t\t\t# Set the ColorMap used.\n\t\t\t\tui.input_select(id=\"ColorMap\", label=\"Color Map\", choices=[\"Viridis\", \"Plasma\", \"Inferno\", \"Magma\", \"Cividis\"], selected=\"Viridis\"),\n\n\t\t\t\t# Toggle rendering features. All are on by default.\n\t\t\t\tui.input_checkbox_group(id=\"Features\", label=\"Heatmap Features\",\n\t\t\t\t\tchoices={\"row\": \"Row Dendrogram\", \"col\": \"Column Dendrogram\", \"x\": \"X Labels\", \"y\": \"Y Labels\", \"legend\": \"Legend\"},\n\t\t\t\t\tselected=[\"row\", \"col\", \"x\", \"y\", \"legend\"])\n\t\t\t),\n\n\t\t\t# Settings pertaining to the dendrogram view.\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'Row' || input.MainTab === 'Column'\",\n\t\t\t\tui.br(),\n\n\t\t\t\t# Define the Orientation of the dendrogram in the Tab\n\t\t\t\tui.input_select(id=\"Orientation\", label=\"Dendrogram Orientation\", choices=[\"Top\", \"Bottom\", \"Left\", \"Right\"], selected=\"Left\"),\n\t\t\t),\n\n\t\t\t# Add the download buttons. You can download the heatmap by right clicking it :)\n\t\t\tui.download_button(\"DownloadTable\", \"Download Table\"),\n\n\t\t\tid=\"SidebarPanel\",\n\t\t),\n\n\t\t# Add the main interface tabs.\n\t\tui.navset_tab(\n\t\t\t\tui.nav_panel(\"Interactive\", ui.output_plot(\"Heatmap\", height=\"90vh\"), value=\"Interactive\"),\n\t\t\t\tui.nav_panel(\"Row Dendrogram\", ui.output_plot(\"RowDendrogram\", height=\"90vh\"), value=\"Row\"),\n\t\t\t\tui.nav_panel(\"Column Dendrogram\", ui.output_plot(\"ColumnDendrogram\", height=\"90vh\"), value=\"Column\"),\n\t\t\t\tTable,\n\t\t\t\tid=\"MainTab\"\n\t\t),\n\t)\n)\n\napp = App(app_ui, server)", "type": "text"}, {"name": "shared.py", "content": "#\n# Heatmapper\n# Shared\n#\n# This file contains shared functionality between Heatmapper applications. It is not a standalone application.\n# Due to the way ShinyLive exports applications, this file is symlinked into each project to reduce redundancy.\n#\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nfrom pandas import DataFrame, read_csv, read_excel, read_table\nfrom io import BytesIO\nfrom sys import modules\nfrom copy import deepcopy\nfrom pathlib import Path\n\n# If pyodide is found, we're running WebAssembly.\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tPyodide = True\n# Otherwise,\nelse:\n\tfrom os.path import exists\n\tPyodide = False\n\n\nTemporalColumns = {\"time\", \"date\"}\n\n\ndef Filter(columns, good_columns, bad_columns):\n\tret = None\n\tfor column in columns:\n\t\tlowered = column.lower()\n\t\tif lowered in good_columns:\n\t\t\treturn column\n\t\telif lowered in bad_columns:\n\t\t\tbreak\n\t\telif ret is not None:\n\t\t\tret = column\n\treturn ret\n\n\nclass Cache:\n\t\"\"\"\n\t@brief A class that encompasses fetching/storing web resources.\n\t\"\"\"\n\n\t@staticmethod\n\tdef DefaultHandler(n, i):\n\t\t\"\"\"\n\t\t@brief The default handler. It can handle csv, xlsx, and defaults all other files to read_table\n\t\t@param n: The name of the file. We use this for pattern matching against the suffix.\n\t\t@param i: The binary of the file (Either via read() or BytesIO())\n\t\t@returns: A null-filled DataFrame.\n\t\t\"\"\"\n\t\tmatch Path(n).suffix:\n\t\t\tcase \".csv\": df = read_csv(i)\n\t\t\tcase \".xlsx\": df = read_excel(i)\n\t\t\tcase _: df = read_table(i)\n\t\treturn df.fillna(0)\n\n\n\t@staticmethod\n\tasync def Remote(url): r = await pyfetch(url); return await r.bytes() if r.ok else None\n\n\n\t@staticmethod\n\tasync def Local(url): return open(url, \"rb\").read() if exists(url) else None\n\n\n\tdef __init__(self, project, DataHandler = DefaultHandler):\n\t\t\"\"\"\n\t\t@brief Initialize an instance of the Cache object.\n\t\t@param project: The name of the project. This is used to fetch web resources.\n\t\t@param DataHandler:\tThe function that should be called to process files. It should\n\t\t\t\t\t\t\t\t\t\t\t\ttake a name, and a binary stream, and return a DataFrame.\n\t\t\"\"\"\n\n\t\t# The primary cache is immutable, and is used when the resource has not been fetched before.\n\t\tself._primary = {}\n\n\t\t# The secondary cache is mutable, and is populated by the primary cache. Purge deletes from here.\n\t\tself._secondary = {}\n\n\t\t# The data handler for processing the binary files.\n\t\tself._handler = DataHandler\n\n\t\t# If we're in a Pyodide environment, we fetch resources from the web.\n\t\tif Pyodide:\n\t\t\tself.Download = lambda url: Cache.Remote(url)\n\t\t\tself.Source = \"https://raw.githubusercontent.com/kkernick/kkernick.github.io/main/{}/example_input/\".format(project)\n\n\t\t# Otherwise, we fetch locally.\n\t\telse:\n\t\t\tself.Download = lambda url: Cache.Local(url)\n\t\t\tself.Source = \"../example_input/\"\n\n\n\tasync def Load(self, input, copy=False):\n\t\tn = await self.N(input);\n\t\tdf = DataFrame() if n is None else self._secondary[n]\n\t\treturn deepcopy(df) if copy else df\n\n\n\tasync def N(self, input):\n\t\t\"\"\"\n\t\t@brief Caches whatever the user has currently uploaded/selection, returning the identifier within the secondary cache.\n\t\t@param input: The Shiny input variable. Importantly, these must be defined:\n\t\t\tinput.File: The uploaded file\n\t\t\tinput.Example: The selected example file\n\t\t\tinput.SourceFile: Whether the user wants \"Upload\" or \"Example\"\n\t\t@returns: The identifier. You should probably use Load() unless you need this.\n\t\t\"\"\"\n\n\t\t# Grab an uploaded file, if its done, or grab an example (Using a cache to prevent redownload)\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.File()\n\t\t\tif file is None: return None\n\t\t\tn = file[0][\"name\"]\n\n\t\t\t# Populate the base cache, if we need to\n\t\t\tif n not in self._primary: self._primary[n] = self._handler(n, read(file[0][\"datapath\"], \"wb\"))\n\n\t\telse:\n\t\t\tn = input.Example()\n\t\t\tif n not in self._primary: self._primary[n] = self._handler(n, BytesIO(await self.Download(self.Source + n)))\n\t\tif n not in self._secondary: self._secondary[n] = deepcopy(self._primary[n])\n\t\treturn n\n\n\n\tdef Cache(self): return self._secondary\n\n\n\tasync def Update(self, input):\n\t\t\"\"\"\n\t\t@brief Updates information within the secondary cache based on user selection\n\t\t@param input: The Shiny input. Importantly, these must be defined:\n\t\t\tinput.TableRow: The row to modify\n\t\t\tinput.TableCol: The column to modify\n\t\t\tinput.TableVal: What the user wants to set as the new value\n\t\t@info This function should be called on a reactive hook for a \"Update\" button.\n\t\t\"\"\"\n\n\t\t# Get the data\n\t\tdf = await self.Load(input)\n\t\trow_count, column_count = df.shape\n\t\trow, column = input.TableRow(), input.TableCol()\n\n\t\t# So long as row and column are sane, update.\n\t\tif row < row_count and column < column_count:\n\t\t\tmatch input.Type():\n\t\t\t\tcase \"Integer\": df.iloc[row, column] = int(input.TableVal())\n\t\t\t\tcase \"Float\": df.iloc[row, column] = float(input.TableVal())\n\t\t\t\tcase \"String\": df.iloc[row, column] = input.TableVal()\n\n\n\tasync def Purge(self, input):\n\t\t\"\"\"\n\t\t@brief Purges the secondary cache of whatever the user has uploaded/selected\n\t\t@param input: The Shiny input. See N() for required objects.\n\t\t@info This function should be called on a reactive hook for a \"Reset\" button.\n\t\t\"\"\"\n\t\tif input.SourceFile() == \"Upload\":\n\t\t\tfile: list[FileInfo] | None = input.File()\n\t\t\tif file is None: return None\n\t\t\tn = file[0][\"name\"]\n\t\telse:\n\t\t\tn = input.Example()\n\t\tdel self._secondary[n]\n\n\ndef NavBar(current):\n\t\"\"\"\n\t@brief Returns a Navigation Bar for each project, with the current project selected.\n\t@returns A list, containing a ui.panel_title, and a ui.navset_bar.\n\t\"\"\"\n\n\treturn [\n\t\t\tui.panel_title(title=None, window_title=\"Heatmapper\"),\n\n\t\tui.navset_bar(\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/expression/site/index.html>Expression</a>'), value=\"Expression\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/pairwise/site/index.html>Pairwise</a>'), value=\"Pairwise\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/image/site/index.html>Image</a>'), value=\"Image\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/geomap/site/index.html>Geomap</a>'), value=\"Geomap\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/geocoordinate/site/index.html>Geocoordinate</a>'), value=\"Geocoordinate\"),\n\t\t\t\tui.nav_panel(ui.HTML('<a href=https://kkernick.github.io/about/site/index.html>About</a>'), value=\"About\"),\n\t\t\t\ttitle=\"Heatmapper\",\n\t\t\t\tselected=current,\n\t\t)\n\t]\n\n\ndef FileSelection(examples, types):\n\t\"\"\"\n\t@brief Returns the file selection dialog for the user to upload/select an example\n\t@param examples: Either a list of example file names, or a dictionary mapping\n\t@param types: The valid file extensions for user uploaded files.\n\t@returns A list, containing the necessary ui components for uploading/selecting\n\t@info The returns elements are named:\n\t\tinput.SourceFile: The ui.input_radio_buttons for whether the user wants to choose an \"Example\" or \"Upload\"\n\t\tinput.File: The ui.input_file for user uploaded files.\n\t\tinput.Example: The ui.input_select for an example file selection\n\t\"\"\"\n\n\t# If the user needs help with the formatting.\n\treturn [ui.HTML('<a href=https://kkernick.github.io/about/site/index.html>Data Format</a>'),\n\n\t# Specify whether to use example files, or upload one.\n\tui.input_radio_buttons(id=\"SourceFile\", label=\"Specify a Source File\", choices=[\"Example\", \"Upload\"], selected=\"Example\", inline=True),\n\n\t# Only display an input dialog if the user is one Upload\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Upload'\",\n\t\tui.input_file(\"File\", \"Choose a File\", accept=types, multiple=False),\n\t),\n\n\t# Otherwise, add the example selection and an info button.\n\tui.panel_conditional(\n\t\t\"input.SourceFile === 'Example'\",\n\t\tui.layout_columns(\n\t\t\tui.input_select(id=\"Example\", label=None, choices=examples, multiple=False),\n\t\t\tui.popover(ui.input_action_link(id=\"ExampleInfoButton\", label=\"Info\"), ui.output_text(\"ExampleInfo\")),\n\t\t\tcol_widths=[10,2],\n\t\t)\n\t)]\n\n\n# The Table element\nTable = ui.nav_panel(\"Table\",\n\tui.layout_columns(\n\t\tui.input_numeric(\"TableRow\", \"Row\", 0),\n\t\tui.input_numeric(\"TableCol\", \"Column\", 0),\n\t\tui.input_text(\"TableVal\", \"Value\", 0),\n\t\tui.input_select(id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"]),\n\t\tcol_widths=[2,2,6,2],\n\t),\n\tui.layout_columns(\n\t\tui.input_action_button(\"Update\", \"Update\"),\n\t\tui.input_action_button(\"Reset\", \"Reset Values\"),\n\t),\n\tui.output_data_frame(\"LoadedTable\"),\n)\n", "type": "text"}]